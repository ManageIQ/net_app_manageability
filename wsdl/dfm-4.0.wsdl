<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:na="http://www.netapp.com/management/v1" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsi="http://ws-i.org/schemas/conformanceClaim/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="NetAppDfm" targetNamespace="http://www.netapp.com/management/v1">
    <types>
        <xsd:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://www.netapp.com/management/v1">
            <xsd:element name="AggregateListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The AggregateListInfoIter* set of APIs are used To retrieve the list of Aggregates. AggregateListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the AggregateListInfoIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="AggregateListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check AggregateListInfoIterStart. The AggregateListInfoIterNext API is used To iterate over the Members of the Aggregates stored in the temporary store created by the AggregateListInfoIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous AggregateListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by AggregateListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Aggregates" type="na:ArrayOfAggregateInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Aggregates.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The AggregateListInfoIter* set of APIs are used To retrieve the list of Aggregates in DFM. The AggregateListInfoIterStart API is used To load the list of Aggregates into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Aggregates in the temporary store. If AggregateListInfoIterStart is invoked twice, then two distinct temporary stores are created. If neither AggregateNameOrId or aggr-group-name-or-id are provided, all Aggregates will be listed. If either, but not both are provided, the Aggregate or all Aggregates in the Group will be listed respectively. If AggregateNameOrId and aggr-group-name-or-id are provided, the Aggregate will be listed only if it is under the specified Group.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AggregateType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Filter by Type of Aggregate. Possible Values are: &lt;ul&gt; &lt;li&gt; traditional &lt;li&gt; Aggregate &lt;li&gt; striped &lt;/ul&gt; If no AggregateType input is supplied, all types of Aggregates will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BlockType" type="na:FileSystemBlockType">
                            <xsd:annotation>
                                <xsd:documentation>Filter by file system block Type of the Aggregate. If no BlockType input is supplied, all types of Aggregates will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDatasetSpaceInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, a list of Datasets that consume space From this Aggregate and the actual space consumed is returned in DatasetsSpaceInfo. Default Value: false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each Aggregate which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDirectMemberOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only return the Aggregates that are direct Members of the specified Resource Group. Default Value is false. This field is meaningful only if a Resource Group Name or Id is given for the ObjectNameOrId field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Aggregates that have been set To be ignored for purposes of data protection. If false, only list Aggregates that have not been set To be ignored for purposes of data protection. If not specified, list all Aggregates without taking into account whether they have been ignored or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsInDataset" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Aggregates which only contain data which is protected by a Dataset. If false, only list Aggregates containing data which is not protected by a Dataset. If not specified, list all Aggregates whether they are in a Dataset or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsUnprotected" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Aggregates that are not protected, which means the Aggregate is: &lt;ul&gt; &lt;li&gt; 1. not in any Resource pool. &lt;li&gt; 2. not a child of a Host that is a member of any Resource pool. &lt;li&gt; and 3. not a member of a node in a Dataset with protection Policy assigned. &lt;/ul&gt; If false or not set, list all Aggregates.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Aggregates for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Resource Pool &lt;li&gt; Dataset &lt;li&gt; Storage Set &lt;li&gt; Host &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;/ul&gt; If ObjectNameOrId identifies an Aggregate, that single Aggregate will be returned. If ObjectNameOrId resolves To more than one Aggregate, all of them will be returned. If no ObjectNameOrId is provided, all Aggregates will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RbacOperation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of an RBAC Operation. If specified, only return Aggregates for which authenticated admin has the required Capability. A Capability is an operation/resource pair. The Resource is the Volume where the Aggregate lives. The possible Values that can be specified for Operation can be obtained by calling RbacOperationInfoList. If Operation is not specified, then it defaults To DFM.Database.Read. For more information about operations, Capabilities and user roles, see the RBAC APIs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourcepoolFilter" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Possible Value: 'in_rpool', 'not_in_rpool', 'all'. If set To 'in_rpool', only list Aggregates that are in a Resource pool. If set To 'not_in_rpool', only list Aggregates that are not in a Resource pool. If set To 'all', then list all Aggregates. If a Value is not specified, then 'all' will be the default. An Aggregate is said To be in a Resource pool if either the Aggregate or the storage system containing the Aggregate is a member of a Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumesToMigrate" type="na:ArrayOfObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>This is a filter To return a list of candidate destination Aggregates where the Volumes in VolumesToMigrate can be migrated To. An ordered list of candidate Aggregates are returned based on free space. Each ObjectNameOrId in VolumesToMigrate input should be the identifier or full Name of a Volume and they should all belong To the same Source Aggregate. Returning the list of candidate Aggregates for migration can potentially take some time To compute.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with AggregateListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To AggregateListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an Aggregate's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Aggregate. &lt;li&gt; EINVALIDINPUT - When invalid input specified. &lt;li&gt; EOBJECTNOTFOUND - When the AggregateNameOrId does not correspond To an Aggregate. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AggregateNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Aggregate To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To ignore this object for purposes of data protection.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementAddOperation">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a space management Operation as part of this space management session. The actual Operation is not carried out unless AggregateSpaceManagementCommit is called. If this Operation cannot be carried out, then ESPACEMGMTCONFLICTOP will be returned The following rules apply when adding an Operation To the session. &lt;ul&gt; &lt;li&gt; A session cannot have 2 operations of same Type for a give Volume. For example two Volume resize operations cannot be added for the same Volume To a session. If this check fails the api will return ESPACEMGMTCONFLICTOP Error. &lt;li&gt; If a Volume migration Operation is added To a session then other session management operations cannot be added To the session. Similarly a Volume migration cannot be added To a session if other Type of Operation is already added To session. If this check fails the api will return ESPACEMGMTCONFLICTOP Error. &lt;/ul&gt; If this Operation leads To Errors in DryRunResults that are returned, then this Operation is not added To the session.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="SpaceManagementOperationInfo" type="na:SpaceManagementOperationInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a space management Operation To be added To the session.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SpaceManagementSessionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the space management session on an Aggregate To which this space management Operation has To be added. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementAddOperationResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AggregateDiffSpaceInfos" type="na:ArrayOfAggregateSpaceInfo">
                            <xsd:annotation>
                                <xsd:documentation>Returns the difference in Aggregate space consumption (i.e used space and committed space) due To this space management Operation only on the session Aggregate as well as other Aggregates affected by this Operation (for example Volume migration affects both session Aggregate and destination Aggregate.) The Values returned in AggregateSpaceInfo can be positive or negetive depending on whether the Operation consumes or frees up space on the Aggregates. For example Volume migration frees up space on the Source Aggregate and consumes space on the destination Aggregate.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementBegin">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Open a space management session To run space management operations on an Aggregate.&lt;P&gt; This allows adding a set of space management operations in a session, getting the difference in space consumption due To these set of operations and then committing all the operations. A space management session must be started before invoking the following ZAPIs: &lt;UL&gt; &lt;LI&gt;AggregateSpaceManagementAddOperation &lt;LI&gt;AggregateSpaceManagementRemoveOperation &lt;LI&gt;AggregateSpaceManagementCommit &lt;LI&gt;AggregateSpaceManagementRollback &lt;/UL&gt; Use AggregateSpaceManagementCommit To commit the changes and To start Jobs which will carry out the space management operations. &lt;P&gt; Use AggregateSpaceManagementRollback To rollback the session. This will not submit any Jobs for space management operations. &lt;P&gt; After 24 hours, a session can be opened on the same Aggregate by another client without the Force Option. This will cause any space management operations that were part of the session To be discarded.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AggregateNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Aggregate on which To open the space management session.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>By default, Force is false. If true, and a space management session is already in progress on the specified Aggregate the previous space management session is rolled back and a new edit session is begun.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementBeginResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="SpaceManagementSessionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the space management session. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementCommit">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Commit the space management operations added as part of this space management session. &lt;P&gt; The session that was opened on the Aggregate will be released once all the space management Jobs that were part of the session are queued To be executed eventually.&lt;P&gt; This will not wait for the Jobs To be executed.&lt;P&gt; Use the &lt;b&gt;DryRun&lt;/b&gt; Option To test the commit. It returns a set of DryRun Results for each space management Operation that was added as part of this session. &lt;p&gt; DryRunResults is a set of steps that the server will take To carry out the space management Operation &lt;p&gt;When DryRun is true, it also returns the projected used and committed space of the Aggregate on which the space management session was opened and other dependent Aggregates in case of migration operations. &lt;p&gt; If &lt;b&gt;DryRun&lt;/b&gt; is false, then before the call returns, the system submits Jobs To the provisioning engine To execute.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the DryRunResults list for each space management Operation and AggregateSpaceInfos which gives the projected used and committed space of the Aggregate(s) as a Result of space management operations added To the session. &lt;p&gt; The DryRunResults list contains actions that would be taken should the changes be committed without actually committing the changes. &lt;p&gt; The session is not released after a dry run. By default, DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SpaceManagementSessionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the space management session on an Aggregate Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementCommitResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AggregateSpaceInfos" type="na:ArrayOfAggregateSpaceInfo">
                            <xsd:annotation>
                                <xsd:documentation>Returns overall Effect of space management operations added To the session on the used and committed space of all affected Aggregates (i.e Aggregate on which the space management session is started and the Aggregates affected by space management operations added To the session. For example migration effects two Aggregates, session Aggregate and destination Aggregate). &lt;P&gt; The space Effect is calculated by obtaining the space freed or consumed by each Operation and by adding or subtracting it From the current used and committed space of the Aggregate. &lt;P&gt; Returned only if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SpaceManagementResults" type="na:ArrayOfSpaceManagementResultInfo">
                            <xsd:annotation>
                                <xsd:documentation>Results of a commit Operation for each space management Operation that was added in this session.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementRemoveOperation">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove a space management Operation that was added as part of this space management session.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Object whose space management Operation has To be removed From this session.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SpaceManagementOpType" type="na:SpaceManagementOpType">
                            <xsd:annotation>
                                <xsd:documentation>Type of space management Operation To be removed for the object From this session.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SpaceManagementSessionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the space management session on an Aggregate From which this space management Operation has To be removed. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementRemoveOperationResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AggregateDiffSpaceInfos" type="na:ArrayOfAggregateSpaceInfo">
                            <xsd:annotation>
                                <xsd:documentation>Returns difference in Aggregate space consumption (i.e used space and committed space) caused by removing this space magagement Operation From the session. The Values returned here are same as the Values returned by AggregateSpaceManagementAddOperation zapi (called when adding this Operation To the session) but with the signs reversed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementRollback">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Release the session opened for space management on an Aggregate. All the space management operations that were submitted as part of the space management session would be discarded.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="SpaceManagementSessionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the space management session on an Aggregate To be rolled back. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AggregateSpaceManagementRollbackResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="AlarmCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a DFM alarm. The AlarmInfo element specifies all the parameters of the new alarm. &lt;P&gt; Note that it is possible To specify a combination of the EventName, EventSeverity and EventClass such that this alarm will never be triggered. It is the user's responsibility To verify these settings are useful. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EINVALIDEMAILADDR - If the email Address has spaces, semi-colons or unprintable characters. &lt;li&gt; EINVALIDEVENTSEVERITY - If the EventSeverity specified is not one of 'normal', 'information', 'unknown', 'warning', 'Error', 'critical', 'emergency'. &lt;li&gt; EINVALIDEVENTCLASSEXP - If the regular expression specified for the EventClass is not a valid POSIX.1 regular expression. &lt;li&gt; EINVALIDALARMTIME - If the time-specified for TimeFrom or TimeTo is greater than 86399 ((24 * 60 * 60) - 1) seconds or if only one of TimeFrom and TimeTo Values are specified. &lt;li&gt; EINVALIDTRAPADDR - If the trap Host specified is not reachable or when the port is greater than 65535 (2^15 - 1) &lt;li&gt; ENOSUCHEVENT - If the event Name specified is not a valid EventName of DFM. &lt;li&gt; EGROUPDOESNOTEXIST - If the Group specified in the alarm parameters is not a DFM Resource Group. &lt;li&gt; ENOTFOUNDUSER - If the administrator Name specified in the alarm parameters is not a DFM administrator. &lt;li&gt; ERUNASUNSUPPORTED - If script-runas parameter is specified on a Windows DFM platform. &lt;li&gt; EINVALIDINPUT - If the EventSeverity Value is less than the Severity of the EventName event. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm is being configured. It is also set when the user sets script-runas parameter for the alarm and he does not have global DFM.Database.Write Capability. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AlarmInfo" type="na:AlarmInfo">
                            <xsd:annotation>
                                <xsd:documentation>Parameters of the new alarm.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AlarmId">
                            <xsd:annotation>
                                <xsd:documentation>ID of newly created alarm. Range: [1..2^15-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="32767"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete an alarm. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EALARMDOESNOTEXIST - If an alarm by the specified Id does not exist. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm being destroyed is configured. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AlarmId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the alarm. Range: [1..2^15-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="32767"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="AlarmGetDefaults">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the default Values of Attributes defined by this ZAPI set.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmGetDefaultsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AlarmDefaults" type="na:AlarmDefaults">
                            <xsd:annotation>
                                <xsd:documentation>The default Values of the Attributes defined by this ZAPI.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends listing of alarms.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag returned From AlarmListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="AlarmListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From list generated by AlarmListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in AlarmListInfoIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AlarmList" type="na:ArrayOfAlarmInfo">
                            <xsd:annotation>
                                <xsd:documentation>Array of alarm information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List all configured alarms.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AlarmId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the alarm To list. Range: [1..2^15-1]. If AlarmId is not specified, list all alarms.</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="32767"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with AlarmListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To AlarmListInfoIterNext or AlarmListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify settings of a DFM alarm. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EALARMDOESNOTEXIST - If an alarm by the specified Id does not exist. &lt;li&gt; EINVALIDEMAILADDR - If the email Address has spaces, semi-colons or unprintable characters. &lt;li&gt; EINVALIDEVENTSEVERITY - If the EventSeverity specified is not one of 'normal', 'information', 'unknown', 'warning', 'Error', 'critical', 'emergency'. &lt;li&gt; EINVALIDEVENTCLASSEXP - If the regular expression specified for the EventClass is not a valid POSIX.1 regular expression. &lt;li&gt; EINVALIDALARMTIME - If the time-specified for TimeFrom or TimeTo is greater than 86399 ((24 * 60 * 60) - 1) seconds or if only one of TimeFrom and TimeTo Values are specified. &lt;li&gt; EINVALIDTRAPADDR - If the trap Host specified is not reachable or when the port is greater than 65535 (2^15 - 1) &lt;li&gt; ENOSUCHEVENT - If the event Name specified is not a valid EventName of DFM. &lt;li&gt; EGROUPDOESNOTEXIST - If the Group specified in the alarm parameters is not a DFM Resource Group. &lt;li&gt; ENOTFOUNDUSER - If the administrator Name specified in the alarm parameters is not a DFM administrator. &lt;li&gt; ERUNASUNSUPPORTED - If script-runas parameter is specified on a Windows DFM platform. &lt;li&gt; EINVALIDINPUT - If the EventSeverity Value is less than the Severity of the EventName event. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm is being configured. It is also set when the user sets script-runas parameter for the alarm and he does not have DFM.Database.Write Capability at global level. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AlarmInfo" type="na:AlarmInfo">
                            <xsd:annotation>
                                <xsd:documentation>Parameters To be modfied for the alarm. Any Value specified in AlarmInfo replaces Values configured for the alarm. Specifying any optional Attributes with a blank Value removes that setting From the alarm. Specifying an empty array for Attributes that take an array will remove all the entries. Specifying an array element with Values replaces the existing Values. If an array element is not specified, then no change happens. If none of the optional parameters are specified, then this API does nothing. &lt;P&gt; Note that it is possible To specify a combination of the EventName, EventSeverity and EventClass such that this alarm will never be triggered. It is the user's responsibility To verify these settings are useful.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="AlarmTest">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Test an alarm by performing it's trigger actions. The test will be performed irrespective of whether the alarm is enabled or disabled. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EALARMDOESNOTEXIST - If an alarm by the specified Id does not exist. &lt;li&gt; EALARMTESTFAILED - If there is an Error sending the test alarm event To DataFabric Manager Event Service. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm is configured. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AlarmId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the alarm. Range: [1..2^15-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="32767"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AlarmTestResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ApiProxy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Proxy an API Request To a third party and return the API Response.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Request" type="na:Request">
                            <xsd:annotation>
                                <xsd:documentation>The Request To be forwarded To another server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Target" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Target Host. May be a Hostname (qualified or unqualified), a Vfiler Name or a Host agent. If the Target is not resolved during a Capability check, EOBJECTAMBIGUOUS or EOBJECTNOTFOUND is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timeout" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of seconds that the proxy server should wait for a Response before giving up.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Username" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>User account To use for executing the API. If none is specified, the highest Privilege available will be attempted. The proxy server may have a security Policy that restricts the accepted Values for this field. Invalid Values will cause EACCESSDENIED.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ApiProxyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Response" type="na:Response">
                            <xsd:annotation>
                                <xsd:documentation>The Response From the other server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AuditLogAddEntry">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Log an entry in the audit log file of DataFabric Manager</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AuditApplicationName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the application which wants To log an entry in the audit log file.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="AuditInterface" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Interface of the event being logged. Possible Values: web, command and log. Default Value is log.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="AuditIpAddress" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the IP Address of the machine From which the Operation is invoked.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="AuditMessage" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Application specific message for audit logging.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="AuditPriority" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the priority of the audit log entry. Possible Values: emergency, critical, Error, warning and information</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="AuditType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Type of the event being logged. Possible Values: input, Error, Action and output</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="AuditLogAddEntryResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CifsDomainListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a View list iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CifsDomainListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CifsDomainListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To CifsDomainListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CifsDomainListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CifsDomainList" type="na:ArrayOfCifsDomainInfo">
                            <xsd:annotation>
                                <xsd:documentation>A list of cifs domains.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CifsDomainListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of cifs domains on Hosts discovered by DFM.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CifsDomainListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with CifsDomainListInfoIterNext. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store. Used in subsequent calls To CifsDomainListInfoIterNext. or CifsDomainListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ClientRegistryDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove one or all name/value pairs From the persistent store.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ApplicationName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unique Name identifying the application requesting the data.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Match" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specify how the API should determine which name/value pairs To remove. Use "exact", the default, To specify that the Option Name must exactly Match "Option". The API returns ENAMENOTFOUND if an Option by that Name does not exist. Use "all" To indicate that the API should ignore the Option Name and return all name/value pairs. Use "regexp" To indicate that the API should interpret the Option as an extended regular expression, and return all name/value pairs where the Option Name matches the pattern specified in "Option". The API returns EINVALIDINPUTERROR if the "Option" is not a valid regular expression.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Option" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the Key To remove. See the Description of the "Match" parameter for more information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ClientRegistryDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ClientRegistryGet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve one or all name/value string pairs.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ApplicationName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unique Name identifying the application requesting the data.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Match" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Indicate how the API should find matching Options. Use "exact", the default, To specify that the Option Name must exactly Match "Option". The API returns ENAMENOTFOUND if no Option with that Name exists for this application. Use "all" To indicate that the API should ignore the Option Name and return all name/value pairs. Use "regexp" To indicate that the API should interpret the Option as an extended regular expression, and return all name/value pairs where the Option Name matches the pattern specified in "Option". In the case of "regexp", the API returns EINVALIDINPUTERROR if the "Option" is not a valid regular expression.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Option" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the registry Key To fetch. See the Description of the "Match" parameter for more information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ClientRegistryGetResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Options" type="na:ArrayOfClientOptionInfo">
                            <xsd:annotation>
                                <xsd:documentation>An array of name/value pair Objects.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ClientRegistrySet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Store one or more name/value string pairs.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ApplicationName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unique Name identifying the application requesting storage.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Options" type="na:ArrayOfClientOptionInfo">
                            <xsd:annotation>
                                <xsd:documentation>An array of name/value pair Objects.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ClientRegistrySetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CommentFieldCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a comment field. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDALREADYEXISTS - A comment field by the same Name already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EINVALIDINPUT - Invalid input was provided. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="CommentFieldInfo" type="na:CommentFieldInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information about the comment field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CommentFieldId" type="na:CommentFieldId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly created comment field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a comment field. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id does not exist. &lt;LI&gt; ESYSTEMCOMMENTFIELD - An attempt was made To Destroy a system comment field. &lt;LI&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="CommentFieldNameOrId" type="na:CommentFieldNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Comment field To be destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CommentFieldListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a list iteration that had been started by a call To CommentFieldListInfoIterStart. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To CommentFieldListInfoIterStart that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CommentFieldListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the next set of comment fields in the iteration started by CommentFieldListInfoIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of comment fields To return. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To CommentFieldListInfoIterStart that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CommentFields" type="na:ArrayOfCommentFieldInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of comment fields.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list all comment fields. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id or Name does not exist. &lt;LI&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CommentFieldNameOrId" type="na:CommentFieldNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only the specified comment field is returned. Otherwise information about all comment fields are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CommentFieldObjectTypes" type="na:ArrayOfCommentFieldObjectType">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only the specified comment field with specified object Type is returned. If not specified, then all comment fields will be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ShowSystemComments" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether system comment fields are returned. Default is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items present in the list iteration. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used To identify the list iteration. The list content resides in a temporary store in the server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a comment field. Currently only the Name of the comment field can be modified. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id does not exist. &lt;LI&gt; ECOMMENTFIELDALREADYEXISTS - A comment field by the same Name already exists. &lt;LI&gt; ESYSTEMCOMMENTFIELD - An attempt was made To modify a system comment field. &lt;LI&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;LI&gt; EINVALIDINPUT - Invalid input was provided. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="CommentFieldNameOrId" type="na:CommentFieldNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the comment field which has To be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CommentFieldObjectTypes" type="na:ArrayOfCommentFieldObjectType">
                            <xsd:annotation>
                                <xsd:documentation>Object Type(s) of the comment field To be modified. If an object Type of the comment field does not exist, then the new object Type will be associated with the comment field. Any existing object Type of the comment field that is not specified in this input will be disassociated. If the input is empty, then all object types of the comment field will be disassociated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NewCommentFieldName" type="na:CommentFieldName">
                            <xsd:annotation>
                                <xsd:documentation>New Name of the comment field. May be omitted if only changing the comment field object types.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CommentFieldValuesListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a list iteration that had been started by a call To CommentFieldValuesListInfoIterStart. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To comment-field-values-list-iter-start that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldValuesListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="CommentFieldValuesListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the next set of comment field Values in the iteration started by comment-field-values-list-iter-start &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of comment field Values To return. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To comment-field-values-list-iter-start that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldValuesListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CommentFieldValues" type="na:ArrayOfCommentFieldValue">
                            <xsd:annotation>
                                <xsd:documentation>Comment field Values.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldValuesListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start iteration on listing comment field Values for Objects. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id or Name does not exist. &lt;li&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;li&gt; EACCESSDENIED - The user does not have DFM.Database.Read Capability on the specified object. If the object is a Dataset, then the user does not have DFM.Dataset.Read on the Dataset. &lt;li&gt; EOBJECTNOTFOUND - The specified object was not found. &lt;li&gt; EOBJECTAMBIGUOUS - The specified object Name could refer To more than a single object. Use object identifiers To disambiguate. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CommentFieldNameOrId" type="na:CommentFieldNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, the Values set for various Objects for the specified comment field is returned. Otherwise, list the comment field Values for all comment fields.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CommentFieldObjectTypes" type="na:ArrayOfCommentFieldObjectType">
                            <xsd:annotation>
                                <xsd:documentation>Object Type(s) of the comment field To be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the managed object. If specified all comment field Values set for that object is returned. Otherwise list the comment field Values for all Objects.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentFieldValuesListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items present in the list iteration. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used To identify the list iteration. The list content resides in a temporary store in the server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentSetObjectValue">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Set the Value of a comment field for a specified managed object. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id or Name does not exist. &lt;li&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;li&gt; EACCESSDENIED - The user does not have DFM.Database.Write Capability on the specified object. &lt;li&gt; EINVALIDINPUT - The specified comment Value is invalid. &lt;li&gt; EOBJECTNOTFOUND - The specified object was not found or the managed object was not a supported Type for setting Comments. &lt;li&gt; EOBJECTAMBIGUOUS - The specified object Name could refer To more than a single object. Use object identifiers To disambiguate. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="CommentFieldNameOrId" type="na:CommentFieldNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the comment field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CommentValue" type="na:CommentValue">
                            <xsd:annotation>
                                <xsd:documentation>Value of the comment field. An empty string can be used To unset the Value of the comment field for this object.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the managed object for which the Value of the comment has To be set. The supported object types for which a comment Value can be set are: &lt;ul&gt; &lt;li&gt;Dataset &lt;li&gt;Host &lt;li&gt;Volume &lt;li&gt;Qtree &lt;li&gt;lun_path &lt;li&gt;quota_user &lt;li&gt;resource_group &lt;li&gt;Aggregate &lt;li&gt;srm_path &lt;li&gt;resource_pool &lt;li&gt;dp_policy &lt;li&gt;dp_schedule &lt;li&gt;dp_throttle &lt;li&gt;prov_policy &lt;li&gt;ossv_directory &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="CommentSetObjectValueResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetAddMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add Members To an existing Dataset.&lt;P&gt; This API is for adding direct member Objects To one or more storage sets in the Dataset. Each storage set is identified by the data protection Policy node associated with it. &lt;P&gt;The types of storage Objects allowed To be added vary: &lt;UL&gt; &lt;LI&gt; Volumes, Qtrees and OSSV Directories are allowed in the storage set attached To a primary Policy node. &lt;/LI&gt; &lt;LI&gt; Only Volumes are allowed in a storage sets attached To secondary/destination nodes. &lt;/LI&gt; &lt;/UL&gt; It is legal To add storage Objects To multiple storage sets in a single call.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetMemberParameters" type="na:ArrayOfDatasetMemberParameter">
                            <xsd:annotation>
                                <xsd:documentation>List of Members To add To the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsExistingMemberOk" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If specified, the call will not return an Error if one or more Objects being added is already a member of the specified node. If an ancestor or child of an object is already a member, an Error will still be returned. By default, IsExistingMemberOk is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetAddMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetAddMemberByDynamicReference">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add dynamic reference To an existing Dataset.&lt;P&gt; By adding a dynamic reference, the Volumes, Qtrees, and ossv Directories referred To by the dynamic reference become implicit (indirect) Members of the Dataset. A dynamic reference can be added To a particular storage set in the Dataset by specifying the data protection Policy node associated with it. If necessary a new storage set is first created automatically before adding storage Objects To it.&lt;P&gt; The types of storage Objects allowed To be added vary: &lt;UL&gt; &lt;LI&gt; Storage systems, vFiler units, Aggregates and OSSV Hosts can be attached To a primary Policy node. &lt;/LI&gt; &lt;LI&gt; Storage systems, vFiler units and Aggregates are allowed in storage sets attached To secondary/destination nodes. &lt;/LI&gt; &lt;/UL&gt; It is legal To add storage Objects To multiple storage sets in a single call.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetDynamicReferenceParameters" type="na:ArrayOfDatasetDynamicReferenceParameter">
                            <xsd:annotation>
                                <xsd:documentation>List of dynamic-references To add To the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetAddMemberByDynamicReferenceResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetAddResourcepool">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add Resource pool To a single storage set that is part of a Dataset. The storage set is specified implicitly by the Name of the Policy node that maps To it.&lt;P&gt; Within the same edit session in which you call &lt;b&gt;DatasetAddResourcepool&lt;/b&gt;, you may also add or remove Members or dynamic references, or change the Dataset's Name, Description, &lt;b&gt;IsDpIgnored&lt;/b&gt;, &lt;b&gt;IsDpSuspended&lt;/b&gt;, or &lt;b&gt;IsSuspended&lt;/b&gt;. You may not change the data set's protection Policy or storage sets within the same edit session. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To modify the storage set or does not have DFM.ResourcePool.Provision on the specified Resource pool. &lt;LI&gt; EOBJECTAMBIGUOUS - The Name given for the storage set or Resource pool matches multiple storage sets or Resource pools. &lt;LI&gt; EOBJECTNOTFOUND - No storage set or Resource pool was found that has the given Name or identifier. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; ESTORAGESETNOTINDATASET - The specified storage set is not a part of the Dataset being edited. &lt;LI&gt; EDPPOLICYNODENOTFOUND - No DP Policy node was found that has the given Name. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EDSCONFLICTALREADYINDATASET - Object, its ancestor or descendent is already in Dataset. &lt;LI&gt; EDSCONFLICTSRCDESTINSAMEAGGR - Source data and destination data are in the same Aggregate. &lt;LI&gt; EDSCONFLICTALREADYINRESPOOL - Object, its ancestor or descendent is already in Resource pool. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the node in the data protection Policy that maps To the storage set. &lt;b&gt;DpNodeName&lt;/b&gt; must Match exactly the Name of one of the nodes in the data protection Policy that is currently assigned To the data set.&lt;P&gt; If &lt;b&gt;DpNodeName&lt;/b&gt; is not specified, then the storage set associated with the root node is modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset that was obtained by an earlier call To &lt;b&gt;DatasetEditBegin&lt;/b&gt;. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of a Resource pool To add To the storage set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetAddResourcepoolResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetBeginFailover">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Begin failover of a Dataset. &lt;P&gt;This API begins the process of failing over a Dataset To its disaster recovery storage. The failover process will break any mirror relationships between the primary and DR storage Objects and make the secondary storage available for use. &lt;P&gt;This API may only be invoked if the DR state of the data set is "ready". &lt;P&gt;Specifically, when the ZAPI runs, the following actions will take place: &lt;ol&gt; &lt;li&gt;The DR state of the Dataset will immediately change To "failing_over". &lt;li&gt;Any pending conformance tasks will be cancelled. &lt;li&gt;Any Jobs running against this Dataset will be aborted. &lt;li&gt;A failover job will be started To break any mirrors between the primary storage set and the DR storage set &lt;li&gt;Finally, the DR state of the Dataset will be updated To either "failed_over" or "failover_error" based on whether the failover job succeeded or not. &lt;/ol&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetBeginFailoverResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the failover job that is failing the Dataset over To its DR secondary. If there was an Error, the job Id will be 0. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetBeginFailoverScriptTest">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Begin test failover of a Dataset that only runs the the failover scripts and does not dequeue tasks, abort Jobs or change the DrState.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetBeginFailoverScriptTestResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the failover job that is just running the DR scripts for the Dataset. If there was an Error, the job Id will be 0. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetChangeDrState">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change the disaster recovery state of a Dataset. &lt;P&gt;This API sets the DR state of a Dataset To a new Value. Users may perform the following DR state transitions using this ZAPI: &lt;ul&gt; &lt;li&gt; From "failover_error" To "failed_over". &lt;li&gt; From "failover_error" To "ready". &lt;li&gt; From "failed_over" To "ready". &lt;/ul&gt; &lt;P&gt;If the "AllowInternalTransitions" element is present and true, the caller may make additional state transitions: &lt;ul&gt; &lt;li&gt; From "ready" To "failing_over" &lt;li&gt; From "failing_over" To "failed_over" &lt;li&gt; From "failing_over" To "failover_error" &lt;/ul&gt; These state transitions are intended To be used by Protection Manager server processes as part of a failover or failback sequence. Any attempt To perform other state transition will fail with an Error code of EDATASETWRONGDRSTATE. &lt;P&gt;The DR state of a Dataset will also change in one special case: &lt;ul&gt; &lt;li&gt;The Dataset is in a "failed_over" DR state &lt;li&gt;The caller changes the data protection Policy &lt;li&gt;The caller maps the storage set for the DR node of the old Policy To the root node of the new Policy (using DatasetSetStorageset) &lt;/ul&gt; When the edit session with these modifications is committed, the DR state will be set back To "ready".</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AllowInternalTransitions" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, allow server-only state transitions (e.g. From "failing_over" To "failed_over"). If not present or false, only allow user-initiated state transitions.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DrState" type="na:DrState">
                            <xsd:annotation>
                                <xsd:documentation>Desired DR state of Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetChangeDrStateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetConformBegin">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Begin a conformance run on a Dataset, To attempt To bring it into conformance with its data protection Policy and provisioning Policy. A conformance run consists of two main steps: &lt;UL&gt; &lt;LI&gt; Perform a &lt;b&gt;conformance check&lt;/b&gt; To determine both the Dataset's current conformance Status, and the set of actions needed To bring the Dataset into conformance. &lt;LI&gt; Perform the &lt;b&gt;conformance actions&lt;/b&gt; needed To bring the Dataset into conformance. &lt;/UL&gt; In addition, the Dataset's conformance Status is updated at various points during the conformance run. Whenever the conformance Status is updated, an event of Type "Dataset.conformance" is generated. &lt;P&gt; Successful completion of this ZAPI indicates that: the conformance check has completed successfully, the Dataset's conformance Status has been updated based on the Results of the conformance check, and the system has begun To take any needed conformance actions. &lt;P&gt; After the ZAPI returns, the system continues To perform conformance actions in the background, until all actions complete. Once all actions have completed, the Dataset's conformance Status is again updated. Note that at present, there is no ZAPI Interface for determining when all actions have completed. &lt;P&gt; If no Policy has been assigned To the Dataset, the conformance run completes immediately and performs no conformance actions. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To access the Dataset. &lt;LI&gt; EOBJECTNOTFOUND - No Dataset was found that has the given Name or ID. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AssumeConfirmation" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Value determining whether confirmation is given for all resolvable conformance actions that require user confirmation. One Key and sometimes undesirable resolvable conformance Action is the possible re-baseline of one or more relationships. If the Value is true, all conformance actions which require user confirmation will be executed as if confirmation is already granted. If the Value is false, all conformance actions which require user confirmation will not be executed. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object ID for the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetConformBeginResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new, empty Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplicationInfo" type="na:ApplicationInfo">
                            <xsd:annotation>
                                <xsd:documentation>If IsApplicationData is true, then this element will contain information about the application which manages this Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetAccessDetails" type="na:DatasetAccessDetails">
                            <xsd:annotation>
                                <xsd:documentation>Data access details for a Dataset that needs To be configured and provisioned in a way that it is capable of transparent migration. This enables all the storage in the primary node of the Dataset To be migrated To a different physical Resource without having To reconfigure the clients accessing this storage.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetContact" type="na:EmailAddressList">
                            <xsd:annotation>
                                <xsd:documentation>Contact for the Dataset, such as the owner's e-mail Address.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the new Dataset, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetMetadata" type="na:ArrayOfDfmMetadataField">
                            <xsd:annotation>
                                <xsd:documentation>Opaque metadata for Dataset. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new Dataset. It cannot be all numeric. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetOwner" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the owner of the Dataset, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Resource Group To which the newly created Dataset should be added To. User should have DFM.Dataset.Write Capability on the specified Group. Default Value: Global Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsApplicationData" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the Dataset is an application Dataset managed by an external application. The default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpSuspended" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Flag indicating whether or not the Dataset should be protected. This also indicates whether conformance checking of the Dataset is To be done or not. Default is False. &lt;P&gt; Deprecated field. Retained for backward compatibility. This field is deprecated in favour of IsSuspended, which suspends the Dataset for all automated actions (data protection and conformance check of the Dataset).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSuspended" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To suspend this Dataset for all automated actions (data protection and conformance check of the Dataset). Default is False. If present, this field takes precedence over IsDpSuspended.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OnlineMigration" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates, that the Dataset will be capable of non-disruptive migration. By default the migration will be disruptive. Default: false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProtectionPolicyId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the protection Policy To associate with this Dataset. This legacy parameter is only used if ProtectionPolicyNameOrId is not supplied. The dataprotection License is required for this input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProtectionPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the protection Policy To associate with this Dataset. This input is preferred over ProtectionPolicyId and if supplied then do not supply ProtectionPolicyId because ProtectionPolicyId will be ignored. The dataprotection License is required for this input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the provisioning Policy To be associated with the primary node of the Dataset. The Members of the primary node are provisioned based on this Policy. Once the provisioning Policy is associated with the Dataset node, the storage in the node is periodically monitored for conformance with the Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RequiresNonDisruptiveRestore" type="na:RequiresNonDisruptiveRestore">
                            <xsd:annotation>
                                <xsd:documentation>Specifies whether the Dataset should be configured To enable non-disruptive restores From backup destinations. &lt;P&gt;Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimezoneName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Timezone To assign To the root node. If specified, the Value must be a TimezoneName returned by TimezoneListInfoIterNext. If no Timezone is assigned, then the default system Timezone will be used.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VfilerNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the vFiler Unit To be attached To the primary node of the Dataset. If a vFiler Unit is attached, then all Members provisioned into this node will be exported over this vFiler Unit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeQtreeNamePrefix" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Prefix for Volume and Qtree names, up To 60 characters long. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DatasetId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the new Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a Dataset. The Dataset must be empty unless the "Force" Option is used.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CancelEditSessions" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Specifies if edit operations in progress on the Dataset should be cancelled. &lt;P&gt; If true, any edit operations in progress on the Dataset are rolled back before destroying the Dataset. &lt;P&gt; If CancelEditSessions is false, Dataset with pending edit operations cannot be destroyed. &lt;P&gt; Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset To Destroy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, allows destroying a Dataset that has Members or dynamic references. By default, only empty Datasets can be destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetDynamicReferenceListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of the dynamic references in the Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetDynamicReferenceListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetDynamicReferenceListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetDynamicReferenceListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next Records in the iteration started by DatasetDynamicReferenceListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetDynamicReferenceListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetDynamicReferenceListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DatasetDynamicReferences" type="na:ArrayOfDatasetDynamicReferenceInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of the dynamic references in the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetDynamicReferenceListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list the dynamic references in the Dataset. Volumes are not considered dynamic references because they are Members. (even though they can contain Qtrees)</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of Dataset whose dynamic references will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                            <xsd:annotation>
                                <xsd:documentation>List only the Members in this Policy node. If none is specified, then list Members in all Policy nodes. If both DpNodeName and StoragesetNameOrId are specified, then the Value of DpNodeName is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDeleted" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, dynamic references which are marked as deleted in the database are also returned. Otherwise, deleted dynamic references are not returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each member which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StoragesetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>List only the Members in this storage set. If none is specified, then list Members in all storagesets mapped To this Dataset's nodes. If both DpNodeName and StoragesetNameOrId are specified, then the Value of DpNodeName is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SuppressStatusRefresh" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, do not refresh the dynamic_reference Status. If false or omitted, the Status of all dynamic references will be refreshed before being returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetDynamicReferenceListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of items that have been saved for future retrieval with DatasetDynamicReferenceListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DatasetDynamicReferenceListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetEditBegin">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Obtain an edit lock To start modifying a Dataset. &lt;P&gt;Besides locking the Dataset itself, all storage sets in the Dataset are locked, as well as the data protection Policy if one is assigned. &lt;P&gt;An edit lock must be obtained before invoking the following ZAPIs: &lt;UL&gt; &lt;LI&gt;DatasetAddMember &lt;LI&gt;DatasetRemoveMember &lt;LI&gt;DatasetAddMemberByDynamicReference &lt;LI&gt;DatasetRemoveMemberByDynamicReference &lt;LI&gt;DatasetSetStorageset &lt;LI&gt;DatasetModify &lt;LI&gt;DatasetModifyNode &lt;LI&gt;DatasetAddResourcepool &lt;LI&gt;DatasetRemoveResourcepool &lt;LI&gt;DatasetProvisionMember &lt;LI&gt;DatasetResizeMember &lt;LI&gt;DatasetMemberDeleteSnapshots &lt;/UL&gt; Use DatasetEditCommit To commit the changes To the database. &lt;P&gt;Use DatasetEditRollback To undo the changes made To the Dataset. &lt;P&gt;After 24 hours, the lock can be taken by another client without the Force Option. This will cause any edits pending on the aborted session To be lost.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset To edit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>By default, Force is false. If true, and an edit is already in progress on the specified Dataset or an object the Dataset is dependent on (such as a data protection Policy), the previous edit session is rolled back and a new edit session is begun.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetEditBeginResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Dataset. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetEditCommit">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Commit changes made To a Dataset into the database.&lt;P&gt; The edit lock on the Dataset will be released after the changes have been successfully committed.&lt;P&gt; Use the &lt;b&gt;DryRun&lt;/b&gt; Option To test the commit. It invokes the conformance checker To return a list of actions that would be taken should the changes be actually committed. The &lt;b&gt;DryRun&lt;/b&gt; Option also returns a list of high level alerts To notify the user of rebaseline operations or system level issues related To successful conformance. &lt;P&gt; If &lt;b&gt;DryRun&lt;/b&gt; is false, then before the call returns, the system begins a &lt;b&gt;conformance run&lt;/b&gt; on the Dataset. (See &lt;b&gt;DatasetConformBegin&lt;/b&gt; for a Description of conformance runs.) If the system is To perform a &lt;b&gt;conformance run&lt;/b&gt; on the Dataset it will be done with the current Dataset edit session Value for AssumeConfirmation. The default Value for AssumeConfirmation is initially true when the edit session begins, but may be altered by certain changes To the Dataset made through the use of &lt;b&gt;DatasetModify&lt;/b&gt;. The optional &lt;b&gt;AssumeConfirmation&lt;/b&gt; Option may be used To specify if user confirmation is To be assumed or not for this &lt;b&gt;DatasetEditCommit&lt;/b&gt;. One Key, and sometimes undesirable, resolvable Action that requires user confirmation is the possible re-baseline of a relationship.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AssumeConfirmation" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Value determining whether confirmation is given for all resolvable conformance actions that require user confirmation. If the Value is true, all conformance actions which require user confirmation will be executed as if confirmation is already granted. If the Value is false, all conformance actions which require user confirmation will not be executed. The default Value is initially true when the edit session begins, but may be altered by certain changes To the Dataset made through the use of &lt;b&gt;DatasetModify&lt;/b&gt;. One Key, and sometimes undesirable, resolvable Action that requires user confirmation is the possible re-baseline of a relationship.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the DryRunResults list as well as the ConformanceAlerts list. The DryRunResults list contains actions that would be taken should the changes be committed without actually committing the changes. The ConformanceAlerts list contains high level alerts To notify a user of conditions that will impact any attempt To commit the changes. A conformance alert may warn that if the changes are committed, one or more rebaseline operations may be done. The conformance alerts may also warn of conditions that exist that may prevent the succesful conformance of Datasets. The edit lock is not released after a dry run. By default, DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Dataset. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDryRunReasonDetails" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true or omitted, then include any possible &lt;b&gt;DryRunReasonDetails&lt;/b&gt; along with the associated &lt;b&gt;DryRunResult&lt;/b&gt; element. Default Value is true. If false, the &lt;b&gt;DryRunReasonDetails&lt;/b&gt; will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetEditCommitResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ConformanceAlerts" type="na:ArrayOfConformanceAlert">
                            <xsd:annotation>
                                <xsd:documentation>Alerts that apply To the conformance check. Each alert describes one Type of Condition that a user should be aware of before attempting To conform any more Datasets. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsProvisioningFailure" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This element is returned only if DryRun is true and only when there was a provisioning Request issued in the edit session. If the dry run shows Errors for the provisioning Request its Value is TRUE, else FALSE. This element can be used by clients To distinguish the case where provisioning job will succeed, but the dry run contains Dataset conformance related Errors.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobIds" type="na:ArrayOfJobInfo">
                            <xsd:annotation>
                                <xsd:documentation>Job identifiers of provisioning requests or Dataset reexport Jobs. This output element is present only if &lt;ul&gt; &lt;li&gt;1. There were any provisioning requests issued in the edit session. &lt;li&gt;2. The Dataset is reexported due To change in provisioning Policy. &lt;/ul&gt; This is returned only if DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetEditRollback">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Roll back changes made To a Dataset. The edit lock on the Dataset will be released after the rollback.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Dataset. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetEditRollbackResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list Datasets.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DatasetListInfoIterStart. &lt;p&gt; If a Dataset has a data protection Policy assigned To it, the HasProtectionPolicy field will be true. If the client has suspended the Dataset, HasProtectionPolicy is still true, but IsDpSuspended and IsSuspended fields are also set To true To reflect this. When the client sets IsDpIgnored To true, nothing changes, except that, when the client requests the list of Datasets which are not ignored, the ignored Datasets will not be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Datasets" type="na:ArrayOfDatasetInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Datasets.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplicationName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Return only application Datasets managed by a particular Type of application. Up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ApplicationServerName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Return only application Datasets managed by an application running on a particular server. Up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DrState" type="na:DrState">
                            <xsd:annotation>
                                <xsd:documentation>Filter by DrState Value. If no DrState input is supplied, all Datasets will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HasProtection" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Datasets which have a data protection Policy and at least 1 relationship associated with them or the Policy has only 1 node. If false, only list Datasets which do not have any associated Policy or Datasets which have Policy with more than 1 node but do not have any associated relationship. If not set, list all Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HasProtectionPolicy" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Datasets which have a data protection Policy assigned To them. If false, only list Datasets which do not have any data protection Policy assigned. If not set, list all Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeConformanceCheckResults" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the detailed conformance check Results. If false or omitted, the conformance check Results, which are expensive To retrieve, will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeConformanceRunReasonDetails" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true or omitted and &lt;b&gt;IncludeConformanceCheckResults&lt;/b&gt; is also true, then include any possible &lt;b&gt;ConformanceRunReasonDetails&lt;/b&gt; along with the associated &lt;b&gt;ConformanceRunResult&lt;/b&gt; element. Default Value is true. If false, the &lt;b&gt;ConformanceRunReasonDetails&lt;/b&gt;, will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeExportSettings" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the export settings for the Dataset nodes will be present in the output of DatasetListInfoIterNext. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeMetadata" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, returns Dataset's metadata. If false, metadata, which can be large in Size, is not returned. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeMigrationInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the migration information for the Dataset is returned in DatasetListInfoIterNext. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeProtectionStatusProblems" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the detailed ProtectionStatusProblems if the Dataset does not have protection Status as "protected". Setting IncludeProtectionStatusProblems To true will generate an Error unless only one Dataset is specified From the other input parameters. If false or omitted, ProtectionStatusProblems, which can be expensive To retrieve, will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsApplicationData" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return only Datasets managed by an application. If false, return only Datasets which are not managed by an application. By default, return all Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Datasets that have been set To be ignored for purposes of data protection. If false, only list Datasets that have been not set To be ignored for purposes of data protection. If not specified, list all Datasets without taking into account whether they have been ignored or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDrCapable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return only Datasets with dp policies that are disaster recovery capable. If false, return only Datasets with policies that are not disaster recovery capable. By default, return all Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsProtected" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Datasets which have a data protection Policy assigned To them. If false, only list Datasets which do not have any data protection Policy assigned. If not set, list all Datasets. &lt;P&gt; Deprecated field. Retained for backward compatibility. This field is deprecated and To be replaced by HasProtectionPolicy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Dataset or Resource Group or provisioning Policy or storage Service. If a Resource Group is given, only the Datasets which are direct Members of the Group are returned. If a provisioning Policy is given, only those Datasets where one or more of its nodes is associated with the provisioning Policy are returned. If storage Service is given, only those Datasets which are associated with the storage Service are are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RequiresNonDisruptiveRestore" type="na:RequiresNonDisruptiveRestore">
                            <xsd:annotation>
                                <xsd:documentation>If true, return only Datasets requiring non-disruptive restore. If false, return only Datasets which do not require non-disruptive restore. By default, return all Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SuppressStatusRefresh" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, do not refresh the Dataset Status. If false or omitted, the Status of all queried Datasets will be re-calculated before being returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeQtreeNamePrefix" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Return only Datasets with a particular Type of custom Name prefix. Up To 60 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records that have been saved for future retrieval with DatasetListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DatasetListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberDedupeAbort">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Abort in-progress dedupe Operation on the given Volume member of the Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VolumeNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Volume member of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberDedupeAbortResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Id of the job that handles the deduplication Operation. This is returned only if there is an on-demand deduplication job running and will not be present if the deduplication Operation was triggered by the storage system. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberDedupeStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start deduplication Operation on specified Volume member of the given Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Identifier of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DedupeMemberRequestInfo" type="na:DedupeMemberRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details on member To be deduplicated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberDedupeStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Id of the job that handles the deduplication Operation. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberDeleteSnapshots">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete Snapshot copies of a Volume which is a member of the effective primary node of the Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the root node of the Dataset. The effective primary of a disaster recovery Dataset in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;The deletion of Snapshot copies happens in the background. &lt;P&gt;A provisioning job Id is returned in DatasetEditCommit zapi that represents the job which will delete the specified Snapshot copies. The Status of the job can be checked using DpJobListIterStart ZAPIs with the given JobId. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To delete Snapshot copies of the member. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EOBJECTNOTFOUND - No Volume by the given Name or identifier was found. &lt;LI&gt; ENOTINDATASET - Member is not in the primary node of the specified Dataset. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified member Name could refer To two or more Objects. Try again with the object identifier or object full Name. &lt;LI&gt; EINVALIDINPUT - No Snapshot copies are specified for deletion or both VolumeId and VolumeName are not given in input or at least one of the Snapshot copies specified for deletion is marked busy. &lt;LI&gt; ESNAPSHOTNOTFOUND - At least one of the Snapshot copy specified is not found on the Volume. &lt;LI&gt; EEDITSESSIONNOTFOUND - If the edit session specified in input is not found &lt;LI&gt; EEDITSESSIONOBJECTALREADYLOCKED - If the object being tried To lock in this Operation is already locked by some other edit session &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - If this Snapshot deletion Operation is conflicting with some other edit Operation in the same edit session &lt;LI&gt; EDATASETNOTINSTABLEDRSTATE - The Dataset is not in a stable disaster recovery state. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DeleteSnapshotsRequestInfo" type="na:DeleteSnapshotsRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details on the Volume and Snapshot copies To be deleted.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberDeleteSnapshotsResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetMemberListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of Dataset Members.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetMemberListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetMemberListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next Records in the iteration started by DatasetMemberListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetMemberListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DatasetMembers" type="na:ArrayOfDatasetMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of the Members of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Members of the Dataset. Dynamic references are not returned by this API, nor are Objects only associated with the Dataset by their inclusion in a dynamic reference.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset whose Members will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                            <xsd:annotation>
                                <xsd:documentation>List only the Members in this Policy node. If none is specified, then list Members in all Policy nodes. If both DpNodeName and StoragesetNameOrId are specified, then the Value of DpNodeName is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDeleted" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, Members which are marked as deleted in the database are also returned. Otherwise, deleted Members are not returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeExportsInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the export information of Members is included in output. If the member is exported over NFS, the NFS export Name is retuned in NfsExportName element in DatasetMemberInfo. If the member is exported over CIFS, the share names are returned in CifsShareNames array in DatasetMemberInfo. In case the Members are accessed using both NFS and CIFS (i.e Mixed mode) then both NFS export Name and CIFS share names are returned. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIndirect" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, indirect Members are included. By default they are not included. An example of an indirect member is a Qtree in a Volume which is a direct member of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each member which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeSpaceInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the space Status is computed for all Members, the space Status and detailed space conditions of every data set member is returned if the space Status of the member is "warning" or "Error". Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MemberId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Id, in the DFM database, of a specific member of the Dataset. If specified, details of only this object will be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MemberNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id in the DFM database, of a specific member of the Dataset. If specified, details of only this object will be returned. If both MemberId and MemberNameOrId is specified, then MemberId will take precedence over MemberNameOrId.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StoragesetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>List only the Members in this storage set. If none is specified, then list Members in all storagesets mapped To this Dataset's nodes. If both DpNodeName and StoragesetNameOrId are specified, then the Value of DpNodeName is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SuppressStatusRefresh" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, do not refresh the member Status. If false or omitted, the Status of all Members will be refreshed before being returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records that have been saved for future retieval with DatasetMemberListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DatasetMemberListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberUndedupeStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start undeduplication Operation on specified Volume member of the given Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Identifier of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="UndedupeMemberRequestInfo" type="na:UndedupeMemberRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details on member To be undeduplicated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMemberUndedupeStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Id of the job that handles the undeduplication Operation. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMissingMemberListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of missing Dataset Members.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetMissingMemberListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMissingMemberListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetMissingMemberListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next Records in the iteration started by DatasetMemberListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DatasetMemberListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMissingMemberListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="MissingMembers" type="na:ArrayOfMissingMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of the missing Members of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMissingMemberListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Members of the Dataset that have gone missing. The way the server determines if an object was not intentionally removed From the Dataset is: &lt;ol&gt; &lt;li&gt;The object is still a Dataset member. &lt;li&gt;The object's objDeleted flag is set. &lt;/ol&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset whose Members will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetMissingMemberListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records that have been saved for future retieval with DatasetMemberListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DatasetMemberListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify Attributes for a Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplicationInfo" type="na:ApplicationInfo">
                            <xsd:annotation>
                                <xsd:documentation>This input is used only if IsApplicationData is true. It contains information about the application which manages this Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CheckProtectionPolicyOnCommit" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>In the default case for a protection Policy change, we immediately check the Dataset's membership configuration. However, in the case where we are changing the Policy and the storage set assignments in the same edit session, the caller can set this flag To true To Request that the server postpone the check of the protection Policy configuration and root node membership until the call To edit-commit. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetContact" type="na:EmailAddressList">
                            <xsd:annotation>
                                <xsd:documentation>Contact for the Dataset, such as the owner's e-mail Address.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the Dataset, up To 255 character long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetMetadata" type="na:ArrayOfDfmMetadataField">
                            <xsd:annotation>
                                <xsd:documentation>Opaque metadata for Dataset. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the Dataset. It cannot be all numeric. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetOwner" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the owner of the Dataset, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsApplicationData" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the Dataset is an application Dataset managed by an external application. Conversion of a non-application Dataset To an application Dataset is not allowed. The default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To ignore this Dataset for purposes of data protection. Data sets with this attribute set To true are not returned when the client requests Datasets which are not ignored. This attribute has no other significance To the system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpSuspended" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Flag indicating whether or not the Dataset should be protected. This also indicates whether conformance checking of the Dataset is To be done or not. Default is False. &lt;P&gt; Should IsDpSuspended go From TRUE To FALSE the edit session AssumeConfirmation default setting will be be set To FALSE for this Dataset. (See &lt;b&gt;DatasetEditCommit&lt;/b&gt; for details) &lt;P&gt; Deprecated field. Retained for backward compatibility. This field is deprecated in favour of IsSuspended, which suspends the Dataset for all automated actions (data protection and conformance check of the Dataset).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSuspended" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To suspend this Dataset for all automated actions (data protection and conformance check of the Dataset). Default is False. If present, this field takes precedence over IsDpSuspended. &lt;P&gt; Should IsSuspended go From TRUE To FALSE the edit session AssumeConfirmation default setting will be be set To FALSE for this Dataset. (See &lt;b&gt;DatasetEditCommit&lt;/b&gt; for details)</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProtectionPolicyId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the protection Policy To associate with this Dataset. This legacy parameter is only used if ProtectionPolicyNameOrId is not supplied. The dataprotection License is required for this input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProtectionPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the protection Policy To associate with this Dataset. This input is preferred over ProtectionPolicyId and if supplied then do not supply ProtectionPolicyId because ProtectionPolicyId will be ignored. The dataprotection License is required for this input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RequiresNonDisruptiveRestore" type="na:RequiresNonDisruptiveRestore">
                            <xsd:annotation>
                                <xsd:documentation>Specifies whether the Dataset requires a non-disruptive restore of LUNs so that the Host need not get detached From the LUN. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeQtreeNamePrefix" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Prefix for Volume and Qtree names, up To 60 character long. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetModifyNode">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify Attributes of a single storage set that is part of a Dataset. The storage set is specified implicitly by the Name of the data protection Policy node that maps To it. You may change the storage set's Resource pool and Timezone using this call, but not its Name or Description.&lt;P&gt; Within the same edit session in which you call &lt;b&gt;DatasetModifyNode&lt;/b&gt;, you may also add or remove Members or dynamic references, or change the Dataset's Name, Description, &lt;b&gt;IsDpIgnored&lt;/b&gt;, &lt;b&gt;IsDpSuspended&lt;/b&gt;, or &lt;b&gt;IsSuspended&lt;/b&gt;. You may not change the data set's Policy or storage sets within the same edit session. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was foundthat has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To modify the storage set. &lt;LI&gt; EOBJECTAMBIGUOUS - The Name given for the storage set or Resource pool matches multiple storage sets or Resource pools. &lt;LI&gt; EOBJECTNOTFOUND - No storage set or Resource pool was found that has the given Name or identifier. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; ESTORAGESETNOTINDATASET - The specified storage set is not a part of the Dataset being edited. &lt;LI&gt; EDPPOLICYNODENOTFOUND - No DP Policy node was found that has the given Name. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EINVALIDTIMEZONE - The given Timezone Name is not valid. &lt;LI&gt; EDSCONFLICTALREADYINDATASET - Object, its ancestor or descendent is already in Dataset. &lt;LI&gt; EDSCONFLICTSRCDESTINSAMEAGGR - Source data and destination data are in the same Aggregate. &lt;LI&gt; EDSCONFLICTALREADYINRESPOOL - Object, its ancestor or descendent is already in Resource pool. &lt;LI&gt; EDSCONFLICTCANTMIRROROSSV - OSSV is not allowed in mirror Source node. &lt;LI&gt; EDSCONFLICTCANTSNAPSHOTOSSV - Cannot apply Snapshot schedule To OSSV. &lt;LI&gt; EDSCONFLICTINCOMPATIBLEPOLICY - Policy is not compatible with application Dataset. &lt;LI&gt; EDSCONFLICTOSSVNOTALLOWED - OSSV is not allowed in the Dataset. &lt;LI&gt; EDSCONFLICTNOSMLICENSE - There is no SnapMirror License installed. &lt;LI&gt; EDSCONFLICTNOSMSVLICENSE - There is no SnapMirror or SnapVault License installed. Need To have at least one of them installed. &lt;LI&gt; EDSCONFLICTROOTNODE - Operation cannot be performed on root node of Dataset. &lt;LI&gt; EDSCONFLICTNOTROOTNODE - Operation cannot be performed on non-root node of Dataset. &lt;LI&gt; EDSCONFLICTNOTLEAFNODE - Operation cannot be performed on non-leaf node of Dataset. &lt;LI&gt; EDSCONFLICTINVALIDVFILER - Dataset node has Members that do not belong To the vFiler being attached. &lt;LI&gt;EDSCONFLICTDEDUPLICATION - A deduplication schedule enabled provisioning Policy cannot be associated with SnapVault destinations. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DatasetAccessDetails" type="na:DatasetAccessDetails">
                            <xsd:annotation>
                                <xsd:documentation>Data access details for a Dataset that needs To be configured and provisioned in a way that it is capable of transparent migration. This enables all the storage in the primary node of the Dataset To be migrated To a different physical Resource without having To reconfigure the clients accessing this storage. This input is valid only when: - There are no Members in the Dataset. - There is no vFiler Unit attached To the Dataset. - The node being edited is the primary node of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetExportInfo" type="na:DatasetExportInfo">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the NAS or SAN export settings for Members provisioned in this node of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the node in the data protection Policy that maps To the storage set. &lt;b&gt;DpNodeName&lt;/b&gt; must Match exactly the Name of one of the nodes in the data protection Policy that is currently assigned To the data set.&lt;P&gt; If &lt;b&gt;DpNodeName&lt;/b&gt; is not specified, then the storage set associated with the root node is modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset that was obtained by an earlier call To &lt;b&gt;DatasetEditBegin&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OnlineMigration" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates, that this Dataset is capable of non-disruptive migration. This field is valid only when either DatasetAccessDetails or VfilerId is not empty. By default the migration will be assumed To be disruptive. Default: false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of the provisioning Policy To be attached To the node. The implications of this are: &lt;ul&gt; &lt;li&gt; Members of the storage set associated with node are checked for conformance with the provisioning Policy. &lt;li&gt; Any new Members provisioned into the storage set will be based on this provisioning Policy. &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RelinquishVfiler" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, relinquish the vFiler Unit associated with the Dataset. This will Destroy the vFiler Unit, move all the storage owned by the vFiler Unit To the hosting storage system and re-export the Dataset over the storage system. This Option can be specified only when: &lt;ul&gt; &lt;li&gt; The vFiler Unit associated with the root node of the Dataset has been created for transparent migration by Provisioning Manager. In this case IsVfilerCreatedForMigration will be true in DatasetInfo returned by DatasetListInfoIterStart APIs. &lt;li&gt;All storage of the vFiler Unit belongs To the primary node of the Dataset, except for the root storage. &lt;/ul&gt; Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourcepoolNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of a Resource pool To assign To the storage set. If other Resource pool(s) are already assigned To the storage set, then this one will replace it. This will delete all the attached Resource pools and add the new one. If the input Value is the empty string "", then no Resource pool will be assigned To the storage set i.e. all the attached Resource pools will be removed. If this parameter is not supplied, then the storage set's Resource pool assignment will not be changed. &lt;P&gt; This is a legacy parameter. DatasetAddResourcepool and DatasetRemoveResourcepool are preferred APIs for adding and removing Resource pools to/from Dataset nodes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimezoneName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Timezone To assign To the storage set. The Value must be either a &lt;b&gt;TimezoneName&lt;/b&gt; returned by &lt;b&gt;TimezoneListInfoIterNext&lt;/b&gt;, or the empty string "". If the Value is "", no Timezone is assigned To the storage set. Storage sets with no Timezone assignment use the Timezone of the Resource pool assigned To them, or the system default if no Timezone is assigned To the Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VfilerNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of the vFiler Unit To be attached To the node. If there are any Members currently in the node, they should belong To this vFiler Unit. Any new member provisioned for this node, will be exported over this vFiler Unit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetModifyNodeResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetProvisionMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Provision a new member into the effective primary node of a Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the Dataset root node. The effective primary node of a disaster recovery Dataset in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;Error conditions: &lt;ul&gt; &lt;LI&gt; EINVALIDINPUT - If the inputs specified are not valid. &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To provision a member. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EDATASETNOTINSTABLEDRSTATE - The Dataset is not in a stable disaster recovery state. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset that was obtained by an earlier call To &lt;b&gt;DatasetEditBegin&lt;/b&gt;. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProvisionMemberRequestInfo" type="na:ProvisionMemberRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information of the provisioning Request.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetProvisionMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetRemoveMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove member From a Dataset. Only Members explicitly added To the Dataset (direct Members) can be removed. &lt;P&gt; If "Destroy" is true, even indirect Members can be destroyed on the storage system and removed From the Dataset. &lt;P&gt; If "Destroy" is true, then it is applicable only on Members of the effective primary node of the Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the Dataset root node. The effective primary node of a disaster recovery Dataset in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;The Destroy Operation happens in the background. &lt;P&gt;A provisioning job Id is returned in DatasetEditCommit api that represents the job which will resize the member as specified. The Status of the job can be checked using DpJobListIterStart ZAPIs with the given JobId.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetMemberParameters" type="na:ArrayOfDatasetMemberParameter">
                            <xsd:annotation>
                                <xsd:documentation>List of Members To remove From the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Destroy" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Specifies whether the member should be destroyed on the Filer. If not specified or false, the member will not be destroyed on the Filer. "Destroy" flag can be true, only when the Members given in input are of Type Volume, Qtree or Lun. Also, when "Destroy" is true, the Volume, Qtree or Lun given can be indirect Members of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetRemoveMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetRemoveMemberByDynamicReference">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove dynamic references From a Dataset. Only dynamic_references explicitly added To the Dataset can be removed.&lt;P&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetDynamicReferenceParameters" type="na:ArrayOfDatasetDynamicReferenceParameter">
                            <xsd:annotation>
                                <xsd:documentation>List of dynamic-references To remove From the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetRemoveMemberByDynamicReferenceResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetRemoveResourcepool">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove Resource pool From a single storage set that is part of a Dataset. The storage set is specified implicitly by the Name of the Policy node that maps To it.&lt;P&gt; Within the same edit session in which you call &lt;b&gt;DatasetRemoveResourcepool&lt;/b&gt;, you may also add or remove Members or dynamic references, or change the Dataset's Name, Description, &lt;b&gt;IsDpIgnored&lt;/b&gt;, &lt;b&gt;IsDpSuspended&lt;/b&gt;, or &lt;b&gt;IsSuspended&lt;/b&gt;. You may not change the data set's protection Policy or storage sets within the same edit session. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To modify the storage set. &lt;LI&gt; EOBJECTAMBIGUOUS - The Name given for the storage set or Resource pool matches multiple storage sets or Resource pools. &lt;LI&gt; EOBJECTNOTFOUND - No storage set or Resource pool was found that has the given Name or identifier. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; ESTORAGESETNOTINDATASET - The specified storage set is not a part of the Dataset being edited. &lt;LI&gt; EDPPOLICYNODENOTFOUND - No DP Policy node was found that has the given Name. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EDSCONFLICTALREADYINDATASET - Object, its ancestor or descendent is already in Dataset. &lt;LI&gt; EDSCONFLICTSRCDESTINSAMEAGGR - Source data and destination data are in the same Aggregate. &lt;LI&gt; EDSCONFLICTALREADYINRESPOOL - Object, its ancestor or descendent is already in Resource pool. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the node in the data protection Policy that maps To the storage set. &lt;b&gt;DpNodeName&lt;/b&gt; must Match exactly the Name of one of the nodes in the data protection Policy that is currently assigned To the data set.&lt;P&gt; If &lt;b&gt;DpNodeName&lt;/b&gt; is not specified, then the storage set associated with the root node is modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset that was obtained by an earlier call To &lt;b&gt;DatasetEditBegin&lt;/b&gt;. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of a Resource pool To remove From the storage set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetRemoveResourcepoolResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetReplacePrimaryMembers">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Replace primary Members and relationships after a failover. &lt;P&gt;If a secondary Volume or Qtree is specified, it replaces the primary member for just that secondary Volume or Qtree. If neither are specified, it replaces all primary Members that need To be replaced. &lt;P&gt;If DryRun is specified, it returns the Results of the Operation that would be taken should the Operation be committed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CancelEditSessions" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, any edit operations in progress on the data set are rolled back before replacing any primary Members. If it is false and there are edit operations in progress on the Dataset, EEDITSESSIONINPROGRESS is returned and no primary Members will be replaced. By default, CancelEditSessions is false. If DryRun is true, canel-edit-sessions is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset whose primary Members need To be replaced.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return a list of actions that would be taken should the Operation be committed without actually committing them. Dry run does not affect any edit session in progress. By default, DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the secondary Volume or Qtree whose primary needs To be replaced. If ObjectNameOrId is not specified, it replaces all primary Members in the Dataset that need To be replaced.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetReplacePrimaryMembersResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ReplaceResults" type="na:ArrayOfReplaceResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of the replace Operation. Each Result describes one Action that was taken. If DryRun is true, it describes one Action that would be taken should the Operation be committed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetResizeMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Resize, change Maximum capacity and change snap reserve for a Dataset member on the effective primary node of the Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the Dataset root node. The effective primary of a disaster recovery data set in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;The resize Operation happens in the background. &lt;P&gt;A provisioning job Id is returned in DatasetEditCommit zapi that represents the job which will resize the member as specified. The Status of the job can be checked using DpJobListIterStart ZAPIs with the given JobId. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have the Capability DFM.ResourcePool.Provision on the containing Resource pool for a Volume that is being resized. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EOBJECTNOTFOUND - No Volume or Qtree member by the given Name or identifier was found. &lt;LI&gt; ENOTINDATASET - Member is not in the primary node of the specified Dataset. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified member Name could refer To two or more Objects. Try again with the object identifier or object full Name. &lt;LI&gt; EINVALIDINPUT - Both MemberId and MemberName are not specified, inputs other than NewSize are specified for a Qtree member, Size parameters are being changed for traditional Volumes. &lt;LI&gt; EEDITSESSIONNOTFOUND - If the edit session specified in input is not found &lt;LI&gt; EEDITSESSIONOBJECTALREADYLOCKED - If the object being tried To lock in this Operation is already locked by some other edit session &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - If this resize Operation is conflicting with some other edit Operation in the same edit session &lt;LI&gt; EDATASETNOTINSTABLEDRSTATE - The Dataset is not in a stable disaster recovery state. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ResizeMemberRequestInfo" type="na:ResizeMemberRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details on member To be resized.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetResizeMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetSet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Set Dataset Options.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier for the Dataset whose Options need To be set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsAllowCustomSettings" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, conformance check of some Volume Options is disabled for the Dataset. These Volume Options include, fractional-reserve, autodelete commitment and autodelete trigger Attributes only. This Option is applicable only for Datasets which have san thin provisioning Policy associated. For other Datasets the Option is ignored. default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsEnableWriteGuaranteeChecks" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, periodic write guarantee checks are enabled for the Dataset. This Option is applicable only for Datasets which have SAN thin provisioning Policy associated. Presence of lun-clones, flex-clones, SFSR operations in the Volume may Effect write guarantees in SAN thin provisioning configurations. Periodic write guarantee checks detect such Condition and generate alerts. For other Datasets the Option is ignored. default Value is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaximumLunsPerVolume" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Maximum Luns To be provisioned From a Volume in this Dataset. If the Value is empty, then the Dataset level Value of the global Option maxLUNsPerVolume is applicable for the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaximumQtreesPerVolume" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Maximum Qtrees To be provisioned From a Volume in this Dataset. If the Value is empty, then the Dataset level Value of the global Option maxQtreesPerVolume is applicable for the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetSetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetSetStorageset">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change the storage sets associated with Policy nodes. It is legal To change many storage set/node mappings in an edit session.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the data protection Policy node To associate the storage set To. If this input is not present the root node is used as the default. &lt;P&gt;If DpNodeName is the root node, &lt;ul&gt; &lt;li&gt;Dataset must have a disaster recovery capable protection Policy &lt;li&gt;Dataset must be in a "failed_over" DR state &lt;li&gt;ObjectNameOrId specified must be the storage set mapped To the DR-capable node of the old protection Policy. &lt;/ul&gt; Mapping the DR storage set To the root node of a new protection Policy will have the side Effect of changing the DR state To "ready" when the edit session is committed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock for a Dataset obtained by calling DatasetEditBegin. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the storage set To add.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetSetStoragesetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetUpdateDrStatus">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Update disaster recovery Status for a Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier for the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetUpdateDrStatusResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DatasetUpdateProtectionStatus">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Update protection Status for a Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier for the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DatasetUpdateProtectionStatusResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmAbout">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve information currently provided by the 'dfm about' command.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeDirectorySizeInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, then Size and file Count information of the DFM Directories is returned. Default Value is false i.e. only names of the DFM Directories are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmAboutResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CpuCount" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>CPU Count.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DfmDirectories" type="na:ArrayOfDirectoryInfo"/>
                        <xsd:element name="HostName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Host Name.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="InstallDir" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Installation Directory.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="InstalledPlugins" type="na:ArrayOfPlugin"/>
                        <xsd:element name="LicensedFeatures" type="na:ArrayOfFeature"/>
                        <xsd:element name="NodeLimit" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Operations Manager Node limit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OperatingSystem" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Operating system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ProtMgrNodeLimit" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Protection Manager Node limit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ProvMgrNodeLimit" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Provisioning Manager Node limit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SerialNumber" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>serial number of this product.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SystemMemory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>System memory.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SystemTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>System time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Version" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A string that adheres To the following regular expression: [1-9][0-9]+\.[1-9][0-9]+.* The first number is the DFM major Version. The second number is the DFM minor Version. DFM APIs don't change if the major.minor doesn't change. Example: 3.5.0.4726</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmGetApiStatistics">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve information about the API call frequencies on the DFM server</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ClearApiStats" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, reset all the API statistics. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmGetApiStatisticsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ApiStatistics" type="na:ArrayOfApiStat">
                            <xsd:annotation>
                                <xsd:documentation>Lists the statistics about the API call frequencies on the DFM server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmGetResourcePropertyValues">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Gets the list of Resource Properties and the Values that can be set as filters for Thresholds. The list of Resource Properties are pre-defined, but the Values are obtained From the current set of Values in the database</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ResourceProperty" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the property for which the Values are To be returned If not present, then Resource Values for all Properties are returned Maximum Length of 255 characters</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmGetResourcePropertyValuesResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ResourcePropertyValues" type="na:ArrayOfResourcePropertyValues">
                            <xsd:annotation>
                                <xsd:documentation>The Values for the Resource Properties</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmObjectRefresh">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Request monitors be scheduled To run To refresh the information of the object specified. The monitors To be scheduled To run can be specified implicitly using ChildType or explicitly by providing MonitorNames. If both ChildType and MonitorNames are specified, it will be treated as an Error.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ChildType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If specified, schedule only those monitors affecting the specified Type. Otherwise, all monitors affecting the ObjectNameOrId will be scheduled. Valid only if ObjectNameOrId points To a Storage System or a vFiler Unit. Possible Values: "Aggregate", "Volume", "Qtree" and "lun_path".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MonitorNames" type="na:ArrayOfMonitorName">
                            <xsd:annotation>
                                <xsd:documentation>Specifies one or more monitors To be scheduled To run. If this input is not provided, all monitors will be scheduled. Valid only if ObjectNameOrId points To a Host Agent, Storage System, vFiler Unit, OSSV Host or a NetCache.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name or Id of the object To be refreshed. Should be Name or Id of a Host Agent, Storage System, vFiler Unit, OSSV Host, Aggregate, Volume, Qtree, LUN or a NetCache. If ChildType is specified, this should be Name or Id of a Storage System or a vFiler Unit. If MonitorNames are specified, this should be Name or Id of a Host Agent, Storage System, vFiler Unit, OSSV Host or a NetCache.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmObjectRefreshResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmObjectsGetStatus">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get Status for DFM Objects This api always returns true. It returns the Status for all the Objects that are passed in. A ObjectNameOrId of "0" indicates the "global Group" Privelege required is read</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Objects" type="na:ArrayOfObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Objects for which Status is To be retrieved</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmObjectsGetStatusResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ObjectsStatus" type="na:ArrayOfObjStatusInfo">
                            <xsd:annotation>
                                <xsd:documentation>Status of the passed in input Objects.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmRelatedObjectsListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve information about Objects related To a DFM object. This api takes an object as input and returns the information about parent Objects of that object, Resource Groups, Datasets and Resource pools the object belongs To and Objects that belong To the specified object. Privilege required is DFM.Database.Read on the specified object. Parent output Objects are returned only if the authenticated user has DFM.Database.Read Privilege on that parent object. For e.g. Group To which an object belongs is returned only if the authenticated user has DFM.Database.Read Privilege on that Group.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeIndirect" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, Resource Groups, Datasets and Resource pools in which the input object is an indirect member will also be returned. Default Value is false, i.e only direct memberships are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list related Objects for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Host &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;li&gt; Lun &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmRelatedObjectsListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ChildCountList" type="na:ArrayOfChildCount">
                            <xsd:annotation>
                                <xsd:documentation>Count of children for the specified object. Present in the output if the object has at least one child.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ParentDatasetList" type="na:ArrayOfParentDataset">
                            <xsd:annotation>
                                <xsd:documentation>Datasets the specified object belongs To. Present in the output if the object belongs To at least one Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ParentGroupList" type="na:ArrayOfParentGroup">
                            <xsd:annotation>
                                <xsd:documentation>Resource Groups the specified object belongs To. Present in the output if the object belongs To at least one Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ParentObjectList" type="na:ArrayOfParentObject">
                            <xsd:annotation>
                                <xsd:documentation>Parents of the specified object. Present in the output if there is at least one parent object.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ParentResourcepoolList" type="na:ArrayOfParentResourcepool">
                            <xsd:annotation>
                                <xsd:documentation>Resource Pools the specified object belongs To. Present in the output if the object belongs To at least one Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleContentGet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the content of a given schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleContentGetResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleContentInfo" type="na:ScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new schedule with the given Name. The schedule Type may be daily, weekly, or monthly.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleContentInfo" type="na:ScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>A unique ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDailyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a single schedule within a daily schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyContent" type="na:WrapperOfDailyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the daily schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDailyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the daily item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDailyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a single schedule within a daily schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the daily item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDailyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleDailyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a single schedule within a daily schedule. Sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyContent" type="na:WrapperOfDailyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the daily schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDailyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleDependency">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Return a list of other DP policies, report schedule and schedules using the specified schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDependencyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleAssignees" type="na:ArrayOfScheduleAssignee">
                            <xsd:annotation>
                                <xsd:documentation>List of other DP policies, report schedules and schedules using the specified schedule. The list returned will depend on the schedule category. For schedule catedory 'dfm_schedule' only report schedules and the DFM schedules using this schedule will be returned. For schedule category 'dp_schedule' only DP policies and the DP schedules using this schedule will be returned. The list excludes DP policies, report schedules or schedules that the caller has no permissions To read.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleInUse" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>For schedule category 'dfm_schedule' this is true if its used by report schedules or DFM schedules. For schedule category 'dp_schedule' this is true if its used by DP policies or DP schedules.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a schedule with the given Name or ID. A schedule that is used by another schedule(s) may not be deleted and an Error will be returned. Sample schedules cannot be destroyed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleHourlyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create an hourly schedule within a daily schedule. An hourly schedule specifies the Frequency of schedules To be run within the start time and end time.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HourlyContent" type="na:WrapperOfHourlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the hourly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleHourlyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the hourly item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleHourlyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete an hourly schedule within a daily schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the hourly item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleHourlyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleHourlyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an hourly schedule within a daily schedule. Sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HourlyContent" type="na:WrapperOfHourlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the hourly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleHourlyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List all existing schedule IDs and types.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleList" type="na:ArrayOfScheduleIdInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of schedule IDs</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Tell the DFM station that the temporary store associated with the specified Tag is no longer necessary</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Iterate over the list of schedules stored in the temporary store. The DFM internally maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Maximum number of schedules To retrieve</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleContentList" type="na:ArrayOfScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of detailed schedule contents</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The DfmScheduleListInfoIter* set of APIs are used To retrieve a list of schedule contents</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule. If specified, only this schedule is listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of items saved for future retrieval</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a schedule's details in the database. When the zapi is called, all details within the schedule will be removed and replace by the new details specified in schedule-content. Sample schedules cannot be modified. ScheduleId and ScheduleType cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleContentInfo" type="na:ScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify a single schedule within a monthly schedule. Either DayOfMonth, or both WeekOfMonth and DayOfWeek must be specified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyContent" type="na:WrapperOfMonthlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the monthly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MonthlyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the monthly item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a single schedule within a monthly schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the monthly item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="MonthlyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a single schedule within a monthly schedule. Sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyContent" type="na:WrapperOfMonthlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the monthly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MonthlyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlySubscheduleSet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify a sub-schedule To be used by a monthly schedule. On top of the individual monthly Events, a monthly schedule may only have 1 daily subschedule OR 1 weekly schedule. If this monthly schedule already has a daily or weekly schedule, this command replaces the old one.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SubscheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule To be used by the monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlySubscheduleSetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlySubscheduleUnset">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Unset a sub-schedule used by a monthly schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleMonthlySubscheduleUnsetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleRename">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Rename a schedule. Sample schedules cannot be renamed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="NewScheduleName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A new unique Name of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleRenameResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify a single schedule within a weekly schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyContent" type="na:WrapperOfWeeklyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the weekly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a single schedule within a weekly schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a single schedule within a weekly schedule. Sample schedules canot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyContent" type="na:WrapperOfWeeklyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the weekly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklySubscheduleAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify which daily schedule will be used on a certain range of Days within a weekly schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EndDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the schedule. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StartDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the schedule. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklySubscheduleAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly use item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklySubscheduleDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify which daily schedule To be deleted within a weekly schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly use item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklySubscheduleDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklySubscheduleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify which daily schedule will be used on a certain range of Days within a weekly schedule. Permenent of sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EndDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the schedule. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly use item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StartDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the schedule. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmScheduleWeeklySubscheduleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DfmServerListDiagnosticInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve server diagnostic information</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmServerListDiagnosticInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DiagInfo" type="na:ArrayOfDfmDiagCounterGroup">
                            <xsd:annotation>
                                <xsd:documentation>Diagnostic information collected From the dfm server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmUserPrivGet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve current user's global Privilege. This api is no longer the preferred way To getting user privileges. Use RbacAccessCheck.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DfmUserPrivGetResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Privilege" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>User's Privilege(s), comma separated if there are multiple. Possible privileges are: FULL, DELETE, WRITE, READ, BACKUP, RESTORE, SAN, SRM, MIRROR.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DiskListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The DiskListInfoIter* set of APIs are used To retrieve the list of Disks. DiskListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the DiskListInfoIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DiskListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DiskListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check DiskListInfoIterStart. The DiskListInfoIterNext API is used To iterate over the Members of the Disks stored in the temporary store created by the DiskListInfoIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DiskListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by DiskListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DiskListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Disks" type="na:ArrayOfDiskInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Disks.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DiskListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The DiskListInfoIter* set of APIs are used To retrieve the list of Disks in DFM. DiskListInfoIterStart returns the disk belonging To Objects specified. It loads the list of Disks into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Disks in the temporary store. If DiskListInfoIterStart is invoked twice, then two distinct temporary stores are created.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Disks for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Host &lt;li&gt; Aggregate &lt;/ul&gt; Disks are not Objects in DFM. So, a single disk cannot be listed. If ObjectNameOrId is specified, all Disks that belong To the object specified will be listed. If no ObjectNameOrId is provided, all Disks will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DiskListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DiskListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DiskListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupContentListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list file contents of a backup.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpBackupContentListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupContentListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpBackupContentListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpBackupContentListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpBackupContentListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupContentListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="BackupContents" type="na:ArrayOfDpBackupContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of files and Directories in backup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupContentListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list contents of a backup. Files and Directories directly under specified Path are listed. In order To list all files recursively, multiple invocations of this API are necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Id of backup Instance whose file contents are To be listed. Use DpBackupListIterStart To retrieve valid backup ids. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the Snapshot copy on the primary where the data originated. This field is ignored if the RootObjectNameOrId is omitted. It is also ignored, if PrimarySnapshotUniqueId is specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data originated. Currently, this is the Snapshot copy's creation time. This field is ignored if the RootObjectNameOrId is omitted.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RootObjectNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a Dataset member that is at the root of the file tree. This may be Qtree, ossv Directory or Volume that is the Source of the physical data protection relationship. Indirect Members may also be specified. If the sub Path input is given, then this input is required. If specified, backup contents of this object are listed. Otherwise, backup contents directly under the Dataset are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SubPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Local subpath within the Dataset with regard To RootObjectNameOrId. If specified, backup contents directly under this sub Path are listed. Otherwise, backup contents directly under the specified root-object are listed. Ignored if RootObjectNameOrId input is not present If the RootObjectNameOrId is a Volume,Qtree or ossv unix Directory then this SubPath is a unix-like Path, ex: 'dir1/dir2/'. If the RootObjectNameOrId is ossv windows Directory then this SubPath is a windows Path, ex : 'dir1\\dir2\\'. Maximum Length of SubPath is 32767 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SuppressChildCount" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This flag is set To FALSE by default. When TRUE, the child Count for a file will not be calculated and a zero will be returned in its place in the file_info structer.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupContentListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpBackupContentListIterNext. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpBackupContentListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupGetLocation">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Given a BackupId or the BackupVersion and a list of member-ids or member-names, returns the Snapshot Name, Volume that it exists on as well as the secondary Qtree associated with the member Id. If more than one Snapshots Match the BackupId or BackupVersion, only one, the first item in the resulting list, is returned. Multiple matches occur when the same backup Version exists on multiple nodes. In case of mutiple matches which Snapshot gets picked is unspecified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the backup Instance. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp of the backup Version.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the Dataset To which this backup Version belongs To. This parameter is ignored in case of BackupId parameter in the input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Paths" type="na:ArrayOfDpBackupPathInfo">
                            <xsd:annotation>
                                <xsd:documentation>Path information about backup</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupGetLocationResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="BackupLocations" type="na:ArrayOfBackupLocationInfo">
                            <xsd:annotation>
                                <xsd:documentation>Location information for the backup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list Backups.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpBackupListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpBackupListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpBackupListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpBackupListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Backups" type="na:ArrayOfDpBackupInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Backups.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Backups of a Dataset or a Path within Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Id of backup Instance whose information is To be listed. If this parameter is specified BackupVersion, VolumeId, SnapshotUniqueId, RootObjectNameOrId and SubPath parameters are ignored. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when the backup was taken. Backups of the Dataset that were taken at this time is listed. If this parameter is specified, VolumeId, SnapshotUniqueId, RootObjectNameOrId and SubPath are ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of Dataset. Backups for this Dataset are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each member which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeMetadata" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, returns metadata for the backup. If false, metadata, which can be large in Size, is not returned. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RootObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a Dataset member that is at the root of the file tree. This may be Qtree, ossv Directory or Volume that is Source of the physical data protection relationship. If sub Path input is given then this input is required. If specified, Backups containing this object are listed. Otherwise, all Backups of this Dataset are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SnapshotUniqueId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unique Id of a Snapshot. If VolumeId is present, then this input must be given. Ignored if VolumeId is not present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SubPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Local subpath within the Dataset with regard To RootObjectNameOrId. If specified, Backups containing this sub Path are listed. Ignored if RootObjectNameOrId input is not present If the RootObjectNameOrId is a Volume,Qtree or ossv unix Directory then this SubPath is a unix-like Path, ex: 'dir1/dir2/'. If the RootObjectNameOrId is ossv windows Directory then this SubPath is a windows Path, ex : 'dir1\dir2\'. Maximum Length of SubPath is 32767 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Id of Volume that is member of a Dataset node. If this input is present then SnapshotUniqueId must be present. BackupVersion containing this (VolumeId, SnapshotUniqueId) is returned. If this parameter is specified, RootObjectNameOrId, SubPath are ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpBackupListIterNext. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpBackupListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start an unscheduled backup of a Dataset. All Members of the Dataset will be backed up. A background job will be spawned To backup the Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description for the backup. Can be arbitrary string meaningful To the user. If provided, the job spawned will have this Description. The Length of this string cannot be more than 255 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupDestination" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Destination of the backup. This should be Name of one of the nodes in the data protection Policy attached To the Dataset. If Name of the primary node is specified, the management station takes local Snapshot only. Otherwise, the management station transfers the backup over intervening Policy nodes until it reaches the specified destination node. If this input is not provided, then the management station takes local Snapshots on the primary node as well as Backups on all connections in the Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Dataset To backup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RetentionType" type="na:DpBackupRetentionType">
                            <xsd:annotation>
                                <xsd:documentation>Retention Type To which the backup Version should be archived. &lt;P&gt; This input is required for non-application Datasets and for the application Datasets with IsApplicationResponsibleForPrimaryBackup set To false. &lt;P&gt; If this input is specified, the specified Retention Type will be assigned To the Backups created by the spawned job. &lt;P&gt; If this input is omitted (and it is not required), the Retention Type of the primary backup is assigned To the replicated Backups.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Id of the job that handles the unscheduled backup of the Dataset. dp-backup-progress-* apis can be used To track the progress of the backup job. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a backup Version. Backup Version is collection of Volume Snapshots and denotes a single backed up image of a Dataset. The management station keeps track of actual Volumes that hold the Dataset backup using backup versions.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description for backup Version. Can be arbitrary string meaningful To the user. If provided, the new Version will have this Description. The Length of this string cannot be more than 255 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupMetadata" type="na:ArrayOfDfmMetadata">
                            <xsd:annotation>
                                <xsd:documentation>Opaque metadata for this backup. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset for the backup Version.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsAddingMembers" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this input is true, Protection Manager expects more Members To be added To the VersionMembers element of this backup. The job that is transferring this backup, periodically checks To see if the new Members have been added and starts transferring them. The transfer job does not exit until this input is set To false by calling DpBackupVersionModify API (or until the Timeout occurs). &lt;P&gt; If this input is false, the job exits after transferring any Members that it could find in this backup. Any new Members that got added To the backup will be transferred by the next job. &lt;P&gt; This input can be used when creating a local backup potentially takes a very long time and you want the Protection Manager To start the transfers without waiting for the local backup To complete. &lt;P&gt; The default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsComplete" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether or not this backup Version is a consistent backup of the Dataset. The default Value is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsForPropagation" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether or not this backup Version should be propagated according To the data protection Policy. If false, the backup Version will not be propagated To other nodes. Once a backup Version is created, this property can not be modified. Default Value is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsNative" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether or not this backup Version would have been created on the same storage set if Dataset had not failed over. &lt;P&gt; If IsNative is true, this backup Version is retained according To Retention settings on the node on which the backup Version exists. &lt;P&gt; If IsNative is false, this backup Version is retained according To Retention settings on the DR primary node. &lt;P&gt; Default Value is true. &lt;P&gt; When Dataset has failed over To the DR secondary node, local Backups are created on the DR secondary node. But these Backups are retained using Retention settings on the DR primary node. Server uses IsNative in conjunction with RetentionType To determine which Retention settings To use. &lt;P&gt; Examples: &lt;ul&gt; &lt;li&gt; If IsNative is true and RetentionType is hourly, HourlyRetentionDuration and HourlyRetentionCount on the same node, where the backup exists, are used. &lt;li&gt; If IsNative is false and RetentionType is daily, DailyRetentionCount and DailyRetentionDuration on the DR primary node are used. &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Id of the data protection job that is invoking this API. This parameter is intended for internal use only.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RetentionType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Retention Type that will be applied To the backup being created on the requested node. If it is not provided, the RetentionType for the backup being created on the requested node will be set To 'unlimited'. Possible Values: 'hourly','daily', 'weekly', 'monthly' and 'unlimited'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StoragesetId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of storage set on which this backup Version exists. If the storage set is not specified, then the default is the primary storage set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VersionMembers" type="na:ArrayOfVersionMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>Describes Snapshot Members of this backup Version. Members are not required at time of creation. If omitted, VersionMembers is set To empty.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VersionTimestamp" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp of the backup Version. This corresponds To the time at which backup for the Dataset started. This Timestamp will be used as the identifier of this backup Version and will be accepted and returned in the "BackupVersion" element of various APIs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Integer identifier of the new backup Instance. Range: [1..2^31-1] This is different From BackupVersion.</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete an existing backup Version From the database and delete the Snapshots From the storage systems for this backup Version. The backup Version must currently exist. This API does not provide transaction semantics. When API returns an Error, the backup Version may have been partially deleted. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EBACKUPDOESNOTEXIST - The backup Version was not found. &lt;LI&gt; EBACKUPBUSY - The backup Version is busy. This can happen if one of the Snapshots in the backup is needed for future transfers or if transfer From the backup is in progress. &lt;LI&gt; EINVALIDINPUT - Not enough inputs To determine Version properly. This can happen if less than three of Dataset, BackupVersion, and NodeName are used in the case where BackupId is not supplied. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested backup Version. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EOBJECTNOTFOUND - Dataset not found. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AllowDeferredDelete" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this input is true and if the backup cannot be deleted immediately, it will be marked for deletion at a later time and this API will return success. The backup will be deleted when the conditions that were preventing the backup From deletion no longer exist. For example, if the backup contains Snapshot copies needed by SnapVault or SnapMirror for future transfers, the backup will be deleted when those Snapshot copies are no longer needed. &lt;P&gt; The Backups which are marked for deletion will not be returned via any of the backup listing APIs. &lt;P&gt; If this input is false and if the backup cannot be deleted immediately, an Error will be returned. &lt;P&gt; Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the backup Instance To be deleted. Range: [1..2^31-1] This input is required unless both DatasetNameOrId and BackupVersion inputs are supplied.</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when the backup was taken. This input is required if BackupId is not present. This input should be omitted and is ignored if BackupId is present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset for the backup Version To be deleted. This input is required if BackupId is not present. This input should be omitted and is ignored if BackupId is present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DeleteMultipleBackups" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This input is ignored if BackupId input is present or if all three of the DatasetNameOrId, BackupVersion and NodeName are present since in both cases a single backup is identified for deletion. &lt;P&gt; When both BackupId and NodeName are omitted and both DatasetNameOrId and BackupVersion are supplied, multiple Backups may produce a Match. In that case, this input controls whether multiple Backups that Match the specified DatasetNameOrId and BackupVersion inputs will be deleted. &lt;P&gt; If this input is true, all the matching Backups will be deleted. The new callers of this API who omit both NodeName and BackupId inputs are expected To use this Value. &lt;P&gt; If this input is false only a single backup among several matches will be deleted. API does not specify which particular backup will be picked for deletion. This behavior exists for compatibility reasons only. New callers of this API should not specify 'false' Value for this input. &lt;P&gt; Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NodeName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of Policy node that uniquely defines the BackupId for backup Version To be deleted. This input should be omitted and is ignored if BackupId is present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpBackupVersionListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list backup versions.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpBackupVersionListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpBackupVersionListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpBackupVersionListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpBackupVersionListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="BackupVersions" type="na:ArrayOfDpBackupVersionInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of BackupVersions for a given Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list all backup versions for a given Dataset. Information returned includes the IDs of each Instance, the propagation Status for each Version, and job Id responsible for the backup. Clients should use this API if they want a list of backup versions rather than backup Instances.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when the backup was taken. Backups of the Dataset that were taken at this time are listed. If this parameter is specified, VolumeId, SnapshotUniqueId, RootObjectNameOrId and SubPath are ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of Dataset. Backups for this Dataset are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each member which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeMetadata" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, returns metadata for the backup. If false, metadata, which can be large in Size, is not returned. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RootObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a Dataset member that is at the root of the file tree. This may be a Qtree, ossv Directory or Volume that is the Source of the physical data protection relationship. If sub Path input is given then this input is required. If specified, only Backups containing this object are listed. Otherwise, all Backups of this Dataset are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SnapshotUniqueId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unique Id of a Snapshot. This is currently the Snapshot create time. If VolumeId is present, then this input must be given. Ignored if VolumeId is not present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SubPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Local subpath within the Dataset with regard To RootObjectNameOrId. If specified, Backups containing this sub Path are listed. Ignored if RootObjectNameOrId input is not present If the RootObjectNameOrId is a Volume,Qtree or ossv unix Directory then this SubPath is a unix-like Path, ex: 'dir1/dir2/'. If the RootObjectNameOrId is ossv windows Directory then this SubPath is a windows Path, ex : 'dir1\dir2\'. Maximum Length of SubPath is 32767 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Id of Volume that is a member of a Dataset node. If this input is present then SnapshotUniqueId must be present. BackupVersion containing this (VolumeId, SnapshotUniqueId) is returned. If this parameter is specified, RootObjectNameOrId, SubPath are ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpBackupVersionListIterNext. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpBackupVersionListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modifies a backup Version. Either the BackupId or some combination of the DatasetNameOrId, NodeNameOrId and BackupVersion are used To specify an individual backup Instance or a set of backup Instances which represent the same backup Version. Certain inputs, such as IsAddingMembers, DpBackupTransferInfo and VersionMembers, can only be applied To a single backup Instance. When a backup Instance is transferred From one node To another, the Attributes of the backup Instance, BackupDescription and BackupMetadata, are copied at the beginning of the transfer. Any changes To these fields made after a backup Instance has been copied will not be propagated automatically. Specify only the DatasetNameOrId and BackupVersion To update the fields of all the backup Instances with the same BackupVersion.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description for backup Version. Can be arbitrary string meaningful To the user. The Length of this string cannot be more than 255 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the backup Instance To be modified. Range: [1..2^31-1] Either the BackupId or both the DatasetNameOrId and BackupVersion must be specified.</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupMetadata" type="na:ArrayOfDfmMetadata">
                            <xsd:annotation>
                                <xsd:documentation>Opaque metadata for this backup. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when the backup was taken. Backups of same Dataset at different locations have same Version if their contents are identical. The management station keeps track of which Backups have identical contents and assigns same Version To them. Either the BackupId or both the DatasetNameOrId and BackupVersion must be specified. Ignored if BackupId is specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset for the backup Version. Either the BackupId or both the DatasetNameOrId and BackupVersion must be specified. Ignored if BackupId is specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DpBackupTransferInfo" type="na:DpBackupTransferInfo">
                            <xsd:annotation>
                                <xsd:documentation>The transfer Status of the backup To a destination node. If this input is specified, either the BackupId or all three of the DatasetNameOrId, NodeNameOrId, and BackupVersion must be specified. This input is for the internal use of the Protection Manager. Protection Manager job can modify BackupTransferStatus, BackupTransferNeeded or JobId elements of DpBackupTransferInfo.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsAddingMembers" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether more Members are being added To the VersionMembers element of this backup. &lt;P&gt; If this input is true, Protection Manager expects more Members To be added To the VersionMembers element of this backup. The job that is transferring this backup, periodically checks To see if the new Members have been added and starts transferring them. The transfer job does not exit until this input is set To false by calling DpBackupVersionModify API (or until the Timeout occurs). &lt;P&gt; If this input is false, the job exits after transferring any Members that it could find in this backup. Any new Members that got added To the backup will be transferred by the next job. &lt;P&gt; This input can be used when creating a local backup potentially takes a very long time and you want the Protection Manager To start the transfers without waiting for the local backup To complete.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsComplete" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether or not this backup Version is a consistent backup of the Dataset. If not specified, the Value of the attribute remains unchanged.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NodeNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of Policy node that uniquely defines the BackupId for backup Version To be modified. &lt;P&gt; If VersionMembers or DpBackupTransferInfo input is specified, either the BackupId or all three of the DatasetNameOrId, NodeNameOrId, and BackupVersion must be specified. &lt;P&gt; If VersionMembers and backup-transfer-info inputs are not specified, omitting NodeNameOrId and BackupId inputs is acceptable as long as both DatasetNameOrId and BackupVersion are specified. In such case, the setting change will be applied To all Backups with the specified BackupVersion. &lt;P&gt; If NodeNameOrId is 1, it is interpreted as root node. This is true even when there is no data protection Policy attachted To the Dataset. &lt;P&gt; This input should be omitted and is ignored if BackupId is present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RetentionType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Retention Type of this Version. Possible Values: 'hourly','daily', 'weekly', 'monthly' and 'unlimited'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VersionMembers" type="na:ArrayOfVersionMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>Snapshots To add To the backup. If a Snapshot is already a member of the backup, do nothing. Existing Members of the backup are unaffected. If this input is specified, either the BackupId or all three of the DatasetNameOrId, NodeNameOrId, and BackupVersion must be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpBackupVersionModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpDashboardGetDrDatasetCounts">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Return number of disaster recovery enabled Datasets in all DrState and DrStatus combinations. The number of Datasets in each distinct dr-state/dr-status combination is returned. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If present, limit counts To Datasets which are Members of this Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetDrDatasetCountsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DrStateStatusCounts" type="na:ArrayOfDrStateStatusCount">
                            <xsd:annotation>
                                <xsd:documentation>Counts of all Datasets with a distinct dr-state/dr-status combination.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetLaggedDatasets">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get a list of the most lagged Datasets. This API returns a list of some or all Datasets, sorted by Lag time. Only the Datasets Name, ID, and worst relationship Lag time are returned. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Group. Only relationships inside the specified Group will be returned. If no Value is specified, then relationships are returned regardless of Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaxDatasets">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Datasets To return. If not specified, all Datasets are returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetLaggedDatasetsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DpDatasets" type="na:ArrayOfDpDatasetLagInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Datasets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetLaggedRelationships">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get a list of the most lagged relationships. This API returns a list of some or all relationships, sorted by Lag time. Only the relationship Name, ID, and Lag time are returned. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Group. Only relationships inside the specified Group will be returned. If no Value is specified, then relationships are returned regardless of Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsExternalRelationship" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list external relationships. Otherwise, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaxRelationships">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of relationships To return. If not specified, all relationships are returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetLaggedRelationshipsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DpRelationships" type="na:ArrayOfDpRelationshipLagInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of SnapVault and SnapMirror relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetProtectedDataCounts">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>This zapi call has been deprecated in Juno (4.0) release, because the definitions for "protected" and "unprotected" Objects changed. Please use DpDashboardGetProtectedDataCounts2 instead. Get counts for certain types of Objects for displaying on the Protection Manager Dashboard. The types of Objects are: Datasets, Volumes, Qtrees, and OSSV Directories. For each object Type, the number of protected Objects, unprotected Objects, and ignored Objects is returned. And object is considered To be protected if it is a member of a Dataset, and a Dataset is considered To be protected if it has a protection Policy. Objects are unprotected if they are both not protected and not ignored. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Group. Only Objects inside the specified Group will be counted. If no Value is specified, then all Objects are counted, regardless of Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetProtectedDataCountsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="IgnoredDatasetCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored Datasets. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="IgnoredOssvDirectoryCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored OSSV Directories. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="IgnoredQtreeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored Qtrees. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="IgnoredVolumeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored Volumes. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedDatasetCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected Datasets. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedOssvDirectoryCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected OSSV Directories. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedQtreeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected Qtrees. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedVolumeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected Volumes. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedDatasetCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected Datasets. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedOssvDirectoryCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected OSSV Directories. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedQtreeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected Qtrees. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedVolumeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected Volumes. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetProtectedDataCounts2">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get counts for certain types of Objects for displaying on the Protection Manager Dashboard. The types of Objects are: Datasets, Volumes, Qtrees, and OSSV Directories. For each object Type, the number of protected, unprotected and ignored Objects are returned.&lt;BR&gt; An object is considered To be protected if it is: &lt;ul&gt; &lt;li&gt;1. A Dataset with a protection Policy assigned, and has conformed at least once. &lt;li&gt;2. Any Volume or Qtree in a Protection Manager managed relationship. &lt;li&gt;3. Any Host or Aggregate in a Dataset with protection Policy assigned. &lt;li&gt;4. Any Host in any Resource pool (does not have To be associated with any Dataset). &lt;li&gt;5. Any Aggregate that is either in any Resource pool themselves, or is a child of a Host that is a member of any Resource pool. &lt;/ul&gt; &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Group. Only Objects inside the specified Group will be counted. If no Value is specified, then all Objects are counted, regardless of Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpDashboardGetProtectedDataCounts2Result">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="IgnoredDatasetCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored Datasets. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="IgnoredOssvDirectoryCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored OSSV Directories. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="IgnoredQtreeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored Qtrees. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="IgnoredVolumeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of ignored Volumes. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedDatasetCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected Datasets. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedOssvDirectoryCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected OSSV Directories. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedQtreeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected Qtrees. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ProtectedVolumeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of protected Volumes. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedDatasetCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected Datasets. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedQtreeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected Qtrees. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="UnprotectedVolumeCount">
                            <xsd:annotation>
                                <xsd:documentation>Number of unprotected Volumes. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpGetDatasetBackupJobsData">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns a set of Jobs To be spawned To backup the Dataset. This zapi is used To obtain data that is later used To start an on-demand backup of Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupDestination" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Destination of the Dataset backup. This should be Name of one of the nodes in data protection Policy attached To the Dataset. If primary node is specified, only local Snapshot is taken. Otherwise, backup is transferred over intervening Policy nodes until it reaches the specified node. If this element is not present, then local Snapshot on the primary node as well as backup and mirror transfers on all connections of the Policy are done.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Dataset To be backed up.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RetentionType" type="na:DpBackupRetentionType">
                            <xsd:annotation>
                                <xsd:documentation>Retention Type To which the backup Version should be archived. This input may be required depending on the Type of the Dataset. See RetentionType field in DpBackupStart for more information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpGetDatasetBackupJobsDataResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DpJobsData" type="na:ArrayOfDpJobData">
                            <xsd:annotation>
                                <xsd:documentation>List of Jobs that need To be started To backup this Dataset. Each element will have all the details required for that job.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobAbort">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Abort a job. A Request is sent To abort the job. The job will go into an aborting state and will get aborted after sometime.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of job To abort. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobAbortResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpJobListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list Jobs.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpJobListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpJobListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpJobListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpJobListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Jobs" type="na:ArrayOfDpJobInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Jobs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Jobs. The Jobs that Match all the specified filters will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="JobContextObjNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the job context object. The object can be of Type Host, Aggregate or Dataset only. If specified, only those Jobs that ran in the context of the specified object is returned. If not specified, all Jobs will be listed. This field is ignored if either &lt;b&gt;ObjNameOrId&lt;/b&gt; or &lt;b&gt;JobId&lt;/b&gt; is specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of a job To list. If unspecified, all Jobs are listed. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobState" type="na:DpJobState">
                            <xsd:annotation>
                                <xsd:documentation>State of the Jobs To list. If specified, only the Jobs which are in this state are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobType" type="na:DpJobType">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only Jobs of specified Type are listed. This field is deprecated in favor of JobTypes. Only one of JobType or JobTypes can be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobTypes" type="na:ArrayOfJobType">
                            <xsd:annotation>
                                <xsd:documentation>List of job types. Only Jobs of these types are listed. Only one of JobType or JobTypes can be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaxJobs">
                            <xsd:annotation>
                                <xsd:documentation>If specified, this is the Maximum number of Jobs that the client wishes To receive at once. If set To zero, return all Jobs. The default Value of this parameter is 50,000. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the Dataset, a Resource Group or a vFiler Unit. In case of Datasets or vFiler units, Jobs carried out on them are listed. In case of Resource Groups, Jobs carried out on Datasets or vFiler units which are Members of the Resource Group are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartedTimestampFrom" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, Jobs started at or after the specified time are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartedTimestampTo" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, Jobs started at or before the specified time are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpJobListIterNext. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpJobListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobProgressEventListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list progress of job.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpJobProgressEventListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobProgressEventListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpJobProgressEventListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpJobProgressEventListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpJobProgressEventListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobProgressEventListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ProgressEvents" type="na:ArrayOfDpJobProgressEventInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of job progress Events.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobProgressEventListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list job progress Events. The event could be one of the following Type. &lt;ul&gt; &lt;li&gt; 'job-start' &lt;li&gt; 'JobProgress' &lt;li&gt; 'job-abort' &lt;li&gt; 'job-end' &lt;li&gt; 'job-retry' &lt;li&gt; 'rel-create-start' &lt;li&gt; 'rel-create-progress' &lt;li&gt; 'rel-create-end' &lt;li&gt; 'rel-destroy-start' &lt;li&gt; 'rel-destroy-progress' &lt;li&gt; 'rel-destroy-end' &lt;li&gt; 'snapshot-create' &lt;li&gt; 'snapshot-delete' &lt;li&gt; 'backup-create' &lt;li&gt; 'backup-delete' &lt;li&gt; 'snapvault-start' &lt;li&gt; 'snapvault-progress' &lt;li&gt; 'snapvault-end' &lt;li&gt; 'snapmirror-start' &lt;li&gt; 'snapmirror-progress' &lt;li&gt; 'snapmirror-end' &lt;li&gt; 'restore-start' &lt;li&gt; 'restore-progress' &lt;li&gt; 'restore-end' &lt;li&gt; 'MigrateStart' &lt;li&gt; 'migrate-progress' &lt;li&gt; 'migrate-end' &lt;li&gt; 'mirror-break-script-start' &lt;li&gt; 'mirror-break-script-end' &lt;li&gt; 'mirror-break-quiesce-start' &lt;li&gt; 'mirror-break-quiesce-end' &lt;li&gt; 'mirror-break-start' &lt;li&gt; 'mirror-break-end' &lt;li&gt; 'volume-create' &lt;li&gt; 'volume-resize' &lt;li&gt; 'volume-option-set' &lt;li&gt; 'snapshot-reserve-resize' &lt;li&gt; 'volume-autosize' &lt;li&gt; 'snapshot-autodelete' &lt;li&gt; 'lun-create' &lt;li&gt; 'lun-destroy' &lt;li&gt; 'lun-map' &lt;li&gt; 'lun-unmap' &lt;li&gt; 'igroup-create' &lt;li&gt; 'igroup-destroy' &lt;li&gt; 'igroup-add' &lt;li&gt; 'igroup-remove' &lt;li&gt; 'qtree-create' &lt;li&gt; 'quota-set' &lt;li&gt; 'nfsexport-create' &lt;li&gt; 'cifs-share-create' &lt;li&gt; 'cifs-share-modify' &lt;li&gt; 'cifs-share-delete' &lt;li&gt; 'volume-destroy' &lt;li&gt; 'qtree-destroy' &lt;li&gt; 'vfiler-storage-add' &lt;li&gt; 'script-run' &lt;li&gt; 'volume-dedupe' &lt;li&gt; 'volume-dedupe-enable' &lt;li&gt; 'volume-dedupe-schedule-set' &lt;li&gt; 'VfilerCreate' &lt;li&gt; 'VfilerSetup' &lt;li&gt; 'aggregate-space' &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ConnectionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the connection in the Policy being used by the job. If not specified, then progress Events for all Jobs are returned. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the Dataset To list progress Events for. If not specified progress Events for all Jobs are returned. Only DatasetNameOrId or JobId may be supplied, but not both. This field is deprecated in favor of ObjectNameOrId.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EndTime" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>End Timestamp. Events after this time will not be returned. If not present, all Events up To the present are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="History" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If FALSE return only the most recent progress Events for job. The most recent progress Events define the current progress of the job. For example a backup job generates a JobProgress event which says "Retrieving preferred Interfaces" and then when the Interfaces are retrieved it generates an event "Retrieved preferred Interfaces", the earlier then moves To History. The latter one becomes the current event. If TRUE all the Events are returned. Default Value is FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job To list progress Events for. Only DatasetNameOrId or JobId may be supplied, but not both. If neither is supplied, all progress Events are returned. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobType" type="na:DpJobType">
                            <xsd:annotation>
                                <xsd:documentation>Type of the job associated with the event. If not specified progress Events for all job types are returned. This field is deprecated in favor of JobTypes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobTypes" type="na:ArrayOfJobType">
                            <xsd:annotation>
                                <xsd:documentation>List of job types associated with the progress Events. Only progress Events of Jobs of these job types are listed. If not specified, progress Events for all job types are returned. Only one of JobType or JobTypes can be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the object To list progress Events for. If not specified, progress Events for all Jobs are returned. Only ObjectNameOrId or JobId may be supplied, but not both. Only one of DatasetNameOrId or ObjectNameOrId can be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Start Timestamp. Events before this time will not be returned. If not present, all Events since the earliest event are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobProgressEventListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpJobProgressEventListIterNext. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpJobProgressEventListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobPurge">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Purge all completed Jobs From the database. Purged Jobs are removed From the database, all information is lost.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CompletedTimestamp" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, all Jobs successfully completed before this time are purged. This field must be specified when JobId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of job To purge. If specifed, only this job is purged. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PurgeJobsCompletedWithError" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If specified, Jobs completed with Error are also purged. Otherwise, only successfully completed Jobs are purged.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobPurgeResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpJobScheduleGetLastChanged">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Gets time when job schedule last changed. This is used by the scheduler Service To reload list of Jobs that need To run in future. Jobs that are already running are not affected.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobScheduleGetLastChangedResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="LastChangedTimestamp" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when job schedule last changed. Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobScheduleListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list scheduled Jobs.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpJobScheduleListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobScheduleListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpJobScheduleListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpJobScheduleListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpJobScheduleListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobScheduleListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduledJobs" type="na:ArrayOfDpScheduledJob">
                            <xsd:annotation>
                                <xsd:documentation>List of Jobs that need To be started by the scheduler. This list is sorted by increasing StartTime.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobScheduleListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Jobs that need To be started by scheduler in specified time range. Scheduler Service periodically requests a list of scheduled data protection Jobs that will need To start within next few hours. Each item in this list is a Description of what needs To be done and time when it needs To be done. &lt;BR&gt; For example, a scheduled job might be: take a local Snapshot on node 1 of Dataset ds1 at 05/10/2006 9:00 AM UTC using "hourly" Retention. &lt;BR&gt; Scheduler Service is responsible for storing job into the database and starting the job at its start time.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DatasetNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, list of Jobs is filtered by this Dataset. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="FromTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Jobs To be started From this time will be listed. Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ToTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Jobs To be started until this time (inclusive) will be listed. Must be equal To or greater than FromTime. Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpJobScheduleListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpJobScheduleListIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpJobScheduleListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate an iteration started by DpOssvApplicationListInfoIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt;EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt;EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous call To DpOssvApplicationListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpOssvApplicationListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To DpOssvApplicationListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous dp-ossv-directory-application-list-info-iter-start call</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="OssvApplicationList" type="na:ArrayOfOssvApplicationInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of applications supported by OSSV Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Browse the application components supported by an OSSV Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="OssvApplicationPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Path of the application To browse. If specified it must be an the application Path returned by DpOssvApplicationListInfoIterStart. If not specified, it is same as an empty string and all the Virtual Machines reported by the OSSV Host will be returned. Length: [1..255]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OssvHostNameOrId" type="na:OssvHostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of an OSSV Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with DpOssvApplicationListInfoIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpOssvApplicationListInfoIterNext or DpOssvApplicationListInfoIterEnd</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationRestoreDestinationListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate an iteration started by DpOssvApplicationRestoreDestinationListInfoIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt;EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt;EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous call To DpOssvApplicationRestoreDestinationListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationRestoreDestinationListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpOssvApplicationRestoreDestinationListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To DpOssvApplicationRestoreDestinationListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous DpOssvApplicationRestoreDestinationListInfoIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationRestoreDestinationListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="OssvApplicationRestoreDestinationList" type="na:ArrayOfOssvApplicationRestoreDestinationInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of all the OSSV Hosts through which the application can be restored To its original location.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationRestoreDestinationListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List all the OSSV Hosts through which a restore To the original location is possible for a given application.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ApplicationNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the application.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvApplicationRestoreDestinationListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with DpOssvApplicationRestoreDestinationListInfoIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpOssvApplicationRestoreDestinationListInfoIterNext or DpOssvApplicationRestoreDestinationListInfoIterEnd</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a new OSSV Directory To the list of discovered Directories. If the Directory already exists, return its object ID. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. There can be two applications with the same Name. Try specifying the application Path. &lt;LI&gt; EOBJECTNOTFOUND - The Host Name, IP Address, or Host ID was not found. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Host(s). &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDIRDOESNOTEXIST - The specified Directory was not found. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DirectoryPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Directory Path To add. This Path must be an absolute Path on the given Host. In case of adding an application component this should be the OssvApplicationPath returned by DpOssvApplicationListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OssvHostNameOrId" type="na:OssvHostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of an OSSV Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DirectoryId">
                            <xsd:annotation>
                                <xsd:documentation>ID of the newly added Directory. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryBrowseIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate an iteration started by DpOssvDirectoryBrowseIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous call To DpOssvDirectoryBrowseIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryBrowseIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryBrowseIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To DpOssvDirectoryBrowseIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous DpOssvDirectoryBrowseIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryBrowseIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Subdirectories" type="na:ArrayOfDpOssvDirectoryName">
                            <xsd:annotation>
                                <xsd:documentation>List of Subdirectories.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryBrowseIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the list of Subdirectories beneath a given Directory on an OSSV Host. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. &lt;LI&gt; EOBJECTNOTFOUND - The Host Name, IP Address, or Host ID was not found. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Host(s). &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDIRDOESNOTEXIST - The specified Directory was not found. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DirectoryPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Directory Name To browse. Must be an absolute Path, or an empty string. If DirectoryPath is omitted, it is the same as an empty string. &lt;BR&gt; If this Value is omitted, or an empty string, then a list of all the Roots of filesystems that are suitable for backup will be returned. On some systems, special backup sources will be returned as well. These special backup sources will not have a trailing slash when returned. For example, on Windows, "SystemState" is a valid backup Source returned by this API, but it cannot be browsed by this API.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OssvHostNameOrId" type="na:OssvHostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of an OSSV Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryBrowseIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with DpOssvDirectoryBrowseIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpOssvDirectoryBrowseIterNext or DpOssvDirectoryBrowseIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryDiscoveredIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate an iteration started by DpOssvDirectoryDiscoveredIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous call To DpOssvDirectoryDiscoveredIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryDiscoveredIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryDiscoveredIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To DpOssvDirectoryDiscoveredIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous DpOssvDirectoryDiscoveredIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryDiscoveredIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Directories" type="na:ArrayOfDpOssvDirectoryInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Directories.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryDiscoveredIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List the OSSV Directories which have been discovered by the monitor. This list includes OSSV Roots, and siblings of Directories in backup relationships. The list can be filtered To exclude Directories which are marked as "ignored" and To exclude Directories which are protected. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. There can be two applications with the same Name. Try specifying the ID of the application. &lt;LI&gt; EOBJECTNOTFOUND - The lookup object was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Directory object(s). &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each Directory which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If the Value is true, only list Directories which are marked as ignored Freya/DFM for the purpose of data protection. If the Value is false, only list Directories which are not marked as ignored. If the Value is not specified, then list all Directories.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsInBackupRelationship" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this Value is true, only list Directories which are in a backup relationship. If this Value is false, only list Directories which are not in a backup relationship. If this Value is unspecified, then list all Directories.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsInDataset" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If the Value is true, only list Directories which are Members of a Dataset. If the Value is false, only list Directories which are not Members of Datasets. If the Value is not specified, list all Directories.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list OSSV Directories for. The allowed object types for this argument are: &lt;UL&gt; &lt;LI&gt; Resource Group &lt;LI&gt; Dataset &lt;LI&gt; OSSV Host &lt;LI&gt; OSSV Directory &lt;/UL&gt; If ObjectNameOrId identifies an OSSV Directory, that single OSSV Directory will be returned. If ObjectNameOrId resolves To more than one OSSV Directory, all of them will be returned. If no ObjectNameOrId is provided, all OSSV Directories will be listed. The same applies To OSSV applications as well.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryDiscoveredIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with DpOssvDirectoryDiscoveredIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpOssvDirectoryDiscoveredIterNext or DpOssvDirectoryDiscoveredIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a Directory's information. If modifying of one property fails, nothing will be changed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Directory. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EOBJECTNOTFOUND - When the DpOssvDirectoryNameOrId does not correspond To an ossv Directory. &lt;LI&gt; EDATABASEERROR - On database Error. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DpOssvDirectoryNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Directory To modify. If a Name is specified, it must be of the form "HostName:DirectoryPath".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To ignore this object for purposes of data protection.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryRootsIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate an iteration started by DpOssvDirectoryRootsIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous call To DpOssvDirectoryRootsIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryRootsIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryRootsIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To DpOssvDirectoryRootsIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in a previous DpOssvDirectoryRootsIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryRootsIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Roots" type="na:ArrayOfDpOssvDirectoryRootInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Roots.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryRootsIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the list of filesystem Roots From one or more OSSV Hosts. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. &lt;LI&gt; EOBJECTNOTFOUND - The Host Name, IP Address, or Host ID was not found. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Host(s). &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="FsInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If FsInfo is specified and true, then a list of all filesystems is returned instead of a list of root of filesystems suitable for backup. For example, CD-ROM drives and NFS mounts will be returned if FsInfo is true. Additional information will be included in the output, specifically the filesystem device, Type and state, as reported by NDMP. While this flag causes this API To return more data, the recommended way To find filesystems suitable for backup is To set this flag To false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OssvHostNameOrId" type="na:OssvHostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of an OSSV Host. If no OSSV Host is specified, Roots are returned for all OSSV Hosts.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpOssvDirectoryRootsIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with DpOssvDirectoryRootsIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpOssvDirectoryRootsIterNext or DpOssvDirectoryRootsIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyCopy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new DP Policy by copying From an existing "template" Policy. &lt;P&gt; The new Policy created using this ZAPI has the same set of nodes and connections as the template Policy, and the same property Values for each node and connection. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the template Policy From the database, or create a new Policy, or both. &lt;LI&gt; EOBJECTNOTFOUND - No template Policy was found that has the given Name or ID. &lt;LI&gt; EPOLICYEXISTS - A Policy with the given &lt;b&gt;DpPolicyName&lt;/b&gt; already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EAPIMISSINGARGUMENT - No template Policy Name or Id was supplied as an input. &lt;LI&gt; EINVALIDINPUTERROR - Policy Description string was too long. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DpPolicyDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the new Policy. It may contain From 0 To 255 characters. If the Length is greater than 255 characters, the ZAPI fails with Error code EINVALIDINPUTERROR. The default Value is the empty string "".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DpPolicyName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new Policy. It must be unique among all DP policies.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TemplateDpPolicyId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>An object ID for the template Policy that is copied To create the new Policy. Any Policy may serve as a template; there is no special Type of Policy for templates. This legacy parameter is only used if TemplateDpPolicyNameOrId is not supplied.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TemplateDpPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Identifier for the template Policy that is copied To create the new Policy. Any Policy may serve as a template; there is no special Type of Policy for templates. This input is preferred over TemplateDpPolicyId and if supplied then do not supply TemplateDpPolicyId because TemplateDpPolicyId will be ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyCopyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DpPolicyId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>An object ID for the newly created Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a DP Policy. This removes it From the database. &lt;P&gt; If the Policy has been applied To any Datasets, then the Destroy Operation fails; you must first un-map the Policy From any Datasets To which it had been applied before you may Destroy the Policy. &lt;P&gt; If this ZAPI fails for any Reason, the DP Policy edit of which it was a part is not rolled back. Instead, the edit is restored To the state it was in prior To invoking this ZAPI. &lt;P&gt; After this ZAPI successfully completes, any subsequent calls in the same edit session To &lt;b&gt;DpPolicyDestroy&lt;/b&gt; or &lt;b&gt;DpPolicyModify&lt;/b&gt; fail with Error code EOBJECTNOTFOUND. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EOBJECTNOTFOUND - The Policy was already destroyed during this edit session. &lt;LI&gt; EPOLICYNOTMODIFIABLE - The Policy is one of the samples created during installation, and therefore cannot be deleted. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by &lt;b&gt;DpPolicyEditBegin&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpPolicyEditBegin">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create an edit session and obtain an edit lock on a DP Policy To begin modifying the Policy. &lt;P&gt; An edit lock must be obtained before invoking the following APIs: &lt;UL&gt; &lt;LI&gt;&lt;b&gt;DpPolicyModify&lt;/b&gt; &lt;LI&gt;&lt;b&gt;DpPolicyDestroy&lt;/b&gt; &lt;/UL&gt; Use &lt;b&gt;DpPolicyEditCommit&lt;/b&gt; To end the edit session and commit the changes To the database. &lt;P&gt; Use &lt;b&gt;DpPolicyEditRollback&lt;/b&gt; To end the edit session and discard any changes made To the Policy. &lt;P&gt; 24 hours after an edit session on a Policy begins, any subsequent call To &lt;b&gt;DpPolicyEditBegin&lt;/b&gt; for that same Policy automatically rolls back the existing edit session and begins a new edit session, just as if the call had used the &lt;b&gt;Force&lt;/b&gt; Option. If there is no such call, the existing edit session simply continues and retains the edit lock. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITINPROGRESS - Another edit session already has an edit lock on the specified Policy. &lt;LI&gt; EOBJECTNOTFOUND - No Policy was found that has the given Name or ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DpPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a DP Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If &lt;b&gt;true&lt;/b&gt;, and an edit is already in progress on the specified Policy, then the previous edit is rolled back and a new edit is begun. If &lt;b&gt;false&lt;/b&gt;, and an edit is already in progress, then the call fails with Error code &lt;b&gt;EEDITINPROGRESS&lt;/b&gt;. Default Value is &lt;b&gt;false&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyEditBeginResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value is an unsigned 32-bit integer.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyEditCommit">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Commit changes made To a DP Policy during an edit session into the database.&lt;P&gt; If all the changes To the Policy are performed successfully, the entire edit is committed and the edit lock on the Policy is released.&lt;P&gt; If any of the changes To the Policy are not performed successfully, then the edit is rolled back (none of the changes are committed) and the edit lock on the Policy is released.&lt;P&gt; Use the &lt;b&gt;DryRun&lt;/b&gt; Option To test the commit. Using this Option, the changes To the Policy are not committed To the database. Instead, a &lt;b&gt;conformance check&lt;/b&gt; is performed To return a list of actions that the system would take if the changes were committed by calling this ZAPI without the &lt;b&gt;DryRun&lt;/b&gt; Option.&lt;P&gt; If &lt;b&gt;DryRun&lt;/b&gt; is false, and all changes are successfully committed, then before the call returns, the system begins a &lt;b&gt;conformance run&lt;/b&gt; on all Datasets To which the Policy has been applied. (See &lt;b&gt;DatasetConformBegin&lt;/b&gt; for a Description of conformance runs.) If any needed conformance actions require user confirmation, it is assumed that such confirmation &lt;b&gt;has&lt;/b&gt; been given, and the actions &lt;b&gt;are&lt;/b&gt; performed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EPOLICYEXISTS - The Policy's Name is being changed, and a Policy with the new Name already exists. &lt;LI&gt; EDPPOLICYINUSE - The Policy is being deleted, but deletion has failed because the Policy is in use by one or more Datasets. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If &lt;b&gt;true&lt;/b&gt;, return a list of the actions the system would take after committing the changes To the Policy, but without actually committing the changes. In addition, the edit lock is not released. By default, &lt;b&gt;DryRun&lt;/b&gt; is &lt;b&gt;false&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by &lt;b&gt;DpPolicyEditBegin&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyEditCommitResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Only returned if &lt;b&gt;DryRun&lt;/b&gt; is &lt;b&gt;true&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyEditRollback">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Roll back changes made To a DP Policy. The edit lock on the Policy will be released after the rollback. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by &lt;b&gt;DpPolicyEditBegin&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyEditRollbackResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpPolicyGetDefaultPropertyValues">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns default Values for node and connection Properties. These default Values are used in calls To &lt;b&gt;DpPolicyModify&lt;/b&gt;, in cases where the property is present for a node or connection, but the corresponding optional XML element does not appear in the &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt; or &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; structure. &lt;p&gt; Note that default Values may change From release To release. This ZAPI provides a convenient way To determine the default Values for the current release. &lt;HR&gt; Error conditions: None.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyGetDefaultPropertyValuesResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="BackupScheduleId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;BackupScheduleId&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="BackupScheduleName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;BackupScheduleName&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="BackupScriptPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;BackupScriptPath&lt;/b&gt;. The Length of the returned string will be From 0 To 255 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="BackupScriptRunAs" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;BackupScriptRunAs&lt;/b&gt;. The Length of the returned string will be From 0 To 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DailyRetentionCount" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;DailyRetentionCount&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DailyRetentionDuration" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;DailyRetentionDuration&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="FailoverScriptPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;FailoverScriptPath&lt;/b&gt;. The Length of the returned string will be From 0 To 255 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="FailoverScriptRunAs" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;FailoverScriptRunAs&lt;/b&gt;. The Length of the returned string will be From 0 To 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HourlyRetentionCount" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;HourlyRetentionCount&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HourlyRetentionDuration" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;HourlyRetentionDuration&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="IsLagErrorEnabled" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;IsLagErrorEnabled&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="IsLagWarningEnabled" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;IsLagWarningEnabled&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="LagErrorThreshold" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;LagErrorThreshold&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="LagWarningThreshold" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;LagWarningThreshold&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MirrorScheduleId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;MirrorScheduleId&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MirrorScheduleName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;MirrorScheduleName&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MonthlyRetentionCount" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;MonthlyRetentionCount&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MonthlyRetentionDuration" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;MonthlyRetentionDuration&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SnapshotScheduleId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;SnapshotScheduleId&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SnapshotScheduleName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;SnapshotScheduleName&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ThrottleScheduleId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;ThrottleScheduleId&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ThrottleScheduleName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;ThrottleScheduleName &lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyRetentionCount" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;WeeklyRetentionCount&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyRetentionDuration" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Default Value of &lt;b&gt;WeeklyRetentionDuration&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a list iteration that had been started by a call To &lt;b&gt;DpPolicyListIterStart&lt;/b&gt;. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To &lt;b&gt;DpPolicyListIterStart&lt;/b&gt; that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpPolicyListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve the next series of policies that are present in a list iteration created by a call To &lt;b&gt;DpPolicyListIterStart&lt;/b&gt;. The server maintains an internal cursor pointing To the last record returned. Subsequent calls To &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; return the next &lt;b&gt;Maximum&lt;/b&gt; Records after the cursor, or all the remaining Records, whichever is fewer. &lt;p&gt; If a property is &lt;b&gt;present&lt;/b&gt; for a particular node or connection (the presence or absence of each property is defined in its Description), then it always appears in the output element for that node or connection From a call To &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. For example, the output &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; element for a backup connection always contains a &lt;b&gt;BackupScheduleName&lt;/b&gt;. &lt;p&gt; If a property is &lt;b&gt;absent&lt;/b&gt; for a particular node or connection, then it never appears in the output element for that node or connection. For example, the output &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; element for a mirror connection never contains a &lt;b&gt;BackupScheduleName&lt;/b&gt;. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;LI&gt; EOBJECTNOTFOUND - A schedule or throttle referenced by the Policy could not be found. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of policies To return. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To &lt;b&gt;DpPolicyListIterStart&lt;/b&gt; that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DpPolicyInfos" type="na:ArrayOfDpPolicyInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of information about multiple DP policies.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Begin a list iteration over all content in all DP policies in the system. Optionally, you may iterate over the content of just a single Policy. &lt;p&gt; After calling &lt;b&gt;DpPolicyListIterStart&lt;/b&gt;, you continue the iteration by calling &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; zero or more times, followed by a call To &lt;b&gt;DpPolicyListIterEnd&lt;/b&gt; To terminate the iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the specified Policy. &lt;LI&gt; EOBJECTNOTFOUND - No Policy was found that has the given Name or ID. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DpPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a DP Policy. If specified, only this Policy is listed. If not specified, then by default, all policies are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDrCapable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present we filter the policies returned. If true, only list Datasets which are disaster recovery capable. If false, only list Datasets which are not disaster recovery capable.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items present in the list iteration. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used To identify the list iteration. The list content resides in a temporary store in the server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>This ZAPI modifies a DP Policy by completely replacing the Policy's old content with new content specified by input element &lt;b&gt;DpPolicyContent&lt;/b&gt;. This ZAPI can only change a Policy's Name, Description, and the Properties of its nodes and most of the Properties of it's connections. The connection property of IsDrCapable cannot be changed once a Policy is created. This ZAPI also cannot change the topology (set of nodes and connections between nodes) of a Policy; instead, the topology specified in &lt;b&gt;DpPolicyContent&lt;/b&gt; must Match the Policy's current topology. At present, there is no way To change the topology of a Policy. &lt;p&gt; If a property is &lt;b&gt;absent&lt;/b&gt; for a particular node or connection (the presence or absence of each property is defined in its Description), then it is &lt;b&gt;illegal&lt;/b&gt; for that property To appear in the input element for that node or connection in a call To &lt;b&gt;DpPolicyModify&lt;/b&gt;. For example, it is illegal To specify a &lt;b&gt;BackupScheduleName&lt;/b&gt; in a &lt;b&gt;dp-policy-connection&lt;/b&gt; element for a mirror connection. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EOBJECTNOTFOUND - The Policy was already destroyed during this edit session. &lt;LI&gt; EPOLICYNOTMODIFIABLE - The Policy is one of the samples created during installation, and therefore cannot be modified. &lt;LI&gt; EPOLICYTOPOLOGYCHANGED - The requested modification changes the topology of the Policy. &lt;LI&gt; EINVALIDPOLICYPROPERTY - The requested modification would set a node or connection property To an invalid Value. This includes the case when a property Value was specified, but the property is not present for that node or connection. &lt;LI&gt; EOSSVCANTTAKESNAPSHOTS - A Snapshot schedule is being set for the Policy's root node, but the Policy has been applied To a Dataset whose root storage set contains OSSV Directories. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DpPolicyContent" type="na:DpPolicyContent">
                            <xsd:annotation>
                                <xsd:documentation>New content for the Policy. &lt;p&gt; The topology (set of nodes and connections between nodes) specified by this parameter must be the same as the current topology of the Policy; otherwise, it is an Error. In particular, you may not change the &lt;b&gt;Id&lt;/b&gt; of any connection or node. In addition, you may not change the &lt;b&gt;FromNodeId&lt;/b&gt; or &lt;b&gt;ToNodeId&lt;/b&gt; of any connection. &lt;p&gt; &lt;b&gt;All&lt;/b&gt; Properties of the nodes and connections are set precisely as specified by the &lt;b&gt;DpPolicyConnections&lt;/b&gt; and &lt;b&gt;DpPolicyNodes&lt;/b&gt; elements of &lt;b&gt;DpPolicyContent&lt;/b&gt;. To leave the Value of a property unchanged, its old Value &lt;b&gt;must&lt;/b&gt; be specified explicity. The only exception is that if the element that specifies the property's Value is optional, and the old Value of the property happens To be the same as the default Value, then you may omit the specification of the old Value To keep the old Value.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by &lt;b&gt;DpPolicyEditBegin&lt;/b&gt;.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpPolicyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpRelationshipListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list data protection relationships.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpRelationshipListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRelationshipListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpRelationshipListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by DpRelationshipListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous DpRelationshipListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRelationshipListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DpRelationships" type="na:ArrayOfDpRelationshipInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of SnapVault and SnapMirror relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRelationshipListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list data protection relationships. These are SnapVault or SnapMirror relationships formed in order To implement data protection Policy for a Dataset. You can list relationships for a single Policy connection or for a particular Source or destination storage server.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ConnectionId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of Policy connection. If present, only list relationships protecting this connection of the data protection Policy. If specified, DatasetNameOrId must also be specified. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of Dataset. Relationships protecting any connection of this Dataset are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DestinationId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the destination Qtree, Volume, Aggregate or Storage System. If not present, relationships To all destinations are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DestinationType" type="na:RelationshipEndpointType">
                            <xsd:annotation>
                                <xsd:documentation>If present, list only relationships where the destination is of the specified Type. If not present, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDeleted" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, relationships which are marked as deleted in the database are also returned. Otherwise, deleted relationships are not returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list relationships for which the Source object has been marked as ignored for data protection. If present and false, only list relationships for which the Source object has not been marked as ignored. If not present, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpManaged" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list relationships which are To be managed by Protection Manager. If present and false, only list relationships which are not To be managed by Protection Manager. If not present, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsInDataset" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list relationships which are in a Dataset. If present and false, only list relationships for which are not in a Dataset. If not present, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsMigrationRelationship" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only relationships created for migration are returned. If DatasetNameOrId is specified with this flag, the migration relationships for the Members of that Dataset will be returned along with the relationship of the root volume/qtree of the vFiler Unit associated with the root node of the Dataset. It is invalid To specify IsInDataset or ConnectionId fields when is-migraton-relationship is true. If false or not present all relationships will be returned. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OperationalStatuses" type="na:ArrayOfOperationalStatus">
                            <xsd:annotation>
                                <xsd:documentation>If specified, the relationships in any of these statuses are only returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RelationshipId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of relationship To list. If unspecified, all relationships are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RelationshipStates" type="na:ArrayOfRelationshipState">
                            <xsd:annotation>
                                <xsd:documentation>If specified, the relationships in any of these states are only returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RelationshipType" type="na:RelationshipType">
                            <xsd:annotation>
                                <xsd:documentation>If present, list only relationships of specified Type. If not present, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SourceId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the Source Qtree, OSSV Directory, Volume, Aggregate, Storage System, or OSSV Host. If not present, relationships From all sources are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SourceOrDestinationId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of either a Source or a destination object. If empty, all relationships are listed. The Source or destination object must be either a Host, Aggregate, Volume, Qtree, OSSV Directory or DFM Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SourceType" type="na:RelationshipEndpointType">
                            <xsd:annotation>
                                <xsd:documentation>If present, list only relationships where the Source is of the specified Type. If not present, list all relationships.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRelationshipListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with DpRelationshipListInfoIterNext. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To DpRelationshipListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRelationshipModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify settings of a SnapVault, Qtree SnapMirror or Volume SnapMirror relationship.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsDpImported" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true this relationship will be marked as imported but only if IsDpManaged is also present and true. It is an Error for IsDpImported To be true when IsDpManaged is not present or present and false. If IsDpImported is present and false, clear the IsDpImported flag reguardless of the IsDpManaged being present. If a relationship has the IsDpImported flag set then the relationship will not be cleaned up after a containing Dataset has been deleted unless the fully automatic cleanup mode is active.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpManaged" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, set the IsDpManaged flag for this relationship. If present and false, clear the IsDpManaged flag for this relationship. If not present, IsDpManaged flag is not changed. &lt;P&gt; If a relationship has the IsDpManaged flag set, then Protection Manager is allowed To modify the relationship as necessary To make the relationship conform To a data protection Policy. This includes modifying any settings or schedules of the relationship, or deleting the relationship if no longer needed. Protection Manager also has the responsibility of updating the relationship as necessary, either using its own schedules or setting an ONTAP schedule for this relationship. &lt;P&gt; If the IsDpManaged flag is clear, Protection Manager will not modify, update, or delete this relationship.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RelationshipId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the relationships To be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRelationshipModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpRestoreToNewPath">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start a restore Operation on part of a Dataset. This Operation copies whole Members or its sub-paths of the Dataset From a specific backup Version To a new location. The Operation is performed in the background by a job. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTNOTFOUND - The Dataset Name or ID or one of the member Name or ID was not found. &lt;LI&gt; EACCESSDENIED - The Dataset exists, but the user invoking the API has no DFM.BackupManager.Restore Permission on the Dataset. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDINPUT - The number of Paths To restore was either 0 or more than 1000 or neither BackupId nor BackupVersion was specified. &lt;LI&gt; EINVALIDHOST - One of the specified destination Hosts was not a valid restore destination. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the backup Instance To restore From. If this parameter is specified, then BackupVersion is ignored. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp of the backup which should be restored From. If the BackupId is not specified, this parameter is required. A backup location that matches this Version will be picked To do the restore From.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CheckOverwrite" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, checks if the member To be restored overwrites existing data on the destination. This flag cannot be used if the destination Host is an OSSV or an ESX server. If it is used, an Error is returned. It can be set To true only if the Members To be restored are files. If the restore Path has any Members other than files, an Error is returned. If false, goes ahead with the restore job without checking for overwrites at the destination. By default, it is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CheckSpaceStatus" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, checks if there is enough space on the destination To restore the member. This flag cannot be used if the destination Host is an OSSV or an ESX server. If it is used, an Error is returned. It can be set To true only if the Members To be restored are files. If the restore Path has any Members other than files, an Error is returned. If the flag is not specified or set To false, goes ahead with the restore job without checking the space Status at the destination. By default, it is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset To restore part of.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Members" type="na:ArrayOfDpRecoverMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Members and their Path To recover within the Dataset. Each member includes the new location To restore the data. The Maximum number of Members is 1000.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MigrateRelationship" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Flag indicating whether To MigrateStart the relationships. By default, the Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRestoreToNewPathResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Id of the job that handles the restore Operation. It is returned only if "CheckOverwrite" and "CheckSpaceStatus" are false. If either of them is set To true, the API only checks overwrites and/or space Status and returns. The restore Operation is not performed . &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OverwriteResults" type="na:ArrayOfOverwriteResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a CheckOverwrite. Each Result will have information about the file that overwrites data on the destination. Returned if CheckOverwrite is true and if the file being restored might overwrite existing data. This element is not returned if there are no overwrites.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SpaceStatusResults" type="na:ArrayOfSpaceStatusResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of CheckSpaceStatus. Each Result will have information about the destination Volume. Returned if CheckSpaceStatus is true and if the destination Volume does not have enough space for enough space for the restore. Returned if CheckSpaceStatus is true and if the destination Volume does not have enough space for the restore. If the destination Volume has enough space, this element is not returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRestoreToPrimary">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start a restore Operation on part of a Dataset. This Operation copies files and/or Directories From a specific backup Version back To the primary location. The Operation is performed in the background by a job. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTNOTFOUND - The Dataset Name or ID or one of the member Name or ID was not found. &lt;LI&gt; EACCESSDENIED - The Dataset exists, but the user invoking the API has no DFM.BackupManager.Restore Permission on the Dataset or on any of the Members. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDINPUT - The number of Paths To restore was either 0 or more than 1000 or neither BackupId nor BackupVersion was specified. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;LI&gt; ENDRESTORENOTPOSSIBLE - A partial Qtree restore is requested for a Dataset which requires a non disruptive restore. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BackupId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the backup Instance To restore From. If this parameter is specified, then BackupVersion is ignored. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BackupVersion" type="na:DpTimestamp">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp of the backup which should be restored From. If the BackupId is not specified, this parameter is required. A backup location that matches this Version will be picked To do the restore From.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CheckOverwrite" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, checks if the member To be restored overwrites existing data on the destination. This flag cannot be used if the destination Host is an OSSV or an ESX server. If it is used, an Error is returned. It can be set To true only if the Members To be restored are files. If the restore Path has any Members other than files, an Error is returned. If false, goes ahead with the restore job without checking for overwrites at the destination. By default, it is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CheckSpaceStatus" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, checks if there is enough space on the destination To restore the member. This flag cannot be used if the destination Host is an OSSV or an ESX server. If it is used, an Error is returned. It can be set To true only if the Members To be restored are files. If the restore Path has any Members other than files, an Error is returned. If the flag is not specified or set To false, goes ahead with the restore job without checking the space Status at the destination. By default, it is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the Dataset To restore part of.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Paths" type="na:ArrayOfDpPathInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Paths To restore within the Dataset. Each Path can be a single file or a Directory. The Maximum number of Paths is 1000.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpRestoreToPrimaryResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="JobId">
                            <xsd:annotation>
                                <xsd:documentation>Id of the job that handles the restore Operation. It is returned only if "CheckOverwrite" and "CheckSpaceStatus" are false. If either of them is set To true, the API only checks overwrites and/or space Status and returns. The restore Operation is not performed . &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OverwriteResults" type="na:ArrayOfOverwriteResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a CheckOverwrite. Each Result will have information about the file that overwrites data on the destination. Returned if CheckOverwrite is true and if the file being restored might overwrite existing data. This element is not returned if there are no overwrites.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SpaceStatusResults" type="na:ArrayOfSpaceStatusResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of CheckSpaceStatus. Each Result will have information about the destination Volume. Returned if CheckSpaceStatus is true and if the destination Volume does not have enough space for enough space for the restore. Returned if CheckSpaceStatus is true and if the destination Volume does not have enough space for the restore. If the destination Volume has enough space, this element is not returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleContentGet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the content of a given schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleContentGetResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleContentInfo" type="na:ScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new schedule with the given Name. The schedule Type may be daily, weekly, or monthly.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleContentInfo" type="na:ScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>A unique ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDailyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a single Snapshot within a daily schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyContent" type="na:WrapperOfDailyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the daily schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDailyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the daily item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDailyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a single Snapshot within a daily schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the daily item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDailyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleDailyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a single Snapshot within a daily schedule. Sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyContent" type="na:WrapperOfDailyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the daily schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDailyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleDependency">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Return a list of other DP policies and DP schedules using the specified DP schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a DP schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDependencyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleAssignees" type="na:ArrayOfScheduleAssignee">
                            <xsd:annotation>
                                <xsd:documentation>List of other DP polices and DP schedules using the specified DP schedule. The list excludes DP policies or DP schedules that the caller has no permissions To read.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleInUse" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if the schedule is in use by other DP policies or DP schedules.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a schedule with the given Name or ID. A schedule that is used by another schedule(s) may not be deleted and an Error will be returned. Sample schedules cannot be destroyed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleHourlyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create an hourly schedule within a daily schedule. An hourly schedule specifies the Frequency of Snapshots To be run within the start time and end time.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HourlyContent" type="na:WrapperOfHourlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the hourly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleHourlyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the hourly item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleHourlyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete an hourly schedule within a daily schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the hourly item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleHourlyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleHourlyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an hourly schedule within a daily schedule. Sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HourlyContent" type="na:WrapperOfHourlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the hourly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleHourlyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List all existing schedule IDs and types.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ScheduleList" type="na:ArrayOfScheduleIdInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of schedule IDs</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Tell the DFM station that the temporary store associated with the specified Tag is no longer necessary</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Iterate over the list of schedules stored in the temporary store. The DFM internally maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Maximum number of schedules To retrieve</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ScheduleContentList" type="na:ArrayOfScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of detailed schedule contents</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The dp-dpschedule-list-info-iter-* set of APIs are used To retrieve a list of schedule contents</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule. If specified, only this schedule is listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of items saved for future retrieval</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a schedule's details in the database. When the zapi is called, all details within the schedule will be removed and replace by the new details specified in schedule-content. Sample schedules cannot be modified. ScheduleId and ScheduleType cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ScheduleContentInfo" type="na:ScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify a single Snapshot within a monthly schedule. Either DayOfMonth, or both WeekOfMonth and DayOfWeek must be specified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyContent" type="na:WrapperOfMonthlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the monthly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MonthlyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the monthly item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a single Snapshot within a monthly schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the monthly item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="MonthlyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a single Snapshot within a monthly schedule. Sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyContent" type="na:WrapperOfMonthlyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the monthly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MonthlyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlySubscheduleSet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify a sub-schedule To be used by a monthly schedule. On top of the individual monthly Events, a monthly schedule may only have 1 daily subschedule OR 1 weekly schedule. If this monthly schedule already has a daily or weekly schedule, this command replaces the old one.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SubscheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule To be used by the monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlySubscheduleSetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlySubscheduleUnset">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Unset a sub-schedule used by a monthly schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MonthlyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the monthly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleMonthlySubscheduleUnsetResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleRename">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Rename a schedule. Sample schedules cannot be renamed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="NewScheduleName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A new unique Name of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleRenameResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklyAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify a single Snapshot within a weekly schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyContent" type="na:WrapperOfWeeklyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the weekly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklyAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly item within the schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklyDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a single Snapshot within a weekly schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklyDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a single Snapshot within a weekly schedule. Sample schedules canot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyContent" type="na:WrapperOfWeeklyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of the weekly schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklySubscheduleAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify which daily schedule will be used on a certain range of Days within a weekly schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a daily schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EndDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the Snapshot. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StartDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the Snapshot. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklySubscheduleAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly use item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklySubscheduleDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify which daily schedule To be deleted within a weekly schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly use item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklySubscheduleDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklySubscheduleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Specify which daily schedule will be used on a certain range of Days within a weekly schedule. Permenent of sample schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DailyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EndDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the Snapshot. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ItemId">
                            <xsd:annotation>
                                <xsd:documentation>An ID of the weekly use item within the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. Default Value is 'dp_schedule'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StartDayOfWeek">
                            <xsd:annotation>
                                <xsd:documentation>Day of week for the Snapshot. Range: [0..6] (0 = "Sun")</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="6"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="WeeklyScheduleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a weekly schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpScheduleWeeklySubscheduleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpThrottleCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a throttle schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThrottleContent" type="na:ThrottleContent">
                            <xsd:annotation>
                                <xsd:documentation>Full content of a throttle schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ThrottleId">
                            <xsd:annotation>
                                <xsd:documentation>identifier of the throttle schedule Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleDependency">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Return a list of DP policies using the specified DP throttle.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThrottleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a DP throttle.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleDependencyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ThrottleAssignees" type="na:ArrayOfThrottleAssignee">
                            <xsd:annotation>
                                <xsd:documentation>List of other DP polices using the specified DP throttle. The list excludes DP policies that the caller has no permissions To read.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ThrottleInUse" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if the throttle is in use by any DP policies.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a throttle item. Sample throttle schedules cannot be destroyed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThrottleId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the throttle item. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpThrottleItemAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a new throttle item To the throttle schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThrottleItemContent" type="na:WrapperOfThrottleItemInfo">
                            <xsd:annotation>
                                <xsd:documentation>Content of a throttle item</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ThrottleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the throttle schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleItemAddResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpThrottleItemDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete a throttle item From a throttle schedule</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThrottleItemId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the throttle item. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ThrottleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the throttle schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleItemDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpThrottleListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Tell the DFM station that the temporary store associated with the specified Tag is no longer necessary</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpThrottleListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Iterate over the list of throttle items stored in the temporary store. The DFM internally maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Maximum number of schedules To retrieve</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ThrottleList" type="na:ArrayOfThrottleContent">
                            <xsd:annotation>
                                <xsd:documentation>List of detailed throttle items</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The DpThrottleListInfoIter* set of APIs are used To retrieve a list of throttle items</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ThrottleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the throttle schedule. If specified, only this throttle schedule is listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of items saved for future retrieval</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Update a throttle item. When the zapi is called, all details within the throttle schedule will be removed and replace by the new details specified in ThrottleContent. Sample throttle schedules cannot be modified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThrottleContent" type="na:ThrottleContent">
                            <xsd:annotation>
                                <xsd:documentation>Content of the throttle schedule To be modified</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="DpThrottleRename">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Rename a throttle schedule. Sample throttle schedules cannot be renamed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="NewThrottleName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A new unique Name of the throttle schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ThrottleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the throttle schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="DpThrottleRenameResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="EventAcknowledge">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Acknowledge Events. This terminates repeated notifications due To that event.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventId">
                            <xsd:annotation>
                                <xsd:documentation>The identifier of the event that has To be acknowledged. Must specify either EventId or EventIdList not both. Range: [1..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventIdList" type="na:ArrayOfEventIdType">
                            <xsd:annotation>
                                <xsd:documentation>The event identifiers To be acknowledged. Must specify either EventId or EventIdList not both. Returns EINVALIDINPUT if neither or both arguments are included.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventAcknowledgeResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventAcknowledged" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when the event is acknowledged. This element is returned only in Response To an EventId input. Range: [0..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EventsAcknowledgedList" type="na:ArrayOfEventActionInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of timestamps for acknowledged Events along with any Errors. This array is returned only in Response To an EventIdList input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete Events. Terminates repeated notifications due To the event.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventId">
                            <xsd:annotation>
                                <xsd:documentation>The identifier of the event that has To be deleted. Must specify either EventId or EventIdList not both. Range: [1..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventIdList" type="na:ArrayOfEventIdType">
                            <xsd:annotation>
                                <xsd:documentation>The event identifiers To be deleted. Must specify either EventId or EventIdList, not both.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventDeleteResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventDeleted" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Timestamp when the event is deleted. This element is only returned in Response To an EventId input. Range: [0..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventsDeletedList" type="na:ArrayOfEventActionInfo">
                            <xsd:annotation>
                                <xsd:documentation>Lists of timestamps for deleted ids along with any Error returns. This array is returned only in Response To an EventIdList input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventGenerate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The EventGenerate API helps clients To generate Events in the DFM system</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventMessage" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A message specific To this event. This message will be displayed in the Event Details page. If not specified, nothing will be shown in the Condition field of Event Details page.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EventName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The event Name that is being generated. Currently this can be only the event names corresponding To user-defined event added To DFM.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Source" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The id/name of the Source object of the event. This is the object id/short name/long Name DFM generates for an object. Suppose, for a Host, a Host id/name can be found by using the CLI "dfm Host list".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timestamp" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The date-time when the event is generated This is the number of seconds elapsed since midnight on January 1, 1970.(UTC) If not specified or invalid Timestamp specified , the time on the DFM server when the api is invoked is used.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventGenerateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="EventListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>EventListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the EventListIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="EventListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The EventListIterNext API is used To iterate over the list of Events stored in the temporary store created by the EventListIterStart API. The DFM station, internally, maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Events To return.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify the temporary store created by EventListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Events" type="na:ArrayOfEventInfo">
                            <xsd:annotation>
                                <xsd:documentation>Array of Events managed by DFM.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List Events. The EventListIter* set of APIs are used To retrieve the list of Events. &lt;P&gt; The EventListIterStart API is used To load the list of Events into a temporary store. The API returns a Tag To temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. &lt;P&gt; Note that, depending on the input parameters, this API may take up To "Timeout" seconds To return. Subsequent calls To EventListIterNext() will return immediately.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventApplicationList" type="na:ArrayOfEventApplicationType">
                            <xsd:annotation>
                                <xsd:documentation>If given, specifies a list of event-applications which is used as a filter for Events that are To be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The 64-bit identifier of the event that has To be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventSeverities" type="na:ArrayOfObjStatus">
                            <xsd:annotation>
                                <xsd:documentation>Lists Events of the specified severities.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventSourceId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Lists Events generated by the specified Source. The EventSourceId is a Name or object identifier returned by other APIs. For example, the EventSourceId could refer To a storage system (From GroupMemberListIterStart) or Dataset (From dataset-list-iter-start). If the EventSourceId identifies a Group, lists Events for all sources in that Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EventTypeFilterList" type="na:ArrayOfEventTypeFilter">
                            <xsd:annotation>
                                <xsd:documentation>If specified, the list of event types (interpreted as prefixes) will filter which Events are returned. Events not matching will not be returned. Default is empty, meaning that all event types Match.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GreaterThanId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>If specified, the API will only return Events whose identifier (unsigned 64-bit Values) is greater than this Value. Default is 0.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDatasetResourceStatusEvents" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This input is considered only if EventSourceId refers To a Dataset. By default this is false. When this element is true, all Events of Dataset Members, where the member can be through direct or indirect membership are returned. This helps in listing the set of Events that constitutes the Resource Status of the Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDeletedObjects" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>if TRUE, also lists Events on Objects which have been marked "deleted" in DFM's database. If FALSE, only list Events generated on Objects that have not been "deleted" From DFM's database. This field is ignored if EventSourceId is set. Default is TRUE</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeEventArguments" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, include the EventArguments output element for each listed event. If not present, do not include EventArguments.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeRelated" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>if TRUE, include Events of related Objects that resolve From EventSourceId. Would be ignored if EventSourceId is not specified in the input. For e.g: if EventSourceId is Aggregate, all the Events of the Aggregate and its related Storage System, Volumes, Qtrees, Disks and Luns shall be included.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsAcknowledged" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, lists all acknowledged Events. If FALSE, list all unacknowledged Events. If this parameter is not specified, lists all Events irrespective of their Status. Default is empty.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDeleted" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>if TRUE, lists all Events which have been marked "deleted" in DFM's database. Such Events are not normally shown in event Views. If FALSE, list all un-deleted Events. If this parameter is not specified, lists all Events irrespective of their deletion Status. Default is empty.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsHistory" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, lists all Events generated in DFM after it has been installed; otherwise, show only "current" Events. Default is FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsMostSevereFirst" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, specifies that Events should be returned in descending order of Severity, then by Timestamp. The default is FALSE, meaning that Events are returned in order of Timestamp only.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsOldestFirst" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, specifies that Events should be returned in ascending order of Timestamp (that is, oldest Events first). The default is FALSE, meaning that Events are returned in descending order of Timestamp (that is, newest Events first).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaxEvents">
                            <xsd:annotation>
                                <xsd:documentation>If specified, this is the Maximum number of Events that the client wishes To receive at once. If set To zero, return all Events. The default Value of this parameter is 50,000. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the Events based on the mode of event's Source object. filter "cluster" indicates c-mode Objects and "node" indicates 7-mode Objects. If no filter is supplied, all Events will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimeRange" type="na:WrapperOfEventTimestampRange">
                            <xsd:annotation>
                                <xsd:documentation>Lists all Events which were generated in the range specified. Default is all Events. time-out will be ignored if TimeRange is set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timeout" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of seconds after which the API should terminate, if no Events are received matching the input criteria. If the Value is 0, or not specified, the API will terminate immediately (acting as an instantaneous poll for Events). &lt;P&gt; If the Timeout expires with no matching Events, the API returns successfully with an empty list of Events. &lt;P&gt; If IsHistory or IsDeleted is set To TRUE, or if a specific EventId is specified, or if EventSourceId is specified To be 0, then the Timeout Value is ignored. &lt;P&gt; If TimeRange is set, Timeout is also ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Events matching the specified input criteria. This is the number of Records that will be returned by subsequent calls To EventListIterNext().</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle you must pass To EventListIterNext() and EventListIterEnd() To refer To this list of Events.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventStatusChangeListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>EventStatusChangeListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the EventStatusChangeListIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventStatusChangeListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="EventStatusChangeListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The EventStatusChangeListIterNext API is used To iterate over the list of Events stored in the temporary store created by the EventStatusChangeListIterStart API. The DFM station, internally, maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Events To return.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify the temporary store created by EventStatusChangeListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventStatusChangeListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Events" type="na:ArrayOfEventInfo">
                            <xsd:annotation>
                                <xsd:documentation>Array of Events managed by DFM.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventStatusChangeListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List Events that had Status changes (acknowledged or deleted) within the specified time range. &lt;P&gt; The EventStatusChangeListIter* set of APIs are used To retrieve the list of Events that had Status changes. &lt;P&gt; The EventStatusChangeListIterStart API is used To load the list of Events into a temporary store. The API returns a Tag To temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. &lt;P&gt; The returned list of Events will be sorted according To when they had their Status changed (either eventAcked Timestamp or eventDeleted Timestamp). An event that's both acked and deleted within the requested timeframe would appear twice in the returned list of Events, because those would Count as 2 Status changes, and appear in the returned list based on acked Timestamp and deleted Timestamp respectively. &lt;P&gt; Note that, depending on the input parameters, this API may take up To "Timeout" seconds To return. Subsequent calls To EventStatusChangeListIterNext() will return immediately.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="MaxEvents">
                            <xsd:annotation>
                                <xsd:documentation>If specified, this is the Maximum number of Events that the client wishes To receive at once. If set To zero, return all Events. The default Value of this parameter is 50,000. Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="TimeRange" type="na:WrapperOfEventTimestampRange">
                            <xsd:annotation>
                                <xsd:documentation>Lists all Events which were generated in the range specified. &lt;P&gt; If the EndTime of the TimeRange is sometime in the future, time-out will be ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timeout" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of seconds after which the API should terminate, if no Events are received matching the input criteria. If the Value is 0, or not specified, the API will terminate immediately (acting as an instantaneous poll for Events). &lt;P&gt; If the Timeout expires with no matching Events, the API returns successfully with an empty list of Events.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventStatusChangeListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Events matching the specified input criteria. This is the number of Records that will be returned by subsequent calls To EventStatusChangeListIterNext().</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle you must pass To EventStatusChangeListIterNext() and EventStatusChangeListIterEnd() To refer To this list of Events.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassAddCustom">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Supports adding custom event classes.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AboutMessage" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Custom event class Description.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EventClassName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Custom event class Name.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EventNames" type="na:ArrayOfEventNameInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of event names for this event class.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EventNamespaceName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Namespace in which the event types are defined</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsAllowDuplicates" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Event Service will not drop duplicate Events of this event class if IsAllowDuplicates is true. Event is duplicate if it has same EventName as previous event with same EventClass and the same event-source. It is false by default. If an invalid Value is provided, it will be considered as true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsMultiCurrent" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Event Service should keep multiple current Events of this event class for each event-source. Valid only with IsAllowDuplicates. It is false by default. If an invalid Value is provided, it will be considered as true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassAddCustomResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="EventClassId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Unique Id for the custom event class.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassDeleteCustom">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Supports deletion of custom event classes.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EventClassName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Custom event class Name or its database identifier.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassDeleteCustomResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="EventclassList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Lists all or a sub-set of the custom event classes.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EventClassObjects" type="na:ArrayOfEventClassObject">
                            <xsd:annotation>
                                <xsd:documentation>List of custom event classes To be listed. If nothing is specified, all custom event classes are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="EventClasses" type="na:ArrayOfEventClassInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of custom event classes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The EventclassListIter* set of APIs are used To retrieve the list of event classes. EventclassListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the EventclassListIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="EventclassListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check EventclassListIterStart. The EventclassListIterNext API is used To iterate over the Members of the event classes stored in the temporary store created by the EventclassListIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous EventclassListIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by EventclassListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="EventClasses" type="na:ArrayOfEventClassInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of event classes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned as a Result of invoking this API.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The EventclassListIter* set of APIs are used To retrieve the list of event classes in DFM. The EventclassListIterStart API is used To load the list of event classes into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the event classes in the temporary store. If EventclassListIterStart is invoked twice, then two distinct temporary stores are created.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="EventclassListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with EventclassListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To EventclassListIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="FcpTargetListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of Targets.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous FcpTargetListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="FcpTargetListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="FcpTargetListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next set of Records in the iteration started by call To FcpTargetListInfoIterStart. This zapi will fetch the fcp Target info Records. The input param 'Maximum' specifies the number of Records it will show at a time.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>Maximum Records To retrieve. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous FcpTargetListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="FcpTargetListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Value of 0 Records indicates that end of Records. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Targets" type="na:ArrayOfTargetInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Targets.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="FcpTargetListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start iteration of Targets.Depending on the input it will return a Tag and the number of Records To be retrieved.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the following Objects. &lt;UL&gt; &lt;LI&gt; FCPTarget &lt;LI&gt; Storage System &lt;UL&gt; If Storage System Name or Id is specified only the FCP Targets discovered on the Storage System are returned. &lt;BR&gt; The Name of the FCP Target should be specified in &lt;Storage System&gt;:&lt;Target Name&gt; format. Ex: storage01:0c_2 If no ObjectNameOrId is present in the input all the fcp Targets will be fetched.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="FcpTargetListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records fetched and stored for retrieval using FcpTargetListInfoIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used for subsequent calls.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphDataListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve data of all the graph Lines of a graph.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EndDate" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of seconds in the future that the graph should end. The graph Values From the current time till the EndDate will be extrapolated and used for trending. Use a negative Value if the graph should stop in the past.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="GraphName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the graph. Maximum Length: 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GraphPeriod" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Period for which graph data has To be returned. This returns consolidated graph data depending on the graph Period. Possible Values: &lt;ul&gt; &lt;li&gt; '1d' - graph data for 1 Day. &lt;li&gt; '1w' - graph data for 1 week. &lt;li&gt; '1m' - graph data for 1 Month. &lt;li&gt; '3m' - graph data for 3 Months. &lt;li&gt; '1y' - graph data for 1 year. &lt;/ul&gt; Default Value is '1d'. The default Value of StartDate will be the same as the graph Period specified. The default Values of EndDate will be as follows: &lt;ul&gt; &lt;li&gt; 3 hours for graph Period '1d'. &lt;li&gt; 1 Day for graph Period '1w'. &lt;li&gt; 4 Days for graph Period '1m'. &lt;li&gt; 7 Days for graph Period '3m'. &lt;li&gt; 31 Days for graph Period '1y'. &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PrimaryObject" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The primary object for which the graph data is returned. If not specified then global Group is considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SecondaryObject" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>This object is valid only if the primary object is a quota user and should be a Volume or a Qtree.The primary and secondary object together represent a single quota object. If not specified, - its ignored only if the primary object is not a quota user. - if the primary object is a quota user then the ZAPI will fail with Errors. Used in Graphs like user-disk-space-used-vs-total, user-disk-space-used-percent.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartDate" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of seconds in the past that the graph should start.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphDataListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GraphLineValues" type="na:ArrayOfGraphLineValueInfo">
                            <xsd:annotation>
                                <xsd:documentation>Data for various Lines in a graph.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphListInfoIterEnd">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GraphListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To GraphListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Graphs" type="na:ArrayOfGraphInfo">
                            <xsd:annotation>
                                <xsd:documentation>A list of Graphs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of Graphs and its metadata like graph Lines and sample information.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GraphName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the graph. If not specified then all the Graphs are returned. Maximum Length: 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GraphListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with GraphListInfoIterNext. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store. Used in subsequent calls To GraphListInfoIterNext or GraphListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupAddMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a member To a Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDMEMBER - The proposed member object is not a groupable object Type. The Error message indicates which object. &lt;LI&gt; EMEMBERALREADYINGROUP - The proposed new member is already in the Group. &lt;LI&gt; EMEMBERNAMEAMBIGUOUS - The proposed member Name could refer To 2 or more Objects. &lt;LI&gt; EOBJECTNOTFOUND - The proposed member Name or ID was not found. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To add Members To the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MemberNameOrId" type="na:ObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a member To add To the Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupAddMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupCopy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Copy the Group and all of its subgroups under a new parent Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI EGROUPCOPYERROR - An attempt was made To copy a Group under itself, or under one of its sub-group or some other configuration Error occured. &lt;LI&gt; EPARENTGROUPDOESNOTEXIST - The parent Group Name or ID was not found. &lt;LI&gt; EPARENTGROUPNAMEAMBIGUOUS - The specified parent Group Name could refer To 2 or more Groups. Try again with a parent Group ID or a fully qualified parent Group Name. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To copy the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NewGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Group will be copied under the new parent Group with this Name. Groups may contain any printable ASCII character except slash characters. The Maximum Name Length is 64 characters. Group Name cannot be "global" or "all" or fully numeric.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ParentGroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the new parent Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupCopyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GroupId">
                            <xsd:annotation>
                                <xsd:documentation>ID of the newly created copy. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EPARENTGROUPDOESNOTEXIST - The parent Group Name or ID was not found. &lt;LI&gt; EPARENTGROUPNAMEAMBIGUOUS - The specified parent Group Name could refer To 2 or more Groups. Try again with a parent Group ID or a fully qualified parent Group Name. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To create the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new Group. Groups may contain any printable ASCII character except slash characters. The Maximum Name Length is 64 characters. Group Name cannot be "all" or "global" or fully numeric.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ParentGroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the parent Group. If this Value is not specified, a new top-level Group is created. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GroupId">
                            <xsd:annotation>
                                <xsd:documentation>ID of the newly created Group. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupDeleteMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove one member From a Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EMEMBERNOTINGROUP - The object specified is not a member in the Group. &lt;LI&gt; EOBJECTNOTFOUND - The object specified was not found. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To delete Members From the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MemberNameOrId" type="na:ObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a member To remove From the Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupDeleteMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy an existing Group. Child Groups are destroyed recursively. If there is any Error, then no Groups are destroyed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To Destroy the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group To be destroyed. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupGetOptions">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the Options for a Group. Option Values that are not present indicate that the Option is using the global default. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To read Options of the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupGetOptionsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GroupOptionInfo" type="na:GroupOptionInfo"/>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupGetStatus">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the Status of the Group &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To get the Status of the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupGetStatusResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GroupStatus" type="na:ObjStatus">
                            <xsd:annotation>
                                <xsd:documentation>Current Status of the Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupIsMemberOf">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Checks if the object associated with the ObjectId input is a member of the Group. This includes both direct and indirect membership. If a Group Id of 0 is passed, this will always return true as long as the object is a valid object. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EMEMBERNAMEAMBIGUOUS - The proposed member Name could refer To 2 or more Objects. &lt;LI&gt; EOBJECTNOTFOUND - The object specified was not found. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To read From the database. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the object we want To determine if it is a member of the Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupIsMemberOfResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="IsMember" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Returns true if the object associated with the ObjectId is a direct or indirect member of the Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The GroupListIter* set of APIs are used To retrieve the Members of the DFM global Group. GroupListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the GroupListIterNext API for the particular Tag is no longer necessary. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check GroupListIterStart. The GroupListIterNext API is used To iterate over the Members of the Group stored in the temporary store created by the GroupListIterStart API. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous GroupListIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by GroupListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GroupList" type="na:ArrayOfGroupInfo">
                            <xsd:annotation>
                                <xsd:documentation>An array of GroupInfo that describes each Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned as a Result of invoking this API. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The GroupListIter* set of APIs are used To retrieve the list of DFM Groups. By default, a Group is listed if the user has DFM.Database.Read Capability on the Group or if the user has DFM.Database.Read Capability on any subgroup of the Group. &lt;BR&gt; If RbacOperation is present in the input, then a Group is listed, if the authenticated user has the requested Capability on that Group or if the user has the required Capability on any of its sub-groups. In that case, HasPrivilege output will be false for the parent Group and true for the sub-group. &lt;BR&gt; The GroupListIterStart API is used To load the list of Groups into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Groups in the temporary store. &lt;BR&gt; If GroupListIterStart is invoked twice, then two distinct temporary stores are created. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - Specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have DFM.Database.Read or if RbacOperation is specified, the user does nat have the requested Capability on the specified Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;LI&gt; ENOTFOUNDOPERATION - If the input element RbacOperation is not a valid RBAC Operation Name. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only the specified Group and its immediate children are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ListSubgroups" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, lists all the subgroups recursively. If GroupNameOrId is specified, then all its subgroups are listed recursively. If FALSE, only top level Groups are listed. If GroupNameOrId is specified, then the immediate children Groups of the Group are listed. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RbacOperation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of an RBAC Operation. If specified, only return Resource Groups for which the authenticated administrator has the required Capability and DFM.Database.Read. Default Value is DFM.Database.Read. This can be up To 255 characters long. &lt;p&gt; The parameter is of the form: Application.Category.TypeOfAccess. For example: "DFM.Database.Read" or "DFM.Database.Write".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with GroupListIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To GroupListIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMemberListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>See GroupMemberListIterStart for more information. Frees up the resources used by previous call To GroupMemberListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag returned by the call To GroupMemberListIterStart</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMemberListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupMemberListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>See GroupMemberListIterStart for more information. The GroupListIterNext API is used To iterate over the Members of the Group stored in the temporary store created by the GroupListIterStart API. The DFM station, internally, maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To be returned From the temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous GroupMemberListIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by GroupMemberListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMemberListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GroupMemberList" type="na:ArrayOfGroupMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>A record in the temporary store describing a Group member. A Group member is a DFM object</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of entries actually returned as a Result of invoking this API.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMemberListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>DFM has an object that is known as the "Group" that contains other DFM Objects. Group may also have subgroups. The group-member-list-* APIs are used To retrieve the Members of particular Groups. These APIs can be used To retrieve either all Members or particular Type of Members of Groups. These APIs don't return the subgroups. Use GroupListIterStart To get a list of subgroups. The GroupMemberListIterStart API is used To load the Group Members into a temporary store. Subsequent GroupMemberListIterNext invocations iterate over the Records in the temporary store. The GroupMemberListIterEnd API is used To release the temporary store. If GroupMemberListIterStart is invoked twice, then the DFM station will create two different temporary stores that can be accessed using the different tags. When this API is invoked without specifying any Groups, Type parameter must be specified. In that case, API lists all the Objects of specified Type that are known To DFM. Those Objects may or may not be Members of any Group. If you specify Groups when invoking this API, Type parameter is optional. API lists all the Objects (optionally, of the specified Type) that have been directly added To the specified Groups.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Groups" type="na:ArrayOfGroup">
                            <xsd:annotation>
                                <xsd:documentation>A list of Group names. If no Groups are specified, all the DFM Objects of the specified Type are listed. You must specify either Groups or Type or both.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HideSubgroupMembers" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, omits Members of the subgroups. Otherwise, Members of subgroups are also listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Type" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Type of the Members To be listed. Possible Values include Cluster, Filer, Agent, Cache, OSSV Host, vFiler, vserver, Volume, Qtree, Configuration, Initiator Group, Lun Path, FCP Target, FCP Initiator, SRM Path, Aggregate, Resource Pool, Dataset. If not specified, all the Group Members are listed. You must specify either Groups or Type or both.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMemberListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with GroupMemberListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To GroupMemberListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMove">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Move the Group under a new parent Group. The Id of the Group does not change after the move. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI EGROUPMOVEERROR - An attempt was made To copy a Group under itself, or under one of its sub-group or some other configuration Error occured. &lt;LI&gt; EPARENTGROUPDOESNOTEXIST - The parent Group Name or ID was not found. &lt;LI&gt; EPARENTGROUPNAMEAMBIGUOUS - The specified parent Group Name could refer To 2 or more Groups. Try again with a parent Group ID or a fully qualified parent Group Name. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To move the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NewGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Group will be moved under the new parent Group with this Name. Groups may contain any printable ASCII character except slash characters. The Maximum Name Length is 64 characters. Group Name cannot be "global" or "all" or fully numeric.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ParentGroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the new parent Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupMoveResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupRename">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change the Name of a Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To rename the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="NewGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>New Name of the Group. Groups may contain any printable ASCII character except slash characters. The Maximum Name Length is 64 characters. Group Name cannot be "all" or "global" or fully numeric.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupRenameResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="GroupSetOptions">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change one or more Options for a Group. Only Options that are specified will be updated. The remaining Options will retain their current Values. If there is any Error, then no Options are changed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDINPUT - Invalid Value for one of the Options was specified. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To set Options for the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="GroupNameOrId" type="na:GroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="GroupOptionInfo" type="na:GroupOptionInfo">
                            <xsd:annotation>
                                <xsd:documentation>New Option Values for this Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="GroupSetOptionsResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add new managed Host To the DataFabric Manager. The Host being added must be a storage system or an Host agent. DFM figures out what Type of Host we're adding. If it's a storage system or NetCache or FC Switch, we add it To the database and set the ApplianceId. If it's a Host agent, we add the agent To the database and set the AgentId. On return, only one of the ApplianceId or AgentId will be set.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AddNetwork" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates if DFM should start monitoring the network in which new Host resides. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="AdminPort">
                            <xsd:annotation>
                                <xsd:documentation>The port To use To try To access a Host agent. Range: [1..65535]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="65535"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="BlockCmode" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates if DFM should block adding c-mode Hosts. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name, dfm Id, or IP Address of the Host To be added. Value can be a DFM * object Name (Maximum 255 characters), a fully qualified domain Name (FQDN)(Maximum 255 characters), or the ip Address. If the Value is a DFM object Name for a Host object with a deletion flag, the deletion flag is removed. &amp;lt;P&amp;gt; Length: [0..255]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AgentId" type="na:HostId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly added Host agent.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ApplianceId" type="na:HostId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly added storage system or NetCache or FC Switch.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostAddress" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>IP Address for the Host. Length: [0..39]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAddLicense">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a License To a Host. Host must be a storage system. Host must already be present in DFM's database and root login and Password for the Host must be set in DFM. The DFM will check the list of Licenses on the Host and update the database when the following types of Licenses are changed: &lt;ul&gt; &lt;li&gt; Snapvault primary (sv_ontap_pri) &lt;li&gt; Snapvault secondary (sv_ontap_sec) &lt;li&gt; Unix primary (sv_unix_pri) &lt;li&gt; Linux primary (sv_linux_pri) &lt;li&gt; Windows primary (sv_windows_pri) &lt;li&gt; Snapmirror (snapmirror) &lt;li&gt; Synchronous snapmirror (snapmirror_sync) &lt;li&gt; Windows OFM primary (sv_windows_ofm_pri) &lt;li&gt; Nearstore (nearstore_option) &lt;li&gt; NFS (nfs) &lt;li&gt; CIFS (cifs) &lt;li&gt; iSCSI (iscsi) &lt;li&gt; MultiStore (Vfiler) &lt;li&gt; FCP (fcp) &lt;li&gt; ASIS (a_sis) &lt;/ul&gt; If the License is already in use by another Host and is not a site License, then the ZAPI will apply the License To the Host, and then return with Error code ELICENSEINUSE. The ELICENSEINUSE Error will not be returned if the optional parameter SuppressInuseError is true. The ELICENSEINUSE Error will not prevent the License From being applied To the Host, since it is not the role of the DFM To prevent the user From installing duplicate Licenses. The storage system must be running a minimum ONTAP Version of 6.5.6.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostLicense" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>License To be installed on storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Host To receive the License.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SuppressInuseError" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, suppresses the ELICENSEINUSE Error. Defaults To false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAddLicenseResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostAddOssv">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add new managed ossv Host To the DataFabric Manager. If there is an ossv agent running on the Host, we add the ossv agent To the database as a snapvault primary and set the OssvId.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or IP Address of the Host To be added or the DFM object Id of a previously deleted OSSV agent. When adding a new OSSV agent, the Value can be a valid DFM object Name (Maximum 255 characters), a fully qualified domain Name (FQDN)(Maximum 255 characters), or the IPv4 Address. When adding a previously deleted OSSV agent, the Id must be the ID of the deleted OSSV agent, not the Id of Host agent on the same client system Length: [0..255]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NdmpCredentials" type="na:WrapperOfFullNdmpCredentials">
                            <xsd:annotation>
                                <xsd:documentation>The ndmp credentials we should try To use To connect To the ossv Host we're trying To add.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAddOssvResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="HostAddress" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>IP Address for the Host. Length: [0..39]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OssvId" type="na:HostId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly added ossv agent.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAgentOssvServiceStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start the OSSV Service on the Host agent using the ossv ZAPI. DFM must have valid credentials for the Host Agent. The Host Agent and OSSV Agent must be installed on the Host. Valid only for Host Agents. DFM will wait up To the time allowed in the Timeout argument To make sure the requested Service state was reached. If the Timeout is exceeded, we return ESERVICESTATEUNKNOWN.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AgentNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name or Id of the agent Host To start/stop the ossv Service on.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timeout">
                            <xsd:annotation>
                                <xsd:documentation>Number of seconds To wait for ossv Service To start/stop. Range: [1..100]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="100"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAgentOssvServiceStartResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostAgentOssvServiceStop">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Stop the OSSV Service on the Host agent using the ossv ZAPI. DFM must have valid credentials for the Host Agent. The Host Agent and OSSV Agent must be installed on the Host. Valid only for Host Agents. DFM will wait up To the time allowed in the Timeout argument To make sure the requested Service state was reached. If the Timeout is exceeded, we return ESERVICESTATEUNKNOWN.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AgentNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name or Id of the agent Host To start/stop the ossv Service on.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timeout">
                            <xsd:annotation>
                                <xsd:documentation>Number of seconds To wait for ossv Service To start/stop. Range: [1..100]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="100"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostAgentOssvServiceStopResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostCapabilityListIterEnd">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostCapabilityListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostCapabilityListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostCapabilityListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To HostCapabilityListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous host-capability-list-iter-start-call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostCapabilityListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Capabilities" type="na:ArrayOfCapability">
                            <xsd:annotation>
                                <xsd:documentation>List of Capabilities on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostCapabilityListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of allowed Capabilities on Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Host To list the Capabilities for. Only storage systems and vFiler units are allowed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostCapabilityListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with HostCapabilityListIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To HostCapabilityListIterNext or HostCapabilityListIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostCreateNdmpuser">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create an NDMP user on the Host, creating the user account if necessary and storing the host-encrypted Password on dfm. If the user exists already, we generate the encrypted NDMP Password for them on the storage system and store that in the database. If it is a new user on the storage system, we will create a new unencrypted Password for the caller and use that To generate the encrypted NDMP Password which we will then store in the database. If the user is root, we will just use root's unencrypted Password as the NDMP Password since the encryption requirement does not apply To the root user. New non-root users will be added To the "Backup Administrators" Group. Valid only for storage systems.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Host To create the NDMP user on.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="NdmpUsername" type="na:NdmpUsername">
                            <xsd:annotation>
                                <xsd:documentation>NDMP user Name.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostCreateNdmpuserResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostDomainuserAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Adds a domain user on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostDomainuserNameOrIdOrSid" type="na:DomainuserNameOrIdOrSid">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id or Sid of domain user.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Host on which the domain user is To be added. Only storage systems and vFiler units are allowed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostUsergroupNamesOrIds" type="na:ArrayOfHostUsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>List of ids or names of usergroups To which the domain user has To be added.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostDomainuserId" type="na:AccessObjectId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the domain user added To usergroup(s) on Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserListIterEnd">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostDomainuserListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostDomainuserListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To HostDomainuserListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostDomainuserListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostDomainusers" type="na:ArrayOfHostDomainuserInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of domain users on Host(s).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of domain users on Host(s). Domain users on Host(s) that matches all filters will be returned. If no input is specified, all the domain users on all monitored storage systems/vFiler units will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="HostDomainuserNameOrIdOrSid" type="na:DomainuserNameOrIdOrSid">
                            <xsd:annotation>
                                <xsd:documentation>Name or Sid or Id of the domain user on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostUsergroupNameOrId" type="na:UsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name of Id of the user Group. If specified only the users belonging To this Group will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of an object To list the domain users for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Host (only storage systems and vFiler units are allowed) &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Verbose" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Default is false. If set To true, then the usergroups, roles, and allowed Capabilities are placed into the HostDomainuserInfo element.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with HostDomainuserListIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To HostDomainuserListIterNext or HostDomainuserListIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserPush">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostDomainuserNameOrIdOrSid" type="na:DomainuserNameOrIdOrSid">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id or Sid of the domain user on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Host To push the domain user on. Only storage systems and vFiler units are allowed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserPushResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostDomainuserRemove">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Removes a domain user From a usergroup or usergroups.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostDomainuserNameOrIdOrSid" type="na:DomainuserNameOrIdOrSid">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id or Sid of domain user on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostUsergroupNamesOrIds" type="na:ArrayOfHostUsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>List of ids or names of usergroups From which the domain user has To be removed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostDomainuserRemoveResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostGetDefaults">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The DFM stores a set of global default Values for selected Attributes, which are used on all Hosts. The administrator can override the Values on a per-host basis. This api returns the default Values for some Attributes returned by HostListInfoIterNext. Default Values vary according To the Host Type.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostGetDefaultsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostDefaults" type="na:HostDefaults">
                            <xsd:annotation>
                                <xsd:documentation>The default Values of the Attributes defined by this ZAPI set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list Hosts.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous HostListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by HostListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;P&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned by a previous HostListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Hosts" type="na:ArrayOfHostInfo">
                            <xsd:annotation>
                                <xsd:documentation>Array of Hosts.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Hosts. The list of Hosts can include: &lt;ul&gt; &lt;li&gt; Storage Systems &lt;li&gt; vFiler units &lt;li&gt; vserver &lt;li&gt; Host Agents &lt;li&gt; OSSV Agents &lt;li&gt; Switches &lt;/ul&gt; Use the filtering criteria in this API To specify the list of Hosts returned by HostListInfoIterNext. If no filtering criteria is specified, all non-deleted Hosts will be returned by HostListInfoIterNext.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ExpandFilerToVfilers" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true and ObjectNameOrId is a storage system and HostTypes contains "Vfiler" then all vFiler units belonging To the storage system are returned else it is ignored. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostDpFilterInfo" type="na:HostDpFilterInfo">
                            <xsd:annotation>
                                <xsd:documentation>Data Protection specific information for this iterator.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostTypes" type="na:ArrayOfHostType">
                            <xsd:annotation>
                                <xsd:documentation>Types of Hosts To list. If the Host Type matches any of the types in this array of Host types it will be included in the list, subject To other filtering criteria. If this list contains an unknown Type the EBADHOSTTYPE Error will be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each Host which may make the call To this zapi take much longer.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeMigrationInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the migration information for the migrating vFiler units. Default false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludePerfSpaceDetails" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the details of space consumed by performance data of the Host. Default false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDirectMemberOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only return the Hosts that are direct Members of the specified Resource Group. Default Value is false. This field is meaningful only if a Resource Group Name or Id is given for the ObjectNameOrId field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="LicenseFilter" type="na:ArrayOfLicense">
                            <xsd:annotation>
                                <xsd:documentation>Filter for listing storage systems based on services licensed. Appliable when HostType is "Filer". Only those storage systems which have all the Licenses installed as specified in input are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Hosts for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Resource Pool &lt;li&gt; Dataset &lt;li&gt; Storage Set &lt;li&gt; Host &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;li&gt; OSSV Directory &lt;/ul&gt; If ObjectNameOrId identifies a Host, that single Host will be returned. If ObjectNameOrId resolves To more than one Hosts, all of them will be returned. If no ObjectNameOrId is provided, all Hosts will be listed. Host Agents and OSSV agents may use a subdomain To identify themselves, unlike other Host types. If the HostTypes element includes "agent" or "ossv" all subdomains beginning with the Host Name will be checked.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="QueryHost" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, Query the Host To update the database and refresh the Values returned in the following elements by HostListInfoIterNext: &lt;ul&gt; &lt;li&gt; HostStatus&lt;/li&gt; &lt;li&gt; IsAgentOssvEnabled&lt;/li&gt; &lt;li&gt; IsSnapvaultEnabled&lt;/li&gt; &lt;li&gt; IsNdmpEnabled&lt;/li&gt; &lt;li&gt; IsSnapmirrorEnabled&lt;/li&gt; &lt;li&gt; SnapvaultAccessSpecifier&lt;/li&gt; &lt;li&gt; NdmpAccessSpecifier&lt;/li&gt; &lt;li&gt; SnapmirrorAccessSpecifier&lt;/li&gt; &lt;li&gt; HostCommunicationStatus&lt;/li&gt; &lt;li&gt; HostCredentialsStatus&lt;/li&gt; &lt;li&gt; NdmpCommunicationStatus&lt;/li&gt; &lt;li&gt; NdmpCredentialsStatus&lt;/li&gt; &lt;li&gt; NdmpAgentStatus&lt;/li&gt; &lt;li&gt; IsSnapvaultPrimary&lt;/li&gt; &lt;li&gt; IsSnapvaultSecondary&lt;/li&gt; &lt;li&gt; IsSnapmirrorHost&lt;/li&gt; &lt;li&gt; IsUnixPrimary&lt;/li&gt; &lt;li&gt; IsLinuxPrimary&lt;/li&gt; &lt;li&gt; IsWindowsPrimary&lt;/li&gt; &lt;li&gt; IsWindowsOfmPrimary&lt;/li&gt; &lt;li&gt; IsNearstore&lt;/li&gt; &lt;/ul&gt; The HostListInfoIterNext zapi defines which elements will be updated based on whether the Host Type supports it. &lt;p&gt; Errors in communicating with or authenticating To the Host will prevent updating all the elements that are supported for that Host Type.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VfilerIpspace" type="na:VfilerIpspace">
                            <xsd:annotation>
                                <xsd:documentation>Filter for listing vFiler units, if specified, only the vFiler units that belong To the Ipspace are listed. Applicable only for HostType "Vfiler".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with host-list-iter-next. &lt;P&gt; Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To host-list-iter-next or host-list-iter-end.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify Attributes stored in the DFM database of a Host managed by the DFM.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostModifyInfo" type="na:HostModifyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Host information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Host To be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostModifyAgentCredentials">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change the Password on the Host Agent for the built in Host Agent management user "admin", using the Operating System credentials specified by OsUsername and OsPassword To authenticate the https POST Request. If the Operation succeeds, update the Host Agent Password stored in the DFM database. Valid only for Host Agents.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AgentNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Host To change the Host Agent Password on.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ManagementPassword" type="na:HostPassword">
                            <xsd:annotation>
                                <xsd:documentation>New Password for the Host Agent management API Password. If this parameter is present, it is assumed To be encrypted using two way encryption. If this parameter is not present, the DFM will generate a Password.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OsPassword" type="na:HostPassword">
                            <xsd:annotation>
                                <xsd:documentation>root or administrative Password used To authenticate https POST Password change Request. Encrypted using two way encryption.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OsUsername" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>root or administrative user Name used To authenticate https POST Password change Request.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostModifyAgentCredentialsResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostRoleCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a role on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostRole" type="na:WrapperOfHostRoleInfo">
                            <xsd:annotation>
                                <xsd:documentation>New role information. "HostRoleName" and at least one allowed Capability must be specified. Either Host Name or Id on which the role is To be created must be provided. If both Host Name and Host Id are provided, then Id takes precedence. Description is also allowed. All other fields are ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostRoleId" type="na:AccessObjectId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the new role created on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes a role on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostRoleNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the role To be deleted on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostRoleListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminates a View list iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostRoleListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostRoleListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To HostRoleListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostRoleListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostRoles" type="na:ArrayOfHostRoleInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of roles on Host(s).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of roles on Host(s). Roles on Host(s) that Match all filters will be returned. If no input is specified, all the roles on all monitored storage systems or vFiler units will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="HostRoleNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a role on the Host. If this is provided, the output contains only the information associated with this role.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of an object To list the roles for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Host (allowed Host types are storage system and vFiler units) &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Verbose" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Default is false. If set To true, then the allowed Capabilities are placed into the HostRoleInfo element.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with HostRoleListIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To HostRoleListIterNext or HostRoleListIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modifies a role on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostRole" type="na:WrapperOfHostRoleInfo">
                            <xsd:annotation>
                                <xsd:documentation>Role Name or Id must be provided. Host Name or Id is an optional parameter. If one or more Capabilities and/or Description is provided, the role is modified accordingly. If both Name and Id are provided, Id takes precedence.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRoleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostRolePush">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Host To push the role on. Only storage systems and vFiler units are allowed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostRoleNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the role To be pushed on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostRolePushResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostSetOption">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change the Option on the storage system specified by HostOptionName To the Value specified by HostOptionValue. If the Operation succeeds the following Options will be stored in the DFM database and will be returned in the specified elements the next time HostListInfoIterNext is called. &lt;table style="border-collapse: collapse;"&gt; &lt;tr style="background-color: #ddd"&gt; &lt;th style="border: solid;"&gt; HostOptionName &lt;/th&gt; &lt;th style="border: solid;"&gt; HostListInfoIterNext element &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; ndmpd.enable &lt;/td&gt; &lt;td style="border: solid;"&gt; IsNdmpEnabled &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; ndmpd.access &lt;/td&gt; &lt;td style="border: solid;"&gt; NdmpAccessSpecifier &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapvault.enable &lt;/td&gt; &lt;td style="border: solid;"&gt; IsSnapvaultEnabled &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapvault.access &lt;/td&gt; &lt;td style="border: solid;"&gt; SnapvaultAccessSpecifier &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapmirror.enable &lt;/td&gt; &lt;td style="border: solid;"&gt; IsSnapmirrorEnabled &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapmirror.access &lt;/td&gt; &lt;td style="border: solid;"&gt; SnapmirrorAccessSpecifier &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; If the Name of the Host Option ends in ".access" and the Value of the Host Option is the empty string, the Value will be changed To "none". See na_options(1) for a list of Option names and Values. See na_protocolaccess(8) for access specifier syntax and usage. Valid only for storage systems.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Host To set the Option on.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostOptionName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name of the Host Option. Length: [0..255]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostOptionValue" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Host Option will be set To this Value. Length: [0..255]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostSetOptionResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUserAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a local user on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostUser" type="na:WrapperOfHostUserInfo">
                            <xsd:annotation>
                                <xsd:documentation>New local user information. HostUserName, Password and at least one usergroup must be provided. Usergroup can be specified in terms of Name or usergroup Id. Either Host Name or Id on which the local user is To be created must be provided. Description, minimum Password age, Maximum Password age are also allowed. All other fields are ignored. If both Id and Name are specified, then Id takes precedence.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostUserId" type="na:AccessObjectId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the new user created on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes a local user on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostUserNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the local user on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUserListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminates a View list iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostUserListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUserListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To HostUserListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous host-user-list-iter- call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostUsers" type="na:ArrayOfHostUserInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of local users on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of local users on Host(s). Local users on Host(s) that matches all filters will be returned. If no input is specified, all the local users on all monitored storage systems or vFiler units will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="HostUserNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a local user.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostUsergroupNameOrId" type="na:UsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name of Id of the user Group. If specified only the users belonging To this Group will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of an object To list the local users for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Host (allowed Host types are storage system and vFiler Unit) &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Verbose" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Default is false. If set To true, then the usergroups, roles, and allowed Capabilities are placed into the HostUserInfo element.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with HostUserListIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To HostUserListIterNext or HostUserListIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modifies local user on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostUser" type="na:WrapperOfHostUserInfo">
                            <xsd:annotation>
                                <xsd:documentation>Local user Name or Id must be provided. Host Name or Id is an optional parameter. If one or more usergroups(ids or names), Description, minimum Password age, and/or Maximum Password age are provided, the local user is modified accordingly. All other fields are ignored. If both Id and Name are specified, then Id takes precedence.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUserModifyPassword">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modifies Password of a local user on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of Storage System/vFiler Unit on which the local user exists.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostUserNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the local user. For storage systems running Data ONTAP Version 7.0 or later, the user should have been discovered by DFM and thus Host user Id can be specified instead of Host user Name.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="NewPassword" type="na:HostUserPassword">
                            <xsd:annotation>
                                <xsd:documentation>New Password of the local user.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OldPassword" type="na:HostUserPassword">
                            <xsd:annotation>
                                <xsd:documentation>Old Password of the local user. If this element is provided, we run the Password command or ZAPI using the credentials provided in the ZAPI input elements.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserModifyPasswordResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUserPush">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Host To push the user on. Only storage systems and vFiler units are allowed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostUserNameOrId" type="na:AccessObjectNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the local user on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Password" type="na:HostUserPassword">
                            <xsd:annotation>
                                <xsd:documentation>Password of the new user on the Host, To which the user is pushed on. If the user already exists on the destination Host, this field is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUserPushResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUsergroupCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a usergroup on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostUsergroup" type="na:WrapperOfHostUsergroupInfo">
                            <xsd:annotation>
                                <xsd:documentation>New usergroup information. "HostUsergroupName" and at least one role must be specified. Role can be specified in terms of role Name or role Id. Either Host Name or Id on which the usergroup is To be created must be provided. Description is also allowed. All other fields are ignored. If both Id and Name are specified, then Id takes precedence.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostUsergroupId" type="na:AccessObjectId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the new usergroup created on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes a usergroup on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostUsergroupNameOrId" type="na:UsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the usergroup on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUsergroupListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminates a View list iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous HostUsergroupListIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUsergroupListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To HostUsergroupListIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous host-group-list-iter-start call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostUsergroups" type="na:ArrayOfHostUsergroupInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of usergroups on Host(s).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of usergroups on Host(s). Usergroups on Host(s) that Match all filters will be returned. If no input is specified, all the usergroups on all monitored storage systems or vFiler units will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="HostUsergroupNameOrId" type="na:UsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of an object To list the usergroups for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Host (allowed Host types are storage system and vFiler Unit) &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Verbose" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Default is false. If set To true, then the roles and allowed Capabilities are placed into the HostUsergroupInfo element.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with host-group-list-iter-next. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To HostUsergroupListIterNext or HostUsergroupListIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modifies a usergroup on the Host.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostUsergroup" type="na:WrapperOfHostUsergroupInfo">
                            <xsd:annotation>
                                <xsd:documentation>Usergroup Name or Id must be provided. Host Name or Id is an optional parameter. If one or more roles(ids or names) and/or Description is provided, existing roles and/or Description are removed and updated with new ones. All other fields are ignored. If both Id and Name are specified, then Id takes precedence.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NewUsergroupName" type="na:UsergroupName">
                            <xsd:annotation>
                                <xsd:documentation>New usergroup Name for this usergroup. This is used To rename the usergroup specified in HostUsergroup. If this Value is invalid, HostUsergroupModify fails without changing anything. The Value is optional, and if not provided, the Group Name will be unchanged.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="HostUsergroupPush">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Pushes a usergroup To a Host. This is applicable for Hosts running ONTAP versions 7.0 and above. The Operation succeeds when the Host on which the usergroup is To be pushed contains roles similar To that of the usergroup. Two roles are similar if they have the same Name and same set of Capabilities.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the Host To push the usergroup on. Only storage systems and vFiler units are allowed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="HostUsergroupNameOrId" type="na:UsergroupNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the usergroup To be pushed on the Host.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="HostUsergroupPushResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="IfcListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of Interfaces.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous IfcListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="IfcListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="IfcListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next set of Records in the iteration started by call To IfcListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>Maximum Records To retrieve. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous IfcListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="IfcListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Ifcs" type="na:ArrayOfIfcInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Interfaces.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Value of 0 Records indicates that end of Records. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="IfcListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start iteration of Interfaces.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Ipspace" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>IPSpace Name. If specified only the Interfaces that belong the given Ipspace are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name of Id of the following Objects. &lt;UL&gt; &lt;LI&gt; Interface &lt;LI&gt; Storage system &lt;UL&gt; If storage sytem Name or Id is specified, only the Interfaces discovered on the storage system are returned. &lt;BR&gt; The Name of the Interface should be specified in &lt;storage system Name&gt;:&lt;Interface Name&gt; format. Ex: "toaster:e0a".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="IfcListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records fetched and stored for retrieval using IfcListInfoIterNext. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used for subsequent calls.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="LunListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The LunListInfoIter* set of APIs are used To retrieve the list of Luns. LunListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the LunListInfoIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="LunListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="LunListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check LunListInfoIterStart. The LunListInfoIterNext API is used To iterate over the Members of the Luns stored in the temporary store created by the LunListInfoIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous LunListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by LunListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="LunListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Luns" type="na:ArrayOfLunInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Luns.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="LunListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The LunListInfoIter* set of APIs are used To retrieve the list of Luns in DFM. LunListInfoIterStart returns the union of Lun Objects specified, intersected with RbacOperation. It loads the list of Luns into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Luns in the temporary store. If LunListInfoIterStart is invoked twice, then two distinct temporary stores are created.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Luns for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Host &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;li&gt; Lun &lt;/ul&gt; If ObjectNameOrId identifies a Lun, that single Lun will be returned. If ObjectNameOrId resolves To more than one Lun, all of them will be returned. If no ObjectNameOrId is provided, all Luns will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RbacOperation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of an RBAC Operation. If specified, only return Luns for which authenticated admin has the required Capability. A Capability is an operation/resource pair. The Resource is a Lun or a container with one or more Luns in it. The possible Values that can be specified for Operation can be obtained by calling RbacOperationInfoList. If Operation is not specified, then it defaults To DFM.Database.Read. For more information about operations, Capabilities and user roles, see the RBAC APIs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="LunListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with LunListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To LunListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateCancel">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Cancel the migration Operation for the specified vFiler Unit or Dataset. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status of the specified vFiler Unit is such that MigrateCancel Operation cannot be initiated. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether a dry run needs To be done of all the tasks To be performed as part of MigrateCancel Operation. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler Unit or Dataset whose migration Operation has To be cancelled. The migration Status of the vFiler Unit or the vFiler Unit attached To the specified Dataset should be either "migrating" or "migrate_failed".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateCancelResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job started To cancel the migration Operation. only returned if DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateChangeState">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Change the state of a migration Operation initiated for a vFiler Unit or Dataset. Only the following state changes are allowed through this API: &lt;ul&gt; &lt;li&gt; Change From "migrated" To "not_started": This is used To retain stale storage on the Source hosting storage system and migrating a vFiler Unit again. &lt;li&gt; Change From "migrated_with_errors" To "migrated": This is used To change the state after going through the Errors that occured after cutover and correcting them as necessary. &lt;li&gt; Change From "rolledback_with_errors" To "rolledback": This is used To change the state after going through the Errors that occured after cutover and correcting them as necessary. Error conditions: &lt;UL&gt; EDATABASEERROR - A database Error occurred while processing the Request. EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status change is not allowed. EINVALIDINPUT - Invalid input specified. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="NewMigrationStatus" type="na:MigrationStatus">
                            <xsd:annotation>
                                <xsd:documentation>The new migration Status for the vFiler Unit or Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler Unit or Dataset whose migration Status has To be changed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateChangeStateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="MigrateCleanup">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete the stale storage associated with a migration Operation From the Source storage system. This will Destroy all the Volumes of the Source vFiler Unit after successful migration of the vFiler Unit. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status of the specified vFiler Unit is such that MigrateCleanup Operation cannot be initiated. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>A DryRun flag that indicates To show a DryRun Result of the Volumes that will be destroyed as part of this cleanup Operation From the Source storage system. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler Unit or the Dataset whose stale storage has To be cleaned up. The migration Status of the vFiler Unit or the vFiler Unit attached To the Dataset should be "migrated".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateCleanupResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job started To cleanup storage after the migration Operation. Returned only when DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateComplete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Complete the migration Operation by doing a cutover From the Source vFiler Unit To destination vFiler Unit. As part of cutover Operation the following will be done: A script if specified, will be run in pre mode. The actual cutover will be carried out so that the Source vFiler Unit is destroyed and data will be served From the destination vFiler Unit. The script if specified, will be run in post mode after successful cutover. For all Volumes of the vFiler Unit, the protection relationships will be migrated To the new destination. All the backup versions will be modified so that they point appropriately To the newly created destination Volumes. The migration Status is changed To 'migrated' after a successful completion of migration. If MigrateComplete fails To cutover To destination storage, then the migration Status is changed To 'migrate-failed'. If the cutover To the destination storage succeeds during completion, but some of the subsequent steps like migrating the protection relationships, or copying the History data fails, then the Status is changed To 'migrated-with-errors'. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the specified vFiler Unit is not in "migrating" Status. &lt;LI&gt;EONLINENOTPOSSIBLE - When online migration cannot be performed, but offline migration is still possible. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>A DryRun flag that indicates To show a DryRun Result of the MigrateComplete Operation. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaxCutoverTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Value provided will be in seconds and this Value defines, the time by which non-disruptive migration should complete. Default Value is 120 seconds. Range [120..1800].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MigrateOffline" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This flag is considered only when migration is started as online migration. When true, offline migration is performed. If false or not specified online migration is performed. This flag is ignored if the migration is not online. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler Unit or the Dataset for which the migration Operation has To be completed. For a MigrateComplete Operation, the Source vFiler Unit should be given as input. The migration Status of the vFiler Unit or the vFiler Unit attached To the Dataset should be "migrating".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PersistentMigratedRoutes" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this Option is set, then the migrated routes From the Source will be made persistent on the destination storage system. This input is ignored, if the RouteMigrationMode is 'none'. Default Value is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RouteMigrationMode" type="na:RouteMigrationMode">
                            <xsd:annotation>
                                <xsd:documentation>Type of routes that needs To be migrated as part of cutover.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RunDedupeScan" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether a full deduplication scan has To be run on the deduplication enabled Volumes of the migrating vFiler Unit on destination storage system after migration. This input is valid only for Volumes in the vFiler Unit which have deduplication turned on and ignored for other Volumes. Default is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScriptPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Path To a script that will be run in pre and post mode just before and after cutover Operation.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateCompleteResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job started To carry out the complete Operation. Returned only when DryRun flag is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateFix">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Fix the migration Status of a Dataset. This API should be called if migration job was aborted abnormally, due To server shutdown or machine reboot etc. It fixes the database entries and migration Status of the Dataset. It can be called only if the last migration job run on the Dataset terminated abnormally. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDINPUT - Invalid input specified. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the Dataset for which migration job was terminated abnormally. This field is deprecated now and ObjectNameOrId field should be used. This field will be ignored if ObjectNameOrId is specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name of Id of the dataset/vfiler for which migration job was terminated abnormally.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateFixResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job started To fix the previous crashed/stopped vFiler Unit migration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateRollback">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Rollback the previous migrated vFiler Unit From the destination vFiler Unit To it's original Source vFiler Unit. As part of rollback Operation the following will be done: A script if specified, will be run in pre mode. Rollback will be carried out so that the destination vFiler Unit is destroyed and data will be served From the Source vFiler Unit. The script if specified, will be run in post mode after successful cutover. For all Volumes of the vFiler Unit, the protection relationships will be migrated To the new destination. All the backup versions will be modified so that they point appropriately To the newly created Source Volumes. The migration Status is changed To 'rolled_back' after a successful rollback. If MigrateRollback fails To cutover To Source storage, then the migration Status will be changed To 'migrated'. If the cutover To the Source storage succeeds during rollback, but some of the subsequent steps like migrating the protection relationships, or copying the History data fails, then the Status is changed To 'rolled_back_with_errors'. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EONLINENOTPOSSIBLE - When online migration cannot be performed, but offline migration is still possible. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether a dry run needs To be done of all the tasks To be performed as part of MigrateRollback Operation. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MaxCutoverTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Value provided will be in seconds and this Value defines, the time by which non-disruptive migration should complete. Default Value is 120 seconds. Range [120..1800].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MigrateOffline" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This flag is considered only when cutover was done as online migration. When true, offline migration is performed. If false or not specified online migration is performed. The flag is ignored if the migration is not online. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler Unit or Dataset whose migration Operation has To be rolled back. The migration Status of the vFiler Unit or the vFiler Unit attached To the specified Dataset should be in "migrated".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PersistentMigratedRoutes" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this Option is set, then the migrated routes From the Source will be made persistent on the destination storage system. This input is ignored, if the RouteMigrationMode is 'none'. Default Value is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RouteMigrationMode" type="na:RouteMigrationMode">
                            <xsd:annotation>
                                <xsd:documentation>Type of routes that needs To be migrated as part of cutover.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RunDedupeScan" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether a full deduplication scan has To be run on the deduplication enabled Volumes of the migrating vFiler Unit on Source storage system after migration. This input is valid only for Volumes in the vFiler Unit which have deduplication turned on and ignored for other Volumes. Default is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScriptPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Path To a script that will be run in pre and post mode just before and after rollback Operation.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateRollbackResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job started To rollback the migration Operation. Returned only when DryRun is false. Range [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start the migration Operation for a Dataset or a vFiler Unit. This initiates a baseline transfer for all the Volumes in the Source vFiler Unit and changes the migration Status To 'migrating'. When a Dataset is given as input then the following conditions should hold good: &lt;UL&gt; &lt;LI&gt; A vFiler Unit should be attached To the primary node of the Dataset. &lt;LI&gt; All the Volumes of the vFiler Unit with the exception of the root storage should belong To this Dataset. &lt;LI&gt; For offline migration, the migrating vFiler Unit may contain Qtree as it's root storage. &lt;LI&gt; For online migration, the migrating vFiler Unit should contain a Volume as it's root storage. &lt;/UL&gt; If any of these conditions are not met, then EMIGRATENOTSUPPORTED is returned. If PerformCutover is set To true, then MigrateComplete will be done after MigrateStart. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. If ResourceNameOrId refers To a Resource pool, user should have DFM.ResourcePool.Provision on it. If ResourceNameOrId refers To a storage system, user should have DFM.Resource.Control on it. If ProvisioningPolicyNameOrId is specified, user should have DFM.Policy.Read on it. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit, Dataset, destination storage system or provisioning Policy is not found. &lt;LI&gt;EINVALIDMEMBERTYPE - When the specified Filer is in c-mode. &lt;LI&gt;EINVALIDINPUT - When invalid inputs are provided for IP Address, Netmask. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the specified vFiler Unit is already in "migrating" Status or in a state where migration cannot be started. &lt;LI&gt;EMIGRATENOTSUPPORTED - When the Dataset or Source vFiler Unit cannot be migrated due To various reasons like invalid vFiler Status, ONTAP Version. &lt;LI&gt;EMIGRATEDESTINATIONSELECTIONFAILED - When a suitable storage system is not found as a destination for migration. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BandwidthThrottle">
                            <xsd:annotation>
                                <xsd:documentation>Specify the bandwidth throttle(in kbps) To be used for baseline transfer and subsequent SnapMirror updates. This element is valid only for OnlineMigration. Default is 0 which means unlimited bandwidth for the transfers. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Description">
                            <xsd:annotation>
                                <xsd:documentation>A short optional Description of the migration activity. Default is an empty Description. Range: [0..4096] characters.</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="4096"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether a dry run needs To be done of all the tasks To be performed as part of MigrateStart Operation. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IpBindings" type="na:ArrayOfIpBindingInfo">
                            <xsd:annotation>
                                <xsd:documentation>IP Address To Interface binding information for the destination vFiler Unit. If this element is not present, then the Interface configured as the "defaultVFilerInterface" for the selected destination storage system is used To bind IP Addresses of the Source vFiler Unit at the destination.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler Unit or the Dataset which has To be migrated. If the input element is a Dataset, then a vFiler Unit should be attached To the Dataset and all the Volumes of the vFiler Unit should be Members of the primary node of the Dataset with the exception of the root storage. The vFiler Unit will be migrated To a new storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OnlineMigration" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates, that cutover has To be performed non-disruptively. This input is considered only when a vFiler Unit is migrated and ignored when ObjectNameOrId refers To a Dataset. For Datasets, the migration will be done in an online or offline mode depending on 'OnlineMigration' attribute set on the Dataset Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PerformCutover" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this Option is set To true, then MigrateComplete will be done after MigrateStart. If cutover fails because of some Reason, then MigrateStart Status will be set To 'Migrating' and user can issue the MigrateComplete zapi To perform the cutover. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PersistentMigratedRoutes" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this Option is set, then the migrated routes From the Source will be made persistent on the destination storage system. This input is ignored, if the RouteMigrationMode is 'none'. This Option is valid if PerformCutover is set To true. Default Value is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the provisioning Policy To be used To provision destination Volumes during migration. This input is valid only when ObjectNameOrId refers To a Dataset. Default behavior is To use the current provisioning Policy associated with the Dataset or if not associated, To use the same Volume configuration as that of the Source vFiler Unit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourceNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the destination storage system or Resource pool To which the vFiler Unit is To be migrated. If ObjectNameOrId refers To a Dataset, this storage system should be a member of a Resource pool on which the user has required Capabilities. If ObjectNameOrId refers To a vFiler Unit, this can refer To any destination storage system on which the user has required Capabilities. The storage system should be running ONTAP Version same or above the Source storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RouteMigrationMode" type="na:RouteMigrationMode">
                            <xsd:annotation>
                                <xsd:documentation>Type of routes that needs To be migrated as part of cutover. This Option is valid if PerformCutover is set To true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScriptPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Path To a script that will be run in pre and post mode just before and after cutover Operation. This is applicable only when PerformCutover is set To true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeAggregateMap" type="na:ArrayOfVolumeAggregatePair">
                            <xsd:annotation>
                                <xsd:documentation>A list of (Volume, Aggregate) pairs. The Volume is the vFiler Volume being migrated. The Aggregate is the Aggregate on the destination storage system where this Volume should be migrated To. This input is valid only when the ObjectNameOrId is a vFiler Name or Id. If both VolumeAggregateMap and ResourceNameOrId inputs are specified, an Error will be reported.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The identifier of the job started To carry out the MigrateStart Operation. This field is returned only when DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateUpdate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Update all the SnapMirror relationships of a vFiler Unit for which migration Operation has been initiated. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status of the vFiler Unit is such that MigrateUpdate cannot be called. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the Dataset or vFiler Unit whose migration Status is "migrating" and whose SnapMirror relationships are To be updated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateUpdateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="JobId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the job started To update the SnapMirror relationships for a vFiler Unit migration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateVolume">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Migrate one or more Volumes From one Aggregate To another Aggregate on the same or different storage system. Currently this API works only for secondary Volumes i.e destinations of a Volume SnapMirror or Qtree SnapMirror relationships or if the Volumes are SnapVault secondaries. In addition To the above, the following rules must be satisfied To be able To MigrateStart Volumes using this API :- &lt;UL&gt; &lt;LI&gt; The Volume(s) should not have child clones (FlexClones). &lt;LI&gt; The Volume(s) should not have NFS exports, CIFS shares or contain LUNs mapped To storage clients. &lt;LI&gt; The Volumes(s) should be part of a Dataset (i.e either imported into Datasets, or provisioned by Protection Manager.) so that incoming and outgoing data protection relationships To and From the Volumes are managed by Protection Manager. &lt;UL&gt; If the destination Aggregate is not specified, then the system will automatically select an Aggregate, based on the Type of the Volume, space requirements, provisioning and protection Policy configuration associated with the Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether a dry run needs To be done of all the tasks To be executed as part of migrating Volumes. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="MigrationRequestInfo" type="na:MigrationRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of migration Request for Volumes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="MigrateVolumeResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="MigrationDryRunResults" type="na:ArrayOfMigrationDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Dry run Results for migrating each individual Volume. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MigrationJobs" type="na:ArrayOfMigrationJobInfo">
                            <xsd:annotation>
                                <xsd:documentation>Job identifiers of migration Jobs for each Volume. Only returned if DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="NetifIpInterfaceListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the list of Interfaces on a storage system.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CommunityString" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>SNMP community string To use. If omitted, the default "public" is used.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Hostname" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Hostname or IP Address of the device To Query with SNMP.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Timeout">
                            <xsd:annotation>
                                <xsd:documentation>Number of seconds To wait for a Response before giving up. If omitted, the default Value is 5 seconds. &lt;BR&gt;Range: [0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="NetifIpInterfaceListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Interfaces" type="na:ArrayOfNetifIpInterfaceInfo">
                            <xsd:annotation>
                                <xsd:documentation>The Response From the other server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfAssocViewListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a View list iteration and clean up any saved info by a previous call To PerfAssocViewListIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous PerfAssocViewListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfAssocViewListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfAssocViewListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns Objects From a previous call To PerfAssocViewListIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous perf-view-list-info-iter-start.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfAssocViewListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Views" type="na:ArrayOfPerfView">
                            <xsd:annotation>
                                <xsd:documentation>A list of Views</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfAssocViewListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of performance Views.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AssocObjType" type="na:PerfAssocObjType">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only Views with a matching associated object Type will be returned. This is ignored if ObjectNameOrId is specified. Otherwise, all performance Views will be returned (subject To the other optional parameters).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeEmptyViews" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If false, the following will be removed From the output Views: &lt;ul&gt; &lt;li&gt; Lines without any data Source &lt;li&gt; Charts without any Lines &lt;li&gt; Views without any Charts &lt;/ul&gt; By default, this is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Views for. If not specified, all Views will be returned (subject To the other optional parameters). The allowed object types for this argument are &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Dataset &lt;li&gt; Resource Pool &lt;li&gt; Host &lt;li&gt; vFiler &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;li&gt; Lun &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Verbose" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this is set To false, only a few fields for each View is returned instead of the entire metadata Default is true The following fields will be returned for each View &lt;ul&gt; &lt;li&gt; ViewName &lt;li&gt; ViewType &lt;li&gt; AssocObjType &lt;/ul&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ViewType" type="na:ViewType">
                            <xsd:annotation>
                                <xsd:documentation>Indicates the Type of Views To be returned. If not specified, all types of Views will be returned (subject To the other optional parameters).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfAssocViewListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval via calls To PerfViewListIterNext</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To PerfViewListIterNext or PerfViewListIterEnd</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends an iteration started by PerfClientStatsListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous call To PerfClientStatsListInfoIterStart</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfClientStatsListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns the per-client statistics loaded in a previous call To PerfClientStatsListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records To retrieve in this iteration. If not specified, a default Value of 20 is assumed. Range: [ 1 .. 2^31 - 1 ]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous call To PerfClientStatsListInfoIterStart</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="HostsClientStats" type="na:ArrayOfHostClientStats">
                            <xsd:annotation>
                                <xsd:documentation>The per-client Operation statistics.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records returned. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Iterates over the historical data of stored client statistics for storage systems. If no input filters are specified, all the available collections of statistics will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EndTime" type="na:Timestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only client statistics retrieved at or before this time will be returned. The time is specified in seconds From Epoch.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="LastOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>A convenience input To fetch only the last recorded collection for all Hosts, if ObjectNameOrId is not specified, or a specific Host if ObjectNameOrId is specified. If specified, StartTime and EndTime will be ignored, and this cannot be specified in conjunction with StatId.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Name or Id of the object for which historical client statistics are To be retrieved. If not specified, the statistics will be returned for all available Objects. The object must be a storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="na:Timestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only client statistics retrieved at or after this time will be returned. The time is specified in seconds From Epoch.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StatId" type="na:StatId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only the collection of statistics with this Id will be returned and all other inputs will be ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records retrieved. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag To be used in subsequent calls To PerfClientStatsListInfoIterNext or PerfClientStatsListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsPurge">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove collected client Stats From the database. If no input is specified, all collections for Hosts on which the user can perform the DFM.Database.Write Operation will be purged.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="EndTime" type="na:Timestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, all statistics collection collected before this time will be removed. The Timestamp must be specified in seconds From Epoch.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Name or Id, in the DFM database, of the object for which statistics collections should be purged. The object must be a storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="na:Timestamp">
                            <xsd:annotation>
                                <xsd:documentation>If specified, all statistics collection collected after this time will be removed. The Timestamp must be specified in seconds From Epoch.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StatId" type="na:StatId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id, in the DFM database, of the collection To be removed. If specified, all other inputs will be ignored. The user must have the Capability To perform the DFM.Database.Write Operation on the storage system for which the collection with this Id was collected.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfClientStatsPurgeResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DeletedStatsCount">
                            <xsd:annotation>
                                <xsd:documentation>Returns the number of collections of statistics purged From the database. Range: [0 .. 2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCollectClientOperationStatistics">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Collect per-client NFS and CIFS Operation statistics for a storage system. The collection of such statistics will be enabled on all vFiler units on the storage system for a short Period of time, and the collected Values will then be summarized and returned for the storage system as a whole. This ZAPI is synchronous and will not return an Error even if there are Errors collecting per-client statistics From some or all vFiler units on the storage system.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CollectionPeriod">
                            <xsd:annotation>
                                <xsd:documentation>Specifies, in seconds, the Period of time for which the collection of statistics should be enabled on the Filer. If not specified, a default Value of 15 will be assumed. The API will be blocked for at least this Period of time. In case of heavily loaded storage systems, the Duration of blocking may be significantly higher. Range: [15 .. 60]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="15"/>
                                    <xsd:maxInclusive value="60"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name or Id of the object on which the collection of per-client statistics is To be enabled. The object must be a storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCollectClientOperationStatisticsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Errors" type="na:ArrayOfClientStatError">
                            <xsd:annotation>
                                <xsd:documentation>Returns Errors encountered while collecting the per-client statistics, if any.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StatId" type="na:StatId">
                            <xsd:annotation>
                                <xsd:documentation>Returns the Id, in the DFM database, of the collection of statistics stored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCopyCounterConfiguration">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Propagates Source Host's current data collection settings To destination Hosts. When counter configuration is copied To destination Hosts, even if it fails for one Host, it proceeds further with the next available Host in the destination list. Privilege required is DFM.Database.Write.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="DestinationObjects" type="na:ArrayOfObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object, allowed object types for this argument are Host, Resource Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Preview" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this flag is true, it performs a dry run before actually committing the changes. It returns a list of Counters, Host details in case of any discrepancies between Source, destination Hosts. By default true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SourceHostNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>DFM Hostname or Id, the allowed Value for this argument is a valid storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SrcIsDefault" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This flag allows the destination Objects To attach To the default configuration. Default Value is set To FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCopyCounterConfigurationResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CopyResult" type="na:ArrayOfDestinationHostInfo">
                            <xsd:annotation>
                                <xsd:documentation>Result of copy Operation. This element will be included irrespective of Preview flag settings. On successful copy Operation 'CopyResult' will include only 'HostName, HostId' elements. In case of failure the output includes additional element 'ErrorReason'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MissingHostObjectCounters" type="na:ArrayOfPerfMissingHostObjectCounter">
                            <xsd:annotation>
                                <xsd:documentation>List of Counters not available with destination Hosts. The output will include these elements only if Preview flag is set To true and there is a discrepancy between Source, destination Hosts.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PurgedHostObjectCounters" type="na:ArrayOfPerfPurgedHostObjectCounter">
                            <xsd:annotation>
                                <xsd:documentation>List of Counters for which historical data will be purged. The output will include these elements only if Preview flag is set To true and there is a discrepancy between Source, destination Hosts.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a counter Group. Global DFM.PerfView.Write is required To create historical counter Group. To create a RealTime counter Group Global DFM.PerfView.RealTimeRead is required.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="CounterGroup" type="na:WrapperOfPerfCounterGroup">
                            <xsd:annotation>
                                <xsd:documentation>The counter Group To create.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupCreateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfCounterGroupDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroys a counter Group. Privilege To Destroy a historical counter Group is Global DFM.PerfView.Delete. And To Destroy a RealTime counter Group, Global DFM.PerfView.RealTimeRead is required.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of counter Group To Destroy. All the Views that are using the counter Group are automatically destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfCounterGroupGetData">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve a set of data for a set of data sources From a specific counter Group. The data is extracted for the given time interval bounded by StartTime and EndTime. This API is suitable for extracting the data for a single line in a chart (graph). Privilege required is DFM.Database.Read. For viewing RealTime data Global DFM.PerfView.RealTimeRead is also required.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group Name From which we want To fetch data.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DataGroup" type="na:WrapperOfPerfDataGroup">
                            <xsd:annotation>
                                <xsd:documentation>A definition of the data Source(s) requested, plus an optional consolidation method.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EndTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the end of requested data. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. If unspecified, server should end with the latest available data.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SampleRate" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The desired interval between samples, in seconds. If the available samples have higher resolution than the one specified, multiple samples are consolidated into one sample To achieve the desired resolution, using the specified TimeConsolidationMethod. If unspecified, the data returned will be at the SampleRate specified upon creation of the counter Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the beginning of requested data. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. If unspecified, server should begin with the earliest available data.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimeConsolidationMethod" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A function To apply across the data To achieve the desired time resolution, if the requested SampleRate is different From the actual SampleRate of the data. The Values can be average, min, max, or last. The default is last.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupGetDataResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CounterData" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The retrieved data - possibly consolidated, but just a single array. The format is a series of comma-separated Timestamp:Value pairs. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. The Values may have optional decimal extensions, for example 1064439599:127,1064439600:98.6,1064439601:12</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Unit" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unit of CounterData. This element will not be present if the Unit is not known. Some possible Values are per_sec, percent, b_per_sec, kb_per_sec, msecs, usecs. Maximum Length: 32 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupGetDynamicDataSources">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve a list of top-n data sources for a counter. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group Name From which we want To fetch data.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DynamicDataSources" type="na:WrapperOfPerfDynamicDataSources">
                            <xsd:annotation>
                                <xsd:documentation>Criteria for choosing top-n Instances for a counter.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupGetDynamicDataSourcesResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DataSources" type="na:ArrayOfPerfDataSource">
                            <xsd:annotation>
                                <xsd:documentation>Identifiers for the data sources correspoing To dynamic Instances. Each PerfDataSource represents one Instance.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve one or more counter Groups. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards. Either ApplianceNameOrId or ObjectNameOrId should be specified, but not both. ObjectNameOrId is preferred as usage of ApplianceNameOrId, GroupNameOrId is deprecated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ConsolidateHosts" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, then information for all the Hosts is consolidated and returned instead of information for individual Hosts.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group Name To retrieve. If unspecified, all counter Groups will be retrieved.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CounterInfoOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the output element PerfCounterGroupStart, includes only the list of enabled Counters of the Host with object Type derived From the counter Group Name. In this case DataSources will not be returned. By default false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CustomOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, returns only custom counter Groups, by default false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DisabledCounterInfoOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, returns counter information of the presently disabled Counters. Default Value is FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId or ObjectNameOrId is specified. This field defaults To global Group if ApplianceNameOrId or ObjectNameOrId is not specified. ObjectNameOrId is preferred as usage of GroupNameOrId is deprecated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeCalculatedStats" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This Option is valid only if either 'CounterInfoOnly' or 'DisabledCounterInfoOnly' is set To TRUE. If this flag is set To TRUE, the counter information will include calculated Stats Counters otherwise by default it will exclude those Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MetaDataOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, do not return any perf-data-sources with the PerfCounterGroupStart. By default false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, output contains the CounterInfo element with list of enabled Counters belonging To supplied CounterGroupName. If CounterGroupName is not set then output includes Counters information for all counter Groups of the hosting Filer. Either ApplianceNameOrId or ObjectNameOrId should be specified, but not both. ObjectNameOrId is preferred as usage of ApplianceNameOrId, GroupNameOrId is deprecated.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CounterGroups" type="na:ArrayOfPerfCounterGroup">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group(s) retrieved.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a counter Group list iteration and clean up any saved info. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-counter-group-list-iter- call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To PerfCounterGroupListIterStart. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-counter-group-list-iter- call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="CounterGroups" type="na:ArrayOfPerfCounterGroup">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group(s) retrieved.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of performance counter Group names. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group Name To retrieve. If unspecified, all counter Groups will be retrieved.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CustomOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>if TRUE, only custom Groups will be retrieved, by default false</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MetaDataOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, do not include any perf-data-sources with each perf-counter-groups.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupListIterStartResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfCounterGroupModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an existing counter Group. User can modify the sample-interval, SampleBuffer and the counter set of an existing counter Group at the individual Host level. Modifying a counter set of a counter Group means user can selectively enable/disable Counters according To the requirement of collecting data. If a counter is disabled data will not be collected for that counter and this gives the flexibility of controlling load on a storage system. This zapi will only enable the Counters mentioned in the 'DataSources' part of the input parameter 'PerfCounterGroupStart' and rest of the Counters of the counter Group will be automatically disabled. User can also disable all the Counters of a counter Group by setting the flag 'IsDisableAll' in the input parameter 'PerfCounterGroupStart'. Enabling/disabling Counters is not allowed for calculated Stats Counters in default counter Groups. Privilege required is DFM.Database.Write.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroup" type="na:WrapperOfPerfCounterGroup">
                            <xsd:annotation>
                                <xsd:documentation>The new counter Group information. Note that the new counter Group Name may be different From the old counter Group Name. If different, the new counter Group Name must not already exist.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name of the counter Group To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfCounterGroupStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start data collection for one counter Group. Privilege required is Global DFM.PerfView.Write for normal Views and Global DFM.PerfView.RealTimeRead for RealTime Views.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group Name To start data collection for. This must not be a default counter Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupStartResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfCounterGroupStop">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Stop data collection for one counter Group. Privilege required is Global DFM.PerfView.Write for normal Views and Global DFM.PerfView.RealTimeRead for RealTime Views.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="CounterGroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Counter Group Name To stop data collection for. This must not be a default counter Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfCounterGroupStopResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfDiagTroubleshoot">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>This API shall troubleshoot the DFM object for performance related issues and provides the recommendations To help resolve them.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Duration" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The recent time in seconds for which the data has To be analyzed Either Duration or start-time/end-time has be specified but not both. An Error will be returned if at least one of them is not supplied.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EndTime" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the end of diagnosis window The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. Range: [0..(2^32)-1] Either Duration or start-time/end-time has To be specified but not both. An Error will be returned if at least one of them is not supplied.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>ObjectName or Id of the following Objects that needs troubleshooting. &lt;UL&gt; &lt;LI&gt;Storage System &lt;/UL&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the beginning of diagnosis window The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. Range: [0..(2^32)-1] Either Duration or start-time/end-time has To be specified but not both. An Error will be returned if at least one of them is not supplied.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfDiagTroubleshootResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Categories" type="na:ArrayOfPerfDiagCategory">
                            <xsd:annotation>
                                <xsd:documentation>List of root causes or performance problems.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfDisableDataCollection">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Disables DFM performance advisor data collection.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsAsync" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Returns immediately without waiting for DFM performance advisor To disable the data collection completely (when set To true). By default this API is synchronous.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsPersistent" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true the disabling of Performance Advisor is saved in the database. If false, the disbling is temporary and the setting is not saved in the database. If the server restarts the data collection begins again.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfDisableDataCollectionResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfDisableObjectUpdate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Disables any modification To DFM performance advisor Views, counter Groups and object Instances.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfDisableObjectUpdateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfEnableDataCollection">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Enables DFM performance advisor data collection.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfEnableDataCollectionResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfEnableObjectUpdate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Enables modifications To DFM performance advisor Views, counter Groups and object Instances.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfEnableObjectUpdateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfGetCounterData">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve data for all the related Objects for the given object and the specified performance Counters.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Direction" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>This field is used only when Duration is specified It is used To derive the time Period for which data is To be retrieved. If the Value is set To 'forward', then the starting time is the time stamp of the oldest data. The ending time is the sum of time stamp of the oldest data and the Duration. If the Value is set To 'backward', then the starting time is the difference between time stamp of the most recent data and the Duration. The ending time is the time stamp of the most recent data. If the Value is set To 'backward-from-now', then the starting time is the difference between current time and the Duration. The ending time is the current time. Default Value is 'backward'</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Duration" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>The Duration for which the data is To be returned, in seconds. The time Period is calculated based on the Direction flag. Duration should not be specified when either StartTime or EndTime is specified. If specfied, EINVALIDINPUTERROR Error will be returned. Range: [0..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EndTime" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the end of requested data. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. If unspecified, server should end with the latest available data. Range: [0..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="InstanceCounterInfo" type="na:InstanceCounterInfo">
                            <xsd:annotation>
                                <xsd:documentation>This defines what counter data To be returned for the specified Instances.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NumberSamples">
                            <xsd:annotation>
                                <xsd:documentation>The Total number of samples To be returned. The SampleRate will be calculated based on the StartTime and EndTime. If the available samples have higher resolution than the one specified, multiple samples are consolidated into one sample To achieve the desired resolution, using the specified TimeConsolidationMethod. If unspecified, the number of samples returned will be based on the SampleRate specified upon creation of the View. Either SampleRate or NumberSamples should be specified, but not both. Range: [1..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SampleRate">
                            <xsd:annotation>
                                <xsd:documentation>The desired interval between samples, in seconds. If the available samples have higher resolution than the one specified, multiple samples are consolidated into one sample To achieve the desired resolution, using the specified TimeConsolidationMethod. If unspecified, the data returned will be at the SampleRate specified in the counter Group that the counter is present. Range: [1..(2^32)-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the beginning of requested data. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. If unspecified, server should begin with the earliest available data. Range: [0..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimeConsolidationMethod" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A function To apply across the data To achieve the desired time resolution, if the requested SampleRate is different From the actual SampleRate of the data. Possible Values : &lt;li&gt; 'average' &lt;li&gt; 'min' &lt;li&gt; 'max' &lt;li&gt; 'last' Default is 'last'</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimeFilter" type="na:TimeFilter">
                            <xsd:annotation>
                                <xsd:documentation>Time based filter To reading data. This filter will be applied on the range derived From the start-time/end-time/duration/direction fields. This field is used only for Metrics calculations, if Metrics field is not specified in the input this field will be ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetCounterDataResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="InvalidCounterInstances" type="na:ArrayOfInvalidCounterInstance">
                            <xsd:annotation>
                                <xsd:documentation>A list of invalid counter Instance pairs, for which performance data could not be fetched.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="PerfInstances" type="na:ArrayOfPerfInstanceCounterData">
                            <xsd:annotation>
                                <xsd:documentation>List of Instances. Each element of this list contains the counter data for an Instance.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetCounterDependents">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Find out the Operations Manager Reports, Performance Advisor custom Views, Performance Advisor threshold templates and Performance Advisor Thresholds which depend on the specified performance Counters.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Counters" type="na:ArrayOfPerfObjectCounter">
                            <xsd:annotation>
                                <xsd:documentation>The list of Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="HostNameOrId" type="na:HostNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Host Name or Id. If this parameter is specified, custom Views attached To object Instances will be returned in addition To the custom Views attached with object types.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetCounterDependentsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BaseCounters" type="na:ArrayOfPerfObjectCounter">
                            <xsd:annotation>
                                <xsd:documentation>The list of Counters To which at least one of the input Counters are dependent.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DependentCounters" type="na:ArrayOfPerfObjectCounter">
                            <xsd:annotation>
                                <xsd:documentation>The list of Counters dependent on at least one of the input Counters. This dependent counter list will contain both the calculated Stats as well as the basic Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Reports" type="na:ArrayOfPerfReport">
                            <xsd:annotation>
                                <xsd:documentation>The list of report names that have at least one of the input Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ThresholdTemplates" type="na:ArrayOfThresholdTemplate">
                            <xsd:annotation>
                                <xsd:documentation>The list of threshold template names that have at least one of the input Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Thresholds" type="na:ArrayOfPerfThreshold">
                            <xsd:annotation>
                                <xsd:documentation>The list of Thresholds that have at least one of the input Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Views" type="na:ArrayOfPerfView">
                            <xsd:annotation>
                                <xsd:documentation>The list of custom Views that have at least one of the input Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetCounterListNotInView">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Given an array of performance Objects and Counters, the API will return a list of all Counters that are not part of any View.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ObjectCounterList" type="na:ArrayOfPerfObjectCounterInfo">
                            <xsd:annotation>
                                <xsd:documentation>Array of PerfObjectCounterInfo elements for which information is needed, To know whether they belong To any View or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetCounterListNotInViewResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="OrphanObjectCounterList" type="na:ArrayOfPerfObjectCounterInfo">
                            <xsd:annotation>
                                <xsd:documentation>Array of PerfObjectCounterInfo elements that are not part of any View.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetDefaultView">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Gets the default View for an object.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the object for which the View is To be retrieved. If not present, then Global Group is assumed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetDefaultViewResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The ViewName which is To be displayed by default for the object. Maximum Length is 255 characters</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetServerStatus">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns the Status of DFM Performance Advisor.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfGetServerStatusResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="PerfServerStatus" type="na:PerfServerStatus">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Status of Performance Advisor.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectCounterListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve information about a performance object's Counters. (No iterator-based equivalent exists for this API because the number of object Counters is fewer than two hundred in number.) Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name or unique ID for the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeCalculatedStats" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If set To false the output will exclude the calculated Stats Counters. By default the Value is true i.e will always include calculated Stats.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the performance object To retrieve Counters for. Object names are broad classes of system components and protocols, like NFS, VOLUME, DISK, ...</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectCounterListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Counters" type="na:ArrayOfPerfCounter">
                            <xsd:annotation>
                                <xsd:documentation>Counters retrieved.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectDependentCounterListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve information about a performance object's dependent Counters. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name or unique ID for the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the performance object To retrieve dependent Counters. Object names are broad classes of system components and protocols, like NFS, VOLUME, DISK, ...</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectDependentCounterListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="DependentCounters" type="na:ArrayOfPerfDependentCounterInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of dependent Counters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectInstanceListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate an Instance list iteration and clean up any saved info. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-object-instance-list-iter- call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectInstanceListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfObjectInstanceListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To PerfObjectInstanceListIterStart Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-object-instance-list-iter- call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectInstanceListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Instances" type="na:ArrayOfPerfInstance">
                            <xsd:annotation>
                                <xsd:documentation>A list of Instances.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectInstanceListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of performance object Instance names. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name (or unique ID) of the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ObjectName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the performance object To retrieve Instances for. Object names are broad classes of system components and protocols, like NFS, VOLUME, DISK, ...</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectInstanceListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are avialble for future retrieval with PerfObjectInstanceListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To PerfObjectInstanceListIterNext or PerfObjectInstanceListIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectListInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get a list of performance Objects. (No iterator-based equivalent exists for this API because the number of performance Objects is fewer than twenty in number.) Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name (or unique ID) of the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfObjectListInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Objects" type="na:ArrayOfPerfObject">
                            <xsd:annotation>
                                <xsd:documentation>A list of performance Objects.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfSetDefaultView">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Sets the default View for an object.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the object for which the View is To be set. If not specfied, then the Global Group is assumed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The ViewName which is To be displayed by default for the object. Maximum Length is 255.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfSetDefaultViewResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfStatusGet">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns the DFM performance advisor Status</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="HostNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>DFM Name or Id of the Host</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfStatusGetResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DataUnavailableReason" type="na:ArrayOfPerfStatusError">
                            <xsd:annotation>
                                <xsd:documentation>This element is included only if IsDataAvailable is set To false and indicates the Reason(s) for failure.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="IsDataAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Returns if the performance data can be collected for this Host</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Sets threshold Values on one or more Objects based on a performance counter. Privilege required is DFM.Database.Write. Threshold will be set only if the User has DFM.Database.Write Permission over the object specified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThresholdInfo" type="na:ThresholdInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information about a threshold that needs To be set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ThresholdId" type="na:ThresholdId">
                            <xsd:annotation>
                                <xsd:documentation>If the threshold does not exist and is being created for the first time, then this parameter is present in the output. If a threshold already exists, then an Error is returned instead of this parameter.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdCreate2">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates one threshold composed of one or more Counters, and optionally applies it To an object. The user must have the Capability To perform the DFM.Database.Write Operation on the object on which the threshold is applied.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the object on which the threshold is To be applied. When applying a threshold To an object, in case of container Objects (like Groups) or parent Objects (like storage systems), if a counter is specified on a child object, the threshold applies To all such children. For example, if aggr:cp_reads is specified as one of the Counters in the threshold and there is no counter of an object which is a child of an Aggregate (viz. Volume or Qtree), and the ObjectNameOrId is that of a storage system, the threshold applies To all present and future Aggregates on the storage system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ThresholdInfo2" type="na:ThresholdInfo2">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Attributes of the threshold To be created.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdCreate2Result">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ThresholdId" type="na:ThresholdId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the threshold that is created.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Removes threshold set on a counter. The user must have the Capability To perform the DFM.Database.Delete Operation on the object on which the threshold is directly applied.&lt;P&gt; This ZAPI cannot be used To delete template Thresholds, and PerfThresholdTemplateModify should be used for that purpose.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThresholdId" type="na:ThresholdId">
                            <xsd:annotation>
                                <xsd:documentation>The unique identifier of a threshold that needs To be deleted.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a counter-thresholds-list iteration and clean up any saved info. Privilege required is DFM.Database.Read. Only Thresholds on Objects over which the user has DFM.Database.Read permissions will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-threshold-list-iter call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdListInfoIter* list of APIs are used To retrieve the list of all Counters on which Thresholds have been set. It loads the list of Counters on which Thresholds have been set into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the threshold related Counters in the temporary store. Privilege required is DFM.Database.Read. Only Thresholds on Objects over which the user has DFM.Database.Read permissions will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;P&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-threshold-list-iter call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AttributesList" type="na:ArrayOfThresholdInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of performance Thresholds.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdListInfoIter* list of APIs are used To retrieve the list of all Counters on which Thresholds have been set. It loads the list of Counters on which Thresholds have been set into a temporary store. The API returns a Tag that identifies a temporary store so that subsequent APIs can be used To iterate over the threshold related Counters in the temporary store. Privilege required is DFM.Database.Read. Only Thresholds on Objects over which the User has DFM.Database.Read permissions will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Query" type="na:WrapperOfThresholdInfo">
                            <xsd:annotation>
                                <xsd:documentation>Attributes of the Thresholds that need To be listed. If none of the parameters are specified, then all the Thresholds will be listed. &lt;P&gt; If a single ThresholdId is specified, then only information relevant To that threshold will be returned and the rest of the parameters will be ignored. &lt;P&gt; If only an ObjectNameOrId is specified, then only Thresholds set on that object will be returned. Ex. if ObjectNameOrId identifies a Volume, Thresholds set on that Volume only will be returned. If ObjectNameOrId resolves To more than one Volume, Thresholds set on all of them will be returned. If no ObjectNameOrId is provided, all Thresholds will be listed. &lt;P&gt; Likewise, if only PerfObjectCounter is specified, only Thresholds that belong To this CounterName and object Type will be returned. If no CounterName is specified, Thresholds set on any counter is returned. &lt;P&gt; If both ObjectNameOrId and PerfObjectCounter is specified, then only Thresholds set on a combination of all these parameters will be listed. &lt;P&gt; The rest of the parameters in ThresholdInfo are ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval via calls To PerfThresholdListInfoIterNext</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To PerfThresholdListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfo2IterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a perf-thresholds-list-info2 iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous PerfThresholdListInfo2IterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfo2IterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfo2IterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdListInfo2Iter* list of APIs are used To retrieve the list of all Objects on which Thresholds have been set.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;P&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous PerfThresholdListInfo2IterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfo2IterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AttributesList" type="na:ArrayOfThresholdInfo2">
                            <xsd:annotation>
                                <xsd:documentation>List of performance Thresholds.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfo2IterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdListInfo2Iter* list of APIs are used To retrieve the list of Objects on which Thresholds have been set. It loads the list of Thresholds into a temporary store. The API returns a Tag that identifies the temporary store so that subsequent APIs can be used To iterate over the Thresholds in it. The user must have the Capability To perform the DFM.Database.Read Operation on the object on which the threshold is applied, and only Thresholds which are applied on such Objects will be returned.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only Thresholds set on this object will be returned. This includes Thresholds that apply To this object via inheritance. For example, if there is a threshold on an Aggregate counter applied To a Filer, and ObjNameOrId identifies an Aggregate in that Filer, the threshold will be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ThresholdId" type="na:ThresholdId">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only information relevant To the threshold with this Id will be returned. This parameter takes precedence over all others, and it may not be specified in combination with any of the other arguments.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdListInfo2IterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval via calls To PerfThresholdListInfo2IterNext</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To PerfThresholdListInfo2IterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Allows modification of threshold Value and threshold interval that have been set before. Privilege required is DFM.Database.Write.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Attributes" type="na:WrapperOfThresholdInfo">
                            <xsd:annotation>
                                <xsd:documentation>Attributes of a threshold that needs To be modified. If the ThresholdId is specified, then ObjectNameOrId and PerfObjectCounter are ignored. If the ThresholdId is not specified, then ObjectNameOrId and PerfObjectCounter are mandatory. The rest of the parameters are optional. If the ThresholdValue specified is in a different Metric, then the ThresholdUnit needs To be specified for appropriate conversion.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdModify2">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an existing threshold. This ZAPI should be used only for changing the parameters of a threshold, not for changing the Objects it is not applied on. The ObjectsInfo structure is ignored in this ZAPI. This ZAPI cannot be used To modify template Thresholds, and PerfThresholdTemplateModify should be used for that purpose. The user must have the Capability To perform the DFM.Database.Write Operation on the object on which the threshold is applied.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ThresholdInfo2" type="na:ThresholdInfo2">
                            <xsd:annotation>
                                <xsd:documentation>Information on the threshold To modify. The ThresholdId parameter must be specified To modify a threshold.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdModify2Result">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateAttachObjects">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Attach one or more Objects To a performance template. Either all input Objects get attached or none of them get attached. The specified Objects will get associated To the applicable Thresholds in the template. Objects cannot be attached if the template has no Thresholds. Objects already attached To the template are left unchanged. The user must have the Capability To perform the DFM.Database.Write Operation on the object To which the template is To be attached.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="NewObjects" type="na:ArrayOfObjectInfo">
                            <xsd:annotation>
                                <xsd:documentation>The list of Objects To be attached To the template. At least one object should be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="TemplateNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a performance template</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateAttachObjectsResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a template for perf Thresholds.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="MemberThresholds" type="na:ArrayOfThresholdInfo2">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Thresholds that are To be part of this template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TemplateDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="TemplateName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="TemplateId">
                            <xsd:annotation>
                                <xsd:documentation>This returns the Id of the template that is created Range: [1..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes a template.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="TemplateNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name or Id of the template that is To be deleted.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateDeleteResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="TemplateId">
                            <xsd:annotation>
                                <xsd:documentation>The Id of the deleted template. Range: [1..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="TemplateName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name of the deleted template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateDetachObjects">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Detaches one or more Objects From a performance template. Either all or none of the input Objects get detached. The user must have the Capability To perform the DFM.Database.Write Operation on the object which is To be detached From the template.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Objects" type="na:ArrayOfObjectInfo">
                            <xsd:annotation>
                                <xsd:documentation>The list of Objects To be detached From the template. At least one object should be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="TemplateNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of a performance template</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateDetachObjectsResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a perf-threshold-template-list iteration and clean up any saved information.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-threshold-template-list-iter-start call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdTemplateListInfoIter* list of APIs are used To retrieve the list of all Objects on which Thresholds have been set.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. &lt;P&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous PerfThresholdTemplateListInfoIterStart call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ThresholdTemplates" type="na:ArrayOfThresholdTemplateInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of performance Thresholds.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdTemplateListInfoIter* list of APIs are used To retrieve the list of all threshold templates that have been created. It loads the templates into a temporary store. The API returns a Tag that identifies a temporary store so that subsequent APIs can be used To iterate over the threshold related Counters in the temporary store.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeObjects" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the output will include Objects on which the template(s) apply. Only the direct Objects will be returned. Only Objects on which the user has the Capability To perform the DFM.Database.Read Operation will be returned. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeThresholds" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the output will include the Thresholds that are part of the template. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TemplateNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Return information of a specific template</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval via calls To PerfThresholdTemplateListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To PerfThresholdTemplateListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The PerfThresholdTemplateModify zapi is used To modify an existing threshold template. It can be used To add, remove or modify Thresholds in the template or modify Attributes of the template</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsEnabled" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>This specifies if the template is enabled or not. If not specified, the enabled/disabled state of the template is not modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MemberThresholds" type="na:ArrayOfThresholdInfo2">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Thresholds that are To be part of this template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TemplateDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A new Description for the template, if the Description is To be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="TemplateId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the template that is To be modified. Range: [1..2^32-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TemplateName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The new Name for the template, if the Name is To be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfThresholdTemplateModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfViewAssociatedObjectsList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List all the Objects associated with the View.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The View for which To list associated Objects</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewAssociatedObjectsListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Objects" type="na:ArrayOfObjectInfo">
                            <xsd:annotation>
                                <xsd:documentation>The Objects that are associated with the View</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a performance View. A performance View consists of one or more Charts, but each View refers To only a single counter Group. Global DFM.PerfView.Write RBAC Capability is required To create normal Views while Global DFM.PerfView.RealTimeRead is required To create RealTime View.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DataSources" type="na:ArrayOfPerfDataSource">
                            <xsd:annotation>
                                <xsd:documentation>Identifiers for the data sources To be retrieved in later queries. The DataSources can not contain 'Group' data Source. i.e. InstanceName must be specified for each PerfDataSource. The DataSources should not contain a data Source that specifies LabelNames field. This is because counter Group always collects data for the whole counter i.e. for all Labels. PerfDataSource is not required for default counter Groups. The PerfCounterGroupModify API ignores this element for default counter Groups.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RealTime" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Designates whether the counter Group is RealTime, in other words, if no user is getting data From the Group, then the counter Group will no longer get data. By default FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="View" type="na:WrapperOfPerfView">
                            <xsd:annotation>
                                <xsd:documentation>A performance View To create.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewCreateResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfViewDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a performance View. Global DFM.PerfView.Delete is required for destroying normal Views while Global DFM.PerfView.RealTimeRead is required for destroying RealTime Views.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name (or unique ID) of the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Group that this View is associated with. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsCounterGroupAlsoDeleted" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Also Destroy the associated counter Group. Default is false. This Option is ignored if the counter Group is default.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the View To be destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfViewGetData">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve data for a single DataSource From a specific performance View. The data is extracted for the given time interval bounded by StartTime and EndTime.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Direction" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>This field is used only when Duration is specified It is used To derive the time Period for which data is To be retrieved. If the Value is set To 'forward', then the starting time is the time stamp of the oldest data. The ending time is the sum of time stamp of the oldest data and the Duration. If the Value is set To 'backward', then the starting time is the difference between time stamp of the most recent data and the Duration. The ending time is the time stamp of the most recent data. If the Value is set To 'backward-from-now', then the starting time is the difference between current time and the Duration. The ending time is the current time. Default Value is 'backward'</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Duration" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>The Duration for which the data is To be returned, in seconds. The time Period is calculated based on the Direction flag. Duration should not be specified when either StartTime or EndTime is specified. If specfied, EINVALIDINPUTERROR Error will be returned. Range: [0..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DynamicObjectInfo" type="na:WrapperOfPerfDynamicDataSources">
                            <xsd:annotation>
                                <xsd:documentation>This defines what Objects are To be displayed for dynamic Charts like top-N Objects</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="EndTime" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the end of requested data. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. If unspecified, server should end with the latest available data Range: [0..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Instance" type="na:WrapperOfPerfCounterInstance">
                            <xsd:annotation>
                                <xsd:documentation>The object Instance for which data is To be retrieved</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDynamic" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates if top n data sources should be returned Default is false</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="NumberSamples">
                            <xsd:annotation>
                                <xsd:documentation>The Total number of samples To be returned. The SampleRate will be calculated based on the StartTime and EndTime If the available samples have higher resolution than the one specified, multiple samples are consolidated into one sample To achieve the desired resolution, using the specified TimeConsolidationMethod. If unspecified, the number of samples returned will be based on the SampleRate specified upon creation of the View. Either SampleRate or NumberSamples should be specified, but not both Range: [1..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SampleRate">
                            <xsd:annotation>
                                <xsd:documentation>The desired interval between samples, in seconds. If the available samples have higher resolution than the one specified, multiple samples are consolidated into one sample To achieve the desired resolution, using the specified TimeConsolidationMethod. If unspecified, the data returned will be at the SampleRate specified upon creation of the View Range: [1..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="4294967295"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StartTime" type="xsd:unsignedInt">
                            <xsd:annotation>
                                <xsd:documentation>Time stamp marking the beginning of requested data. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. If unspecified, server should begin with the earliest available data. Range: [0..(2^32)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TimeConsolidationMethod" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A function To apply across the data To achieve the desired time resolution, if the requested SampleRate is different From the actual SampleRate of the data. Possible Values : 'average' 'min' 'max' 'last' Default is 'last'</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The View From which data is To be retrieved Maximum Length is 255</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewGetDataResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CounterData" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A single array of the retrieved data. The format is a series of comma-separated Timestamp:Value pairs. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. The Values may have optional decimal extensions, for example 1064439599:127,1064439600:98.6,1064439601:12</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DynamicData" type="na:ArrayOfDynamicData">
                            <xsd:annotation>
                                <xsd:documentation>Contains data for top-N Objects</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Unit" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Unit of CounterData. This element will not be present if the Unit is not known. Some possible Values are per_sec, percent, b_per_sec, kb_per_sec, msecs, usecs. Maximum Length: 32 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a View list iteration and clean up any saved info. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous PerfViewListIterStart</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfViewListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve items From a previous call To PerfViewListIterStart Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag From a previous perf-view-list-iter- call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Views" type="na:ArrayOfPerfView">
                            <xsd:annotation>
                                <xsd:documentation>A list of Views.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of performance Views. Privilege required is read.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards. Only the Views for matching storage system are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CustomOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, returns only custom Views, by default FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the GroupListIterNext APIs. This is ignored if ApplianceNameOrId has been specified. Only the Views for matching Group are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeEmptyViews" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If false, the following will be removed From the output Views: &lt;ul&gt; &lt;li&gt; Lines without any data Source &lt;li&gt; Charts without any Lines &lt;li&gt; Views without any Charts &lt;/ul&gt; By default, this is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="InstanceName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only Views with a matching Instance will be returned. Otherwise, all performance Views will be returned (subject To the other optional parameters). You must specify ApplianceNameOrId and ObjectName when specifying InstanceName.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If specified, only Views with a matching object will be returned. Otherwise, all performance Views will be returned (subject To the other optional parameters).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If ViewName is specified, only the indicated View will be retrieved. Otherwise, all performance Views will be returned (subject To the other optional parameters).</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval via calls To PerfViewListIterNext</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To PerfViewListIterNext or PerfViewListIterEnd</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an existing performance View. Global DFM.PerfView.Write RBAC Capability is required To modify performance Views.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name (or unique ID) of the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Group that this View is associated with. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="View" type="na:WrapperOfPerfView">
                            <xsd:annotation>
                                <xsd:documentation>The new performance View information. Note that the new performance View Name may be different From the old performance View Name. If the new Name is different, the new Name must not already exist.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the performance View To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfViewObjectAssociationAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Associates an object with a View</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The object To be associated with the View</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The View for which the association is To be set</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewObjectAssociationAddResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="PerfViewObjectAssociationDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Removes the association of an object with a View</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The object To be dis-associated with the View</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ViewName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The View for which the association is To be deleted</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="PerfViewObjectAssociationDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyCopy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new provisioning Policy by making a copy of an existing Policy. The new Policy created using this ZAPI has the same set of Properties as the existing Policy. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the existing Policy From the database, or create a new Policy, or both. &lt;LI&gt; EOBJECTNOTFOUND - No existing Policy was found that has the given Name or ID. &lt;LI&gt; EOBJECTAMBIGUOUS - Multiple Objects with the given Name present in database. &lt;LI&gt; EPOLICYEXISTS - A Policy with the given ProvisioningPolicyName already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EINVALIDINPUTERROR - Invalid input was provided. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the new Policy. It may contain From 0 To 255 characters. If the Length is greater than 255 characters, the ZAPI fails with Error code EINVALIDINPUTERROR. The default Value is the empty string "".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ProvisioningPolicyName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new Policy. It must be unique across all provisioning and data protection policies.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="SourcePolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name or ID of an existing Policy that is copied To create the new Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyCopyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ProvisioningPolicyId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>An object ID for the newly created Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>This ZAPI creates a new provisioning Policy. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To create policies. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EINVALIDINPUTERROR - Invalid input was provided. &lt;LI&gt; EPOLICYEXISTS - A provisioning Policy with given Name already exists. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ProvisioningPolicyInfo" type="na:ProvisioningPolicyInfo">
                            <xsd:annotation>
                                <xsd:documentation>Provisioning Policy details of the new Policy To be created.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ProvisioningPolicyId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Object ID of the newly created Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a provisioning Policy. This removes it From the database. &lt;P&gt; If the Policy has been applied To any Dataset nodes, then the Destroy Operation fails; it must first be disassociated From all the Dataset nodes To which it has been associated and then destroyed. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have DFM.Policy.Delete on the Policy being destroyed. &lt;LI&gt; EOBJECTNOTFOUND - The specified provisioning Policy does not exist in the database. &lt;LI&gt; EPROVPOLICYINUSE - The Policy is assigned To one or more Datasets. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EOBJECTAMBIGUOUS - Multiple Objects with the given Name present in database. &lt;LI&gt; EEDITSESSIONINPROGRESS - The provisioning Policy being destroyed locked in an edit session. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Force delete even if there is an edit session in progress on the provisioning Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the provisioning Policy being destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyEditBegin">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create an edit session and obtain an edit lock on a provisioning Policy To begin modifying the Policy. &lt;P&gt; An edit lock must be obtained before invoking ProvisioningPolicyModify. &lt;P&gt; Use ProvisioningPolicyEditCommit To end the edit session and commit the changes To the database. &lt;P&gt; Use ProvisioningPolicyEditRollback To end the edit session and discard any changes made To the Policy. &lt;P&gt; 24 hours after an edit session on a Policy begins, any subsequent call To ProvisioningPolicyEditBegin for that same Policy automatically rolls back the existing edit session and begins a new edit session, just as if the call had used the Force Option. If there is no such call, the existing edit session simply continues and retains the edit lock. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITINPROGRESS - Another edit session already has an edit lock on the specified provisioning Policy. &lt;LI&gt; EOBJECTNOTFOUND - No provisioning Policy was found that has the given Name or ID. &lt;LI&gt; EACCESSDENIED - User does not have DFM.Policy.Write Privilege on the Policy. modify the provisioning Policy. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, and an edit session is already in progress on the specified Policy, then the previous edit is rolled back and a new edit is begun. If false, and an edit is already in progress, then the call fails with Error code EEDITINPROGRESS. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of a provisioning Policy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyEditBeginResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="EditLockId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. Range: [0..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyEditCommit">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Commit changes made To a provisioning Policy during an edit session into the database.&lt;P&gt; If all the changes To the Policy are performed successfully, the entire edit is committed and the edit lock on the Policy is released.&lt;P&gt; If any of the changes To the Policy are not performed successfully, then the edit is rolled back (none of the changes are committed) and the edit lock on the Policy is released.&lt;P&gt; Use the DryRun Option To test the commit. Using this Option, the changes To the Policy are not committed To the database. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have DFM.Policy.Write on the Policy. &lt;LI&gt; EPOLICYEXISTS - The Policy's Name is being changed, and a Policy with the new Name already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return a list of the actions the system would take after committing the changes To the Policy, but without actually committing the changes. In addition, the edit lock is not released. By default, DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by ProvisioningPolicyEditBegin ZAPI.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyEditCommitResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyEditRollback">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Roll back changes made To a provisioning Policy. The edit lock on the Policy will be released after the rollback. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by ProvisioningPolicyEditBegin ZAPI.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyEditRollbackResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a list iteration that had been started by a call To ProvisioningPolicyListIterStart. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To ProvisioningPolicyListIterStart that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve the next series of policies that are present in a list iteration created by a call To ProvisioningPolicyListIterStart. The server maintains an internal cursor pointing To the last record returned. Subsequent calls To ProvisioningPolicyListIterNext return the next Maximum Records after the cursor, or all the remaining Records, whichever is fewer. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of policies To return. Range: [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The opaque handle returned by the prior call To ProvisioningPolicyListIterStart that started this list iteration.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ProvisioningPolicies" type="na:ArrayOfProvisioningPolicyInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of information about multiple provisioning policies.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records actually returned in the output. Range:[0..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Begin a list iteration over all content in all provisioning policies in the system. Optionally, you may iterate over the content of just a single Policy. &lt;p&gt; After calling ProvisioningPolicyListIterStart, you continue the iteration by calling ProvisioningPolicyListIterNext zero or more times, followed by a call To ProvisioningPolicyListIterEnd To terminate the iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the specified Policy. &lt;LI&gt; EOBJECTNOTFOUND - No Policy was found that has the given Name or ID. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or ID of the provisioning Policy. If provisioning Policy Name or ID is specified, then ProvisioningPolicyType filter is ignored.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyType" type="na:ProvisioningPolicyType">
                            <xsd:annotation>
                                <xsd:documentation>filter provisioning policies by Type. Possible Values are "nas", "san" and "secondary".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items present in the list iteration. Range:[0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used To identify the list iteration. The list content resides in a temporary store in the server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>This ZAPI modifies the provisioning Policy settings of an existing Policy in the database with the new Values specified in the input. Note: Type of provisioning Policy cannot be modified after creation. Before modifying the Policy, an edit lock has To be obtained on the Policy object. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - current modification made conflicts with previous change in the edit session. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EOBJECTNOTFOUND - The Policy was already destroyed during this edit session. &lt;LI&gt; EOBJECTAMBIGUOUS - Multiple Objects with the given Name present in database. &lt;LI&gt; EINVALIDINPUT - The requested modification is not applicable To the Policy being modified. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EDSCONFLICTDEDUPLICATION - Deduplication schedule cannot be set in the Policy if it is attached To a SnapVault destination node. Valid only for secondary provisioning Policy. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="EditLockId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the edit lock on the Policy. The Value must be an edit lock ID that was previously returned by ProvisioningPolicyEditBegin.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ProvisioningPolicyInfo" type="na:ProvisioningPolicyInfo">
                            <xsd:annotation>
                                <xsd:documentation>New Values for provisioning Policy Attributes. Any Value specified in the ProvisioningPolicyInfo replaces the existing Values of Attributes. If an optional element is not specified no change is made To the existing attribute settings in database.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ProvisioningPolicyModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="QtreeListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The QtreeListInfoIter* set of APIs are used To retrieve the list of Qtrees. QtreeListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the QtreeListInfoIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="QtreeListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check QtreeListInfoIterStart. The QtreeListInfoIterNext API is used To iterate over the Members of the Qtrees stored in the temporary store created by the QtreeListInfoIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous QtreeListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by QtreeListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Qtrees" type="na:ArrayOfQtreeInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Qtrees.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The QtreeListInfoIter* set of APIs are used To retrieve the list of Qtrees in DFM. QtreeListInfoIterStart returns the union of Qtree Objects specified, intersected with IsSnapvaultSecondaryQtrees, IsInDataset and RbacOperation. It loads the list of Qtrees into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Qtrees in the temporary store. If QtreeListInfoIterStart is invoked twice, then two distinct temporary stores are created.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each Qtree which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDirectMemberOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only return the Qtrees that are direct Members of the specified Resource Group. Default Value is false. This field is meaningful only if a Resource Group Name or Id is given for the ObjectNameOrId field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDirectVfilerChild" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Qtrees that are direct children of a Vfiler. If false, only list Qtrees that are indirect children of a Vfiler. If not specified, list Qtrees that are direct and indirect children of a Vfiler. This filter does not have any Effect if &lt;b&gt;ObjectNameOrId&lt;/b&gt; is not a Vfiler.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Qtrees that have been set To be ignored for purposes of data protection. If false, only list Qtrees that have been not set To be ignored for purposes of data protection. If not specified, list all Qtrees without taking into account whether they have been ignored or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsInDataset" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Qtrees which only contain data which is protected by a Dataset. If false, only list Qtrees containing data which is not protected by a Dataset. If not specified, list all Qtrees whether they are in a Dataset or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSnapvaultSecondaryQtrees" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only SnapVault secondary Qtrees are listed. Otherwise, all Qtrees are listed. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsUnprotected" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Qtrees that are not protected, which means they are not in any SnapMirror or SnapVault relationship. If false or not set, list all Qtrees.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Qtrees for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Dataset &lt;li&gt; Storage Set &lt;li&gt; Host &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;/ul&gt; If ObjectNameOrId identifies a Qtree, that single Qtree will be returned. If ObjectNameOrId resolves To more than one Qtree, all of them will be returned. If no ObjectNameOrId is provided, all Qtrees will be listed. If ObjectNameOrId identifies a Dataset or a storage set, only Qtrees that are direct Members of that Dataset or storage set will be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RbacOperation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of an RBAC Operation. If specified, only return Qtrees for which authenticated admin has the required Capability. A Capability is an operation/resource pair. The Resource is the Volume where the Qtree lives. The possible Values that can be specified for Operation can be obtained by calling RbacOperationInfoList. If Operation is not specified, then it defaults To DFM.Database.Read. For more information about operations, Capabilities and user roles, see the RBAC APIs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with QtreeListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To QtreeListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a Qtree's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Qtree. &lt;li&gt; EINVALIDINPUT - When invalid input specified. &lt;li&gt; EOBJECTNOTFOUND - When the QtreeNameOrId does not correspond To a Qtree. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To ignore this object for purposes of data protection.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="QtreeNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Qtree To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="QtreeRename">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Rename a Qtree on a storage system and in the DataFabric Manager database. The new Qtree will still be in the same Volume as the original Qtree. The first step renames the given Qtree on the storage system. If that fails, then processing stops and the API emits an EINTERNALERROR To the caller along with the appropriate Error message. The second step renames the given Qtree on the DFM database. If that fails, then processing stops and the same EINTERNALERROR is emitted back To the caller along with an appropriate Error message. There is no retrying or undoing of any of the steps should they fail. The API relies on the DFM monitor To undo the rename automatically. However, the undoing does not happen right away because it depends on the DFM monitor regular update schedule. The DFM monitor periodically ensures that storage system resources are matched in its database -- it updates the database To be consistent with the storage system. Prior To invoking this API, the storage system's login credentials where the Qtree resides must be specified in DFM's database using normal DFM procedure.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="QtreeNameNew" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>New Name for Qtree on storage system. This is just the Qtree Name, not including the storage system or Volume parts.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="QtreeNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Qtree To rename. If a Name is specified, then it must in the form specified by DFM's normal container and containment rules such as Hostname:/volume/qtree_name (for example, breeze:/vol0/myqtree). Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeRenameResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="QtreeStartMonitoring">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Start monitoring a previously un-monitored primary Qtree From the DataFabric Manager. Error EQTREEMONITORONFAIL means that an attempt To start monitoring the specified Qtree failed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="QtreeNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>A Qtree Name or identifier To start monitoring. Name must in the form specified by DFM's normal container and containment rules such as Hostname:/volume/qtree_name (for example, breeze:/vol0/myqtree). Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeStartMonitoringResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="QtreeStopMonitoring">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Stop monitoring a primary Qtree From the DataFabric Manager. A Qtree that is being managed by an application cannot be stopped being monitored (Errno returned will be EQTREEMANAGEDBYAPP)</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="QtreeNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>A Qtree Name or identifier To stop monitoring. Name must in the form specified by DFM's normal container and containment rules such as Hostname:/volume/qtree_name (for example, breeze:/vol0/myqtree). Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="QtreeStopMonitoringResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacAccessCheck">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Checks whether the given admin or usergroup has access To the specified Resource. For example, RbacAccessCheck will return "allow" or "deny" on the following Query: Is admin joe allowed To configure storage system, host1.abc.xyz.com, From DFM? One could pass the following as input To answer this question: admin=joe operation=DFM.Event.Read resource=host1.abc.xyz.com In order To prevent an admin From querying everyone's privileges on the system, the system will only allow Admins To check their own access by cross-referencing with however they authenticated To the API server. If the admin has Full Control, or has the Privilege To Query other admin's access, then they will be allowed To make the Query. Per software security best practice, this API limits Error reporting when access is denied on a particular Resource.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AdminNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The admin or usergroup Name or object Id of an admin or usergroup To check access.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Operation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Operation requested on given Resource</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Resource" type="na:WrapperOfResourceIdentifier">
                            <xsd:annotation>
                                <xsd:documentation>The specific Resource To check access</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAccessCheckResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GlobalUsergroupStatus" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If roles assigned To global usergroup accounts where considered, but it was not possible To get glogal Group account information From the system, then GlobalUsergroupStatus will contain the Reason why it was not possible To get global Group account information From the system. An empty Value in this field means that roles assigned To global usergroup accounts were considered and it was possible To obtain this information From the system</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="LocalUsergroupStatus" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If roles assigned To local usergroup accounts where considered, but it was not possible To get local Group account information From the system, then LocalUsergroupStatus will contain the Reason why it was not possible To get local Group account information From the system. An empty Value in this field means that roles assigned To local usergroup accounts were considered and it was possible To obtain this information From the system,</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Result" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Result of whether or not the given admin or usergroup is allowed To perform the specified Action on the given Resource. In essence, it answers whether the given admin or usergroup can perform the specified Operation on the the given Resource. Possible Values: "allow" for access allowed and "deny" for access denied.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends listing of Admins.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag returned From rbac-admin-list-iter-start.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacAdminListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From list generated by RbacAdminListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The Tag returned in rbac-admin-list-iter-start call.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Admins" type="na:ArrayOfAdminInfo">
                            <xsd:annotation>
                                <xsd:documentation>The list returned includes the Id, Name of administrators and their email/pager addresses.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Lists all the administrators and their Attributes.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AdminNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The admin or usergroup Name or Id whose details are necessary.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with RbacAdminListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To RbacAdminListInfoIterNext or RbacAdminListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminRoleAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Assign an existing role To an existing administrator or usergroup. The administrator effectively gains the Capabilities From the role and its inherited roles. As for a usergroup, all Members of the usergroup will gain the Capabilities assigned To that role and its inherited roles.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AdminNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The admin or usergroup Name or object Id of an admin or usergroup To add role To.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To add To an administrator or usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminRoleAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AdminNameOrId" type="na:WrapperOfRbacAdminNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name of the new admin or usergroup or the object Id of the new admin or usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminRoleInfoList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List the administrators or usergroups assigned To an existing role directly or indirectly. In essence, this API lists the Admins or usergroups that have the Capabilities of the given role. This API drills into all the possible ways that an admin or usergroup can effectively have the given role. Admins or usergroups are assigned roles indirectly via role inheritance or usergroup assignment (note: a usergroup can be a member of another usergroup). So an admin or usergroup will be listed if any of the following conditions apply: 1. Given role is directly assigned To the admin or usergroup 2. Admin or usergroup has a role directly assigned that inherits given role. 3. Admin or usergroup gains the given role via usergroup membership</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An role Name or object Id of a role.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminRoleInfoListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AdminList" type="na:ArrayOfRbacAdminOrUsergroup">
                            <xsd:annotation>
                                <xsd:documentation>List of Admins and usergroups assigned To given role</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminRoleRemove">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove one or more roles From an administrator or usergroup. The admin will no longer have the Capabilities gained From the role(s) and its inherited roles. As for a usergroup, the Members of the usergroup will no longer have the Capabilities gained From the role(s) and its inherited roles. If DeleteAll is not specified or is FALSE, then RoleNameOrId must be specified. If DeleteAll is TRUE, then all roles assigned To admin will be removed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AdminNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An admin or usergroup Name or object Id of an admin or usergroup To remove role From. If DeleteAll is not specified or is FALSE then RoleNameOrId must be specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DeleteAll" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, removes all the roles for given administrator</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To remove From an admin or usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacAdminRoleRemoveResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacOperationAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a new Operation To the RBAC system. An Operation is an ability To perform an Action on a particular Resource Type. An Operation is tied To a specific application so that different applications are able To manage access control that are specific To them.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Operation" type="na:WrapperOfRbacOperation">
                            <xsd:annotation>
                                <xsd:documentation>Operation To be added</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacOperationAddResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacOperationDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete an existing Operation</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Operation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Operation To delete</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacOperationDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacOperationInfoList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get information about an existing Operation or all operations in the system.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Operation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Operation To get information about. If not specified, then it gets info on all operations in the system.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacOperationInfoListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="OperationList" type="na:ArrayOfRbacOperation">
                            <xsd:annotation>
                                <xsd:documentation>A list of operations with their details</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a new role To the RBAC system</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Description" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the role. The Maximum Length is 255 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OwnerNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Owner role Name To add. The Maximum Length is 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Role Name To add. The Maximum Length is 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="RoleId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>role Id of the newly created role.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleAdminInfoList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>List the roles assigned To an existing administratror or usergroup. A role is considered assigned To the administrator if that role is gained directly or indirectly via role inheritance or usergroup membership.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="AdminNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An administrator or usergroup Name or object Id of an administrator or usergroup To list roles assigned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="FollowRoleInheritance" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, return all roles that given role inherits directly and indirectly. If FALSE or not set, return only roles that are directly assigned To the given administrator or usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleAdminInfoListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="AdminNameOrId" type="na:WrapperOfRbacAdminNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name of the admin or usergroup or the object Id of the admin or usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GlobalUsergroupStatus" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If roles assigned To global usergroup accounts where considered, but it was not possible To get glogal Group account information From the system, then GlobalUsergroupStatus will contain the Reason why it was not possible To get global Group account information From the system. An empty Value in this field means that roles assigned To global usergroup accounts were considered and it was possible To obtain this information From the system</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="LocalUsergroupStatus" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>If roles assigned To local usergroup accounts where considered, but it was not possible To get local Group account information From the system, then LocalUsergroupStatus will contain the Reason why it was not possible To get local Group account information From the system. An empty Value in this field means that roles assigned To local usergroup accounts were considered and it was possible To obtain this information From the system,</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RoleList" type="na:ArrayOfRbacRoleResource">
                            <xsd:annotation>
                                <xsd:documentation>A list of role names assigned To the given administratror or usergroup. The list will be empty if no roles are currently assigned To the administrator or usergroup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleCapabilityAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add an existing resource/operation pair To a role. In essence, this adds a Capability To a role.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Operation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An existing Operation To add To the specified role.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Resource" type="na:WrapperOfResourceIdentifier">
                            <xsd:annotation>
                                <xsd:documentation>The Resource associated with the given Operation</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Role Name or object Id of the role To add the Capability (operation/resource pair)</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleCapabilityAddResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacRoleCapabilityRemove">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove one or more Capabilities (resource/operation pair) From an existing role. If DeleteAll is TRUE, it removes all Capabilities From given role. Otherwise, it removes only the given Capability (resource/operation pair). If DeleteAll is not specified or is FALSE, then Operation and Resource must be specified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DeleteAll" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, removes all the Capabilities for given role. If FALSE, a valid Operation must be provided in the Operation parameter.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Operation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An Operation To remove. If DeleteAll is FALSE, the caller must provide a valid Operation here.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Resource" type="na:WrapperOfResourceIdentifier">
                            <xsd:annotation>
                                <xsd:documentation>The Resource associated with the given Operation. If DeleteAll is FALSE, the caller must provide a valid Resource identifier here.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Role Name or object Id of the role To remove the Capability.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleCapabilityRemoveResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacRoleDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Delete an existing role From the RBAC system</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To delete</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacRoleDisinherit">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Disinherit one or more roles. The Effect is that the affected role will no longer have the Capabilities gained From the disinherited role(s). If DisinheritAll is not specified or is FALSE, then DisinheritedRoleNameOrId must be specified.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="DisinheritAll" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, disinherits all the roles that given RoleNameOrId inherits.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DisinheritedRoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To disinherit From.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An existing role Name or object Id of a role To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleDisinheritResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacRoleInfoList">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the operations, Capabilities and inherited roles that one or more roles have.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="FollowRoleInheritance" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If TRUE, return all roles that given role inherits directly and indirectly. If FALSE or not set, return only roles that are directly inherited by given role.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Role Name or object Id of a role. If not specified, then it gets info on all the roles.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleInfoListResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="RoleAttributes" type="na:ArrayOfRoleAttributesIdentifier">
                            <xsd:annotation>
                                <xsd:documentation>A list of roles and its associated Attributes</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleInherit">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Inherit From a role. The Effect is that the affected role will gain the Capabilities From the inherited role.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="InheritedRoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To inherit From.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleInheritResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="RbacRoleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify an existing role Name and/or its Description.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="RoleDescriptionNew" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The new role Description for the old role, RoleNameOrIdOld.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RoleNameNew" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>The new role Name for the old role, RoleNameOrIdOld.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="RoleNameOrIdOld" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>A role Name or object Id of a role To modify. Either RoleNameNew or RoleDescriptionNew or both must be specified. The object Id of a role cannot be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="RbacRoleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportGraphListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a View list iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportGraphListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportGraphListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To ReportGraphListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportGraphListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="GraphList" type="na:ArrayOfGraphInfo">
                            <xsd:annotation>
                                <xsd:documentation>A list of Graphs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportGraphListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of Graphs for a particular report.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ReportApplication" type="na:ReportApplication">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the application To which the report belongs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ReportNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the report for which Graphs have To be listed. For custom Reports it can either be Name or Id. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="TargetObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the object for which Graphs have To be listed. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportGraphListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with ReportGraphListInfoIterNext. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store. Used in subsequent calls To ReportGraphListInfoIterNext or ReportGraphListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Terminate a View list iteration and clean up any saved info.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns items From a previous call To ReportListInfoIterStart</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [0..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ReportList" type="na:ArrayOfReportInfo">
                            <xsd:annotation>
                                <xsd:documentation>A list of Reports that can be scheduled.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Initiates a Query for a list of Reports that can be scheduled.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ReportApplication" type="na:ReportApplication">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the application for which Reports have To be listed. If not specified then all the Reports are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Name of report To be listed. For custom report Id can be specified. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Type for which Reports have To be listed. Possible Values: 'custom', 'built_in'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with ReportListInfoIterNext. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store. Used in subsequent calls To ReportListInfoIterNext or ReportListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes a report output.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportOutputId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the report output. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportOutputListInfoIterEnd">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportOutputListInfoIterNext">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ReportOutputList" type="na:ArrayOfReportOutputInfo">
                            <xsd:annotation>
                                <xsd:documentation>A list of outputs.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputListInfoIterStart">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsSuccessful" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Specifies whether the Status of the report output was successful. If the input element is not present then all (success and fail) the report outputs are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportApplication" type="na:ReportApplication">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the application for which Reports have To be listed. Default is 'control_center'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the report. For custom Reports it can either be Name or Id. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportOutputId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the report output. If this is specified then filtering based on ObjectNameOrId and ReportScheduleNameOrId is ignored. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Name or Id of the report schedule for which the output has To be listed. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TargetObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies one of the following: - the Name or Id of the Group. - the Name or Id of the object. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with ReportOutputListInfoIterNext. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store. Used in subsequent calls To ReportOutputListInfoIterNext or ReportOutputListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputRead">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Reads report output data From a file. API will fail if Length exceeds 1 MB.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Length">
                            <xsd:annotation>
                                <xsd:documentation>Number of bytes To read From the file. Range: [0..2^20]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="1048576"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Offset">
                            <xsd:annotation>
                                <xsd:documentation>Offset into file To start reading From. Range: [0..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ReportOutputId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the report output. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportOutputReadResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="FileData" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Data read From the file. The data is is xml encoded.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Length">
                            <xsd:annotation>
                                <xsd:documentation>Number of bytes actually read From the file. If this Value is 0, then you have attempted To read at or past the end of the file. Range: [0..2^20]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="1048576"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="OutputFormat" type="na:ReportOutputFormat">
                            <xsd:annotation>
                                <xsd:documentation>The output format of the file read.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleAdd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add a new report schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportScheduleInfo" type="na:ReportScheduleInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of a report schedule</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleAddResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ReportScheduleId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the report schedule created. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes a report schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the report schedule. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportScheduleDisable">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Disable a report schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the report schedule. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleDisableResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportScheduleEnable">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Enable a report schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the report schedule. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleEnableResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportScheduleListInfoIterEnd">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportScheduleListInfoIterNext">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ReportScheduleList" type="na:ArrayOfReportScheduleContentInfo">
                            <xsd:annotation>
                                <xsd:documentation>A list of report schedules.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleListInfoIterStart">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsEnabled" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Specifies whether the state of the report schedule is enabled. If the input element is not present then all (enabled and disabled) the report schedules are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportApplication" type="na:ReportApplication">
                            <xsd:annotation>
                                <xsd:documentation>Specifies To list only those report schedules which involve Reports that belong To this application. Default is 'control_center'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the report. For custom Reports it can either be Name or Id. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Name or Id of the report schedule To be listed. If this is specified then filtering the report schedules based on ReportNameOrId, ReportApplication, TargetObjectNameOrId if any is ignored. If not specified then only the report schedules satisfying all the conditions will be listed. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="TargetObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies one of the following: - the Name or Id of the Group. - the Name or Id of the object. If specified, only the report schedules which have the Target object as that of the input are listed. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number indicating how many items are available for future retrieval with ReportScheduleListInfoIterNext. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An opaque handle used by the DFM station To identify a temporary store. Used in subsequent calls To ReportScheduleListInfoIterNext or ReportScheduleListInfoIterEnd.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a report schedule.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportScheduleInfo" type="na:ReportScheduleInfo">
                            <xsd:annotation>
                                <xsd:documentation>Details of modifiable contents of a report schedule.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Name or Id of the report schedule To be modified. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ReportScheduleRun">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Runs a report schedule at that instant of time.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ReportScheduleNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of the report schedule. Range for Id: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ReportScheduleRunResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ReportOutputId">
                            <xsd:annotation>
                                <xsd:documentation>Specifies the Id of the report output generated. Range: [1..(2^31)-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolAddMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Add member -- storage system or Aggregate -- To an existing Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Resource pool or DFM.Database.Read Privilege on the object being added. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EOBJECTNOTFOUND - When the specified object of valid Type To add is not found or object does not exist at all. &lt;li&gt; EINVALIDMEMBERTYPE - When an Aggregate To add contains traditional Volume or it is Aggregate Snapshot. &lt;li&gt; EOBJECTINANOTHERDYNAMICREFERENCE - When the specified object or its relative Members, are already in another Resource pool/storage set. Try again with move flag To move resources across Resource pools. When used by storage set, you need To manually remove Resource From storage set and add it To Resource pool. &lt;li&gt; EOBJECTINDIRECTMEMOFANOTHERDYNAMICREF - Object being added To Resource pool is in another Resource pool and it's a indirect member of the Resource pool. &lt;li&gt; EOBJECTEXISTSINRESOURCEPOOL - When the specified object already exists in the Resource pool. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous To denote whether its storage system or Aggregate. Try again with fully qualified Name or object Id. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MemberNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the member To add To the Resource pool. Possible Values are name/id of storage system or Aggregate. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MoveIfExists" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If the object To add, or one or more of its contents, is already in a Resource pool, this flag specifies that the object should be removed From the old dynamic reference and added To the Resource pool. By default, the add Operation fails if the object, or one of its contents, is already in a storage set or Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourceTag" type="na:ResourceTag">
                            <xsd:annotation>
                                <xsd:documentation>Resource Tag of the member which is set on the member.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Resource pool To extend. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolAddMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new, empty Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EINVALIDINPUT - When invalid Name specified. A valid Name is non empty and constitutes at least one non-numeric character. &lt;li&gt; ERESOURCEPOOLEXISTS - When the specified Resource pool already exists. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Resourcepool" type="na:WrapperOfResourcepoolInfo">
                            <xsd:annotation>
                                <xsd:documentation>New information about a Resource pool To modify. If any field is not specified, that field will not be changed. &lt;p&gt; Name field should be specified and others are optional. If the optional fields are specified, they would be set during creation itself.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ResourcepoolId" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the new Resource pool. Its a valid DFM object Id. A valid DFM object Id would be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a Resource pool. If the Resource pool is in use by a storage set or Resource pool is not empty, the Resource pool may only be destroyed by specifying the Force flag. If the Resource pool is in use by the storage Service, the Resource pool can be destroyed only after removing it From the storage Service. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Delete Capability on the specified Resource pool. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; ERESOURCEPOOLNOTEMPTY - When the specified Resource pool is not empty. Try again with Force flag. &lt;li&gt; ERESOURCEPOOLINUSE - When the specified Resource pool is in use by a storage set. Try again with Force flag. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If specified, allows destroying a Resource pool that has Members or in use by storage set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of Resource pool To Destroy. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolGetDefaults">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the default Values of Attributes defined by this ZAPI set.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolGetDefaultsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ResourcepoolDefaults" type="na:ResourcepoolDefaults">
                            <xsd:annotation>
                                <xsd:documentation>The default Values of the Attributes defined by this ZAPI.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of Resource pools.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous ResourcepoolListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next Records in the iteration started by ResourcepoolListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To retrieve. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous ResourcepoolListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Value of 0 Records indicates that end of Records. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Resourcepools" type="na:ArrayOfResourcepoolInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Resource pools.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Resource pools. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Read Capability on the specified Resource pools. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool is not found in the database. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="CheckLicenses" type="na:ArrayOfLicense">
                            <xsd:annotation>
                                <xsd:documentation>Filter for licensed services running on Data ONTAP. If this input is present, only resourepools containing atleast one Aggregate hosted on a Filer having these Licenses will have ResourcepoolIsProvisionable flag set To TRUE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DpNodeName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Applicable only if ObjectNameOrId specified is of Type 'Dataset'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeFreeSpace" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If this Value is true, then free space information will be included with each Resource pool. If this Value is false or not specified, then no free space information is included. ResourcepoolSpaceStatus is returned only when IncludeFreeSpace is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a Resource pool or Group or Dataset or storage Service. If unspecified, all Resource pools are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourceTag" type="na:ResourceTag">
                            <xsd:annotation>
                                <xsd:documentation>If this input is present, only the Resource pools having this Tag or containing atleast one member having this Tag will have ResourcepoolIsProvisionable flag set To TRUE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageReliability" type="na:StorageReliability">
                            <xsd:annotation>
                                <xsd:documentation>If this input is present, only the Resourcepools containing atleast one member having the required reliability will have ResourcepoolIsProvisionable flag set To TRUE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items that have been saved for future retrieval with ResourcepoolListInfoIterNext. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To ResourcepoolListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolMemberListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of Resource pools.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous ResourcepoolMemberListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolMemberListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolMemberListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next Records in the iteration started by ResourcepoolMemberListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To retrieve. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous ResourcepoolMemberListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolMemberListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Value of 0 Records indicates that end of Records. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="ResourcepoolMembers" type="na:ArrayOfResourcepoolMemberInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of the Members of the Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolMemberListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Members of specified Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Read Capability on the specified Resource pools. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeDatasetSpaceInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, space utilized by Datasets on each Aggregate is returned. Default Value: false. This is input is ignored when RunProvisioningChecks element is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIndirect" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, indirect Members are included. By default they are not included.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="MemberType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Type of object To be returned. Possible Values are 'Filer' or 'Aggregate'.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisionMemberRequestInfo" type="na:ProvisionMemberRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information of a provisioning Request.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisioningPolicyNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of provisioning Policy, this input ignored if RunProvisioningChecks is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourcepoolMemberNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or Id of Resource pool member.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Resource pool To Query. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RunProvisioningChecks" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, provisioning related checks are run on all the Members of the Resource pool using the provisioning Policy and provisioning Request info specied as part of ProvisioningPolicyNameOrId and provisioning-member-request-info inputs elements.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolMemberListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items that have been saved for future retrieval with ResourcepoolMemberListInfoIterNext. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To ResourcepoolMemberListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a Resource pool's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Resource pool. &lt;li&gt; EINVALIDINPUT - When invalid input specified. A ResourcepoolName should be non empty and constitutes at least one non-numeric character. &lt;br&gt; The ResourcepoolContact Value should be email Address which does not have any white space. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; ERESOURCEPOOLEXISTS - Already a Resource pool exists with the new Name. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Resourcepool" type="na:WrapperOfResourcepoolInfo">
                            <xsd:annotation>
                                <xsd:documentation>New information about a Resource pool To modify. If any field is not specified, that field will not be changed. If none of the optional parameters are specified, then this API does nothing.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Resource pool To modify. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolModifyMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify the Properties of Members of Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Resource pool or DFM.Database.Write Privilege on the object being modified. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EOBJECTNOTFOUND - When the specified object of valid Type To add is not found or object does not exist at all. &lt;li&gt; EINVALIDMEMBERTYPE - When an object is not a mamber of Resourcepool. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous To denote whether its Filer or Aggregate. Try again with fully qualified Name or object Id. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MemberNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the member To modify in the Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ResourceTag" type="na:ResourceTag">
                            <xsd:annotation>
                                <xsd:documentation>Label for the Resource pool member.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Resource pool.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolModifyMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolRemoveMember">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Remove member -- storage system or Aggregate -- From a Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Delete Capability on the specified Resource pool or DFM.Database.Read Privilege on the object being removed. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EOBJECTNOTFOUND - When the specified object To remove not found. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous To denote whether its storage system or Aggregate. Try again with fully qualified Name or object Id. &lt;li&gt; EOBJECTNOTINRESOURCEPOOL - When the specified object does not exist in the Resource pool. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="MemberNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of member To remove From the Resource pool. Possible Values are name/id of storage system or Aggregate. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourcepoolNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Resource pool To modify. It should be a valid DFM object Name or object Id. A valid DFM object Name should contain at least one non-numeric character. A valid DFM object Id should be in the range of [1..2^31-1].</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolRemoveMemberResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="ResourcepoolUpdateFreeSpaceStatus">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Check the free space in the Resource pool against the nearly-full and full Thresholds and generate appropriate Events for the Resource pool.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="ResourcepoolNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of Resource pool</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="ResourcepoolUpdateFreeSpaceStatusResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="SnapshotGetReclaimableInfo">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns the amount of space that would be freed when a set of Snapshot copies are deleted From a specified Volume. This API gets information dynamically From the Filer and is a blocking call.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Snapshots" type="na:ArrayOfSnapshot">
                            <xsd:annotation>
                                <xsd:documentation>List of Snapshot copies. A Maximum of 255 Snapshot copies can be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VolumeNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Volume on which the reclaimable space has To be computed by deleting the specified set of Snapshot copies.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="SnapshotGetReclaimableInfoResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="ReclaimableSize">
                            <xsd:annotation>
                                <xsd:documentation>Size in bytes of space reclaimable if the specified set of Snapshot copies were deleted. Range : [0..2^63-1].</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="9223372036854775807"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="SnapshotSharedData">
                            <xsd:annotation>
                                <xsd:documentation>Total number of bytes shared between active file system and Snapshots after the given Snapshots are deleted. Range: [0..2^63-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="0"/>
                                    <xsd:maxInclusive value="9223372036854775807"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="SnapshotListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of Snapshot copies.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous SnapshotListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="SnapshotListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="SnapshotListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieve the next Records in the iteration started by SnapshotListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of Records To retrieve. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous SnapshotListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="SnapshotListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Value of 0 Records indicates end of Records. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Snapshots" type="na:ArrayOfSnapshotInfo"/>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="SnapshotListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Returns information on a list of Snapshot copies.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IncludeBackupInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true and Snapshot is part of a Dataset backup Version, the backup Version information which contains this Snapshot as member is returned. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the object whose Snapshot copies are To be listed. Valid types of Objects are: &lt;ul&gt; &lt;li&gt; Volume - Lists Snapshot copies of this Volume &lt;li&gt; Aggregate - Lists Snapshot copies of all Volumes in the Aggregate &lt;li&gt; Filer - Lists all Snapshot copies of all Volumes on this Filer. &lt;li&gt; vFiler - Lists all Snapshot copies for Volumes exclusively belonging To this vFiler. &lt;li&gt; Vserver - Lists all Snapshot copies for Volumes exclusively belonging To this Vserver. &lt;li&gt; Dataset - Lists all Snapshot copies of all Volumes that are Members of all nodes of the Dataset. &lt;li&gt; storage set - Lists all Snapshot copies of all Volumes that are Members of the storage set. &lt;li&gt; Resource Group - Lists all Snapshot copies of all Volumes that are direct or indirect Members of the Resource Group. &lt;/ul&gt; If this input is not specified, then the ZAPI lists all Snapshot copies known To DataFabric Manager server.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="SnapshotListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number of items that have been saved for future retrieval with SnapshotListInfoIterNext. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To SnapshotListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new storage Service.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Resource Group To which the newly created storage Service will be added To. User should have DFM.Service.Write Capability on the specified Group. Default Value: Global Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProtectionPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the protection Policy To associate with this storage Service. The data protection License is required for this input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceContact" type="na:EmailAddressList">
                            <xsd:annotation>
                                <xsd:documentation>Contact for the storage Service, such as the owner's e-mail Address.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the new storage Service, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServiceName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new storage Service. It cannot be all numeric. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServiceNodeList" type="na:ArrayOfStorageServiceNodeAttributes">
                            <xsd:annotation>
                                <xsd:documentation>Attributes of the Policy nodes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceOwner" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the owner of the storage Service, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="StorageServiceId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the new storage Service</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetListIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list of Datasets associated with a storage Service.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous StorageServiceDatasetListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetListIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetListIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by storage-service-dataset-list-info-iter-start.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous StorageServiceDatasetListIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetListIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServiceDatasetsInfo" type="na:ArrayOfStorageServiceDatasetInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information about a Dataset and its association with a storage Service.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetListIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Lists the association of Datasets with storage services. If no service/dataset Name or Id is provided then all Datasets with no storage Service are listed.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the storage Service, Resource Group or Dataset. If a Resource Group is provided, storage services and Datasets associated with them are returned. If this input is not provided then all Datasets with no storage Service are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetListIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records that have been saved for future retrieval with StorageServiceDatasetListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To StorageServiceDatasetListIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Attach or detach a storage Service To a Dataset.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AssumeConfirmation" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Value determining whether confirmation is given for all resolvable conformance actions that require user confirmation. If the Value is true, all conformance actions which require user confirmation will be executed as if confirmation is already granted. If the Value is false, all conformance actions which require user confirmation will not be executed. One Key, and sometimes undesirable, resolvable Action that requires user confirmation is the possible re-baseline of a relationship. By default, AssumeConfirmation is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Dataset object</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the DryRunResults list as well as the ConformanceAlerts list. The DryRunResults list contains actions that would be taken should the changes be committed without actually committing the changes. The ConformanceAlerts list contains high level alerts To notify a user of conditions that will impact any attempt To commit the changes. A conformance alert may warn that if the changes are committed, one or more rebaseline operations may be done. The conformance alerts may also warn of conditions that exist that may prevent the successful conformance of services. By default, DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDryRunReasonDetails" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true or omitted, then include any possible &lt;b&gt;DryRunReasonDetails&lt;/b&gt; along with the associated &lt;b&gt;DryRunResult&lt;/b&gt; element. Default Value is true. If false, the &lt;b&gt;DryRunReasonDetails&lt;/b&gt; will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="OperationType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Possible Values, "attach" or "detach".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the storage Service object. It is not required for 'detach' Operation</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceNodeList" type="na:ArrayOfStorageServiceNodeAttributes">
                            <xsd:annotation>
                                <xsd:documentation>Information about dp Policy node mapping. This input is considered only for 'attach' Operation To specify the node mapping. Specify only DpNodeName and OldDpNodeName. All other elements of this input will be ignored, if specified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetModifyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ConformanceAlerts" type="na:ArrayOfConformanceAlert">
                            <xsd:annotation>
                                <xsd:documentation>Alerts that apply To the conformance check. Each alert describes one Type of Condition that a user should be aware of before attempting To conform any more services. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetProvision">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a Dataset with the specified storage Service</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ApplicationInfo" type="na:ApplicationInfo">
                            <xsd:annotation>
                                <xsd:documentation>If IsApplicationData is true, then this element will contain information about the application which manages this Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="AssumeConfirmation" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Value determining whether confirmation is given for all resolvable conformance actions that require user confirmation. If the Value is true, all conformance actions which require user confirmation will be executed as if confirmation is already granted. If the Value is false, all conformance actions which require user confirmation will not be executed. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetContact" type="na:EmailAddressList">
                            <xsd:annotation>
                                <xsd:documentation>Contact for the Dataset, such as the owner's e-mail Address.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the new Dataset, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetMetadata" type="na:ArrayOfDfmMetadataField">
                            <xsd:annotation>
                                <xsd:documentation>Opaque metadata for Dataset. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new Dataset. It cannot be all numeric. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DatasetOwner" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the owner of the Dataset, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the DryRunResults list as well as the ConformanceAlerts list. The DryRunResults list contains actions that would be taken should the changes be committed without actually committing the changes. The ConformanceAlerts list contains high level alerts To notify a user of conditions that will impact any attempt To commit the changes. A conformance alert may warn that if the changes are committed, one or more rebaseline operations may be done. The conformance alerts may also warn of conditions that exist that may prevent the successful conformance of services. By default, AssumeConfirmation is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="GroupNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Resource Group To which the newly created Dataset should be added To. User should have DFM.Dataset.Write Capability on the specified Group. Default Value: Global Group.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDryRunReasonDetails" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true or omitted, then include any possible &lt;b&gt;DryRunReasonDetails&lt;/b&gt; along with the associated &lt;b&gt;DryRunResult&lt;/b&gt; element. Default Value is true. If false, the &lt;b&gt;DryRunReasonDetails&lt;/b&gt; will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsApplicationData" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the Dataset is an application Dataset managed by an external application. &lt;P&gt;Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSuspended" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To suspend this Dataset for all automated actions (data protection and conformance check of the Dataset). &lt;P&gt;Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="OnlineMigration" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates, that the migration cutover has To be non-disrputive. By default the migration will be assumed To be disruptive. This applies only To the vFiler Unit To be created or attached To the primary node of the Dataset. If provided in input, either DatasetAccessDetails or ServerNameOrId should be provided in StorageSetInfo for the primary node.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProvisionMember" type="na:WrapperOfProvisionMemberRequestInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information of the provisioning Request for the member</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RequiresNonDisruptiveRestore" type="na:RequiresNonDisruptiveRestore">
                            <xsd:annotation>
                                <xsd:documentation>Specifies whether the Dataset should be configured To enable non-disruptive restores From backup destinations. &lt;P&gt;Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServiceNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of a storage Service object.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageSetDetails" type="na:ArrayOfStorageSetInfo">
                            <xsd:annotation>
                                <xsd:documentation>Configuration details for each storage set.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeQtreeNamePrefix" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Prefix for Volume and Qtree names, up To 60 characters long. The allowed characters are a To z A To Z 0 To 9 ' ' (space) . (Period) _ (underscore) - (hyphen) If any other characters are included, an Error is returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDatasetProvisionResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ConformanceAlerts" type="na:ArrayOfConformanceAlert">
                            <xsd:annotation>
                                <xsd:documentation>Alerts that apply To the conformance check. Each alert describes one Type of Condition that a user should be aware of. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="DatasetId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly provisioned Dataset.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a storage Service. In order To Destroy storage Service containing Datasets, Force Option must be supplied.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="Force" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, allows destroying a storage Service that is attached To Datasets. By default, only storage services that are not associated with any Datasets can be destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServiceNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the storage Service To Destroy.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="StorageServiceListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list storage services.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous StorageServiceListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="StorageServiceListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by StorageServiceListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous StorageServiceListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServices" type="na:ArrayOfStorageServiceInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of storage services.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list storage services.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of a storage Service or Resource Group. If a Resource Group is given, only the storage services which are direct Members of the Group are returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number of Records that have been saved for future retrieval with StorageServiceListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To StorageServiceListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify Attributes for a storage Service</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AssumeConfirmation" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Value determining whether confirmation is given for all resolvable conformance actions that require user confirmation. If the Value is true, all conformance actions which require user confirmation will be executed as if confirmation is already granted. If the Value is false, all conformance actions which require user confirmation will not be executed. One Key, and sometimes undesirable, resolvable Action that requires user confirmation is the possible re-baseline of a relationship. By default, AssumeConfirmation is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return the DryRunResults list as well as the ConformanceAlerts list. The DryRunResults list contains actions that would be taken should the changes be committed without actually committing the changes. The ConformanceAlerts list contains high level alerts To notify a user of conditions that will impact any attempt To commit the changes. A conformance alert may warn that if the changes are committed, one or more rebaseline operations may be done. The conformance alerts may also warn of conditions that exist that may prevent the successful conformance of services. By default, DryRun is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeDryRunReasonDetails" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true or omitted, then include any possible &lt;b&gt;DryRunReasonDetails&lt;/b&gt; along with the associated &lt;b&gt;DryRunResult&lt;/b&gt; element. Default Value is true. If false, the &lt;b&gt;DryRunReasonDetails&lt;/b&gt; will not be returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ProtectionPolicyNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the protection Policy To associate with this storage Service. The data protection License is required for this input.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceContact" type="na:EmailAddressList">
                            <xsd:annotation>
                                <xsd:documentation>Contact for the storage Service, such as the owner's e-mail Address.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceDescription" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Description of the storage Service, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="StorageServiceName" type="na:ObjName"/>
                        <xsd:element name="StorageServiceNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or object identifier of a storage Service object.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceNodeList" type="na:ArrayOfStorageServiceNodeAttributes">
                            <xsd:annotation>
                                <xsd:documentation>Information about dp Policy nodes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="StorageServiceOwner" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of the owner of the storage Service, up To 255 characters long.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="StorageServiceModifyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="ConformanceAlerts" type="na:ArrayOfConformanceAlert">
                            <xsd:annotation>
                                <xsd:documentation>Alerts that apply To the conformance check. Each alert describes one Type of Condition that a user should be aware of before attempting To conform any more services. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                            <xsd:annotation>
                                <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneGetDefaults">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Retrieves the default time zone settings, including the time zone in which the server runs and the time zone To use for Objects that don't specify their own time zone.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneGetDefaultsResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="TimezoneDefaults" type="na:TimezoneDefaults">
                            <xsd:annotation>
                                <xsd:documentation>The default time zone settings.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list time zones.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous TimezoneListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="TimezoneListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get the next few Records in the iteration started by TimezoneListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous TimezoneListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Timezones" type="na:ArrayOfTimezoneInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of time zones From the built-in zoneinfo database.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list time zones From the internal database of time zone information.</xsd:documentation>
                    </xsd:annotation>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with TimezoneListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To TimezoneListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneValidate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Determines if a time zone specification is valid. The specification may be the Name of Timezone returned From TimezoneListInfoIterNext(), or can be a POSIX-style time zone specification.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Timezone" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Proposed time zone string.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="TimezoneValidateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="UtcOffset" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Current Offset, in seconds, between this time zone and UTC. Range: -43200 To 50400. Negative Values are west of UTC; positive Values are east of UTC.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserFavoriteReportDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes favorite Reports of a user or all users.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="UserName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of user whose favorite Reports are To be deleted. If not specified then favorite Reports of all users will be deleted. Domain name\user Name is required for windows.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserFavoriteReportDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="UserFavoriteReportListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The UserFavoriteReportListInfoIter* set of APIs are used To retrieve the list of user favorite counts. UserFavoriteReportListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the UserFavoriteReportListInfoIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserFavoriteReportListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="UserFavoriteReportListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check UserFavoriteReportListInfoIterStart. The UserFavoriteReportListInfoIterNext API is used To iterate over the Members of user favorite report counts stored in the temporary store created by the UserFavoriteReportListInfoIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous UserFavoriteReportListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by UserFavoriteReportListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserFavoriteReportListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Favorites" type="na:ArrayOfUserReportInfo">
                            <xsd:annotation>
                                <xsd:documentation>Number of favorite Reports per user.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserFavoriteReportListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The UserFavoriteReportListInfoIter* set of APIs are used To retrieve the number of favorite Reports of specified user or all users. It loads the list of user favorite report counts into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. If UserFavoriteReportListInfoIterStart is invoked twice, then two distinct temporary stores are created.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="UserName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of user. User can be a dfm or non-dfm user. If not specified then all users. Domain name\user Name is required for windows.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserFavoriteReportListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with UserFavoriteReportListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To UserFavoriteReportListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserRecentReportDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes recently viewed Reports of a user or all users.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="UserName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of user whose recenlty viewed Reports are To be deleted. If not specified then recently viewed Reports of all users will be deleted. Domain name\user Name is required for windows.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserRecentReportDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="UserRecentReportListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The UserRecentReportListInfoIter* set of APIs are used To retrieve the list of user's recently viewed report counts. UserRecentReportListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the UserRecentReportListInfoIterNext API for the particular Tag is no longer necessary.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserRecentReportListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="UserRecentReportListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>For more documentation please check UserRecentReportListInfoIterStart. The UserRecentReportListInfoIterNext API is used To iterate over the Members of user's recently viewed report counts stored in the temporary store created by the UserRecentReportListInfoIterStart API.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous UserRecentReportListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by UserRecentReportListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserRecentReportListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="RecentViewed" type="na:ArrayOfUserReportInfo">
                            <xsd:annotation>
                                <xsd:documentation>Number of recently viewed Reports per user.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserRecentReportListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>The UserRecentReportListInfoIter* set of APIs are used To retrieve the number of recently viewed report Count of specified user or all users. It loads the list of user's recently viewed report counts into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. If UserRecentReportListInfoIterStart is invoked twice, then two distinct temporary stores are created.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="UserName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of user. User can be a dfm or non-dfm user. If not specified then all users. Domain name\user Name is required for windows.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="UserRecentReportListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with UserRecentReportListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To UserRecentReportListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Create a new vFiler on a storage system. A vFiler can be created by either: &lt;UL&gt; &lt;LI&gt; Specifying the Filer on which To create it. &lt;LI&gt; Speciying a Resource pool. In this case, a Filer is selected From the Resource pool based on required Licenses and in-built Resource selection algorithm To evenly balance space and load in the Resource pool and a vFiler will be created on the selected Filer. &lt;/UL&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To create a vFiler. &lt;li&gt; EOBJECTNOTFOUND - When the specified ResourceNameOrId Id not found. &lt;li&gt; EFILERNOTFOUND - No storage system could be found on which a vFiler could be created. &lt;li&gt; EINVALIDINPUT - Invalid input provided for certain fields. &lt;li&gt; EINVALIDMEMBERTYPE - when the Filer is in c-mode. &lt;li&gt; EMULTISTORENOTLICENSED - When ResourceNameOrId corresponds To a Filer that does not have multistore licensed. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AllowedProtocols" type="na:ArrayOfProtocol">
                            <xsd:annotation>
                                <xsd:documentation>List of protocols that needs To be allowed access To the vFiler. If not specfied, none of the protocols will be allowed on the vFiler.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="DryRun" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Check if a vFiler can be created on the given ResourceNameOrId. The hosting Filer on which the vFiler is created will be returned. If there are any Errors, because of which a vFiler cannot be created on the given ResourceNameOrId, the API will throw an Error. No changes are made To the ResourceNameOrId when DryRun is true. Default Value is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IpAddress" type="na:IpAddress">
                            <xsd:annotation>
                                <xsd:documentation>IP Address of the new vFiler. This element is not required only when the API is run in DryRun mode.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="Ipspace" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>IP Space of the new vFiler. Only alphabets, number, hyphens and underscore characters are allowed. It can be a Maximum of 64 characters. If not specified, vFiler is created in "default-ipspace".</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Name" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new vFiler To be created. Only alphabets, number, hyphens and underscore characters are allowed. It can be a Maximum of 64 characters.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="ResourceNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the hosting Filer or Resource pool From which To provision a new vFiler.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="FilerId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of hosting Filer on which the vFiler was or will be created in DryRun mode.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="FilerName" type="na:ObjFullName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the hosting Filer on which the vFiler was or will be created in DryRun mode.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RootVolumeId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the root Volume created for this vFiler Unit. This is not returned when the API is run in DryRun mode.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RootVolumeName" type="na:ObjFullName">
                            <xsd:annotation>
                                <xsd:documentation>Full Name of the root Volume created for this vFiler Unit. This is not returned when the API is run in DryRun mode.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VfilerId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of new vFiler created in DFM database. This is not returned when the API is run in DryRun mode.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerDestroy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Destroy a Vfiler. This API stops and then destroys the vFiler on the hosting Filer and marks the vFiler as deleted in DFM. Storage resources owned by the vFiler are not destroyed. They will be owned by the hosting Filer after the vFiler is destroyed. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To Destroy the vFiler. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler is not found. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="VfilerNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name of identifier of the vFiler To be destroyed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerDestroyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="VfilerSetup">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Configure and setup a vFiler based on a specified vFiler template. Depending on the input a CIFS setup will also be done on the vFiler. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To setup the vFiler. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler is not found. &lt;li&gt; EINVALIDINPUT - Invalid input provided. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="AllowedProtocols" type="na:ArrayOfProtocol">
                            <xsd:annotation>
                                <xsd:documentation>List of protocols that needs To be allowed access To the vFiler. This list overrides the list of protocols currently allowed on the vFiler. If this is not present, no changes are done To the allowed protocols of the vFiler.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CifsDomainPassword" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Password for CifsDomainUser. Encrypted using 2-way encryption. &lt;br&gt; Applicable and mandatory if CifsAuthType is set To "active_directory" in Vfiler template specified in VfilerTemplateNameOrId. Default Value is empty.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CifsDomainUser" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of CIFS domain user that has the ability To add the CIFS server To the domain given in CifsDomainName in Vfiler template specified in VfilerTemplateNameOrId. Examples: Username (assumes domain-name is the user's domain), cifsdomain\username, cifs.domain.com\username. Applicable and mandatory if CifsAuthType is set To "active_directory" in Vfiler template specified in VfilerTemplateNameOrId. Default Value is empty.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="CifsWorkgroupName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>CIFS workgroup Name of the new Vfiler. If VfilerTemplateNameOrId is specified, this field is applicable only if CifsAuthType is "workgroup" in the specified VfilerTemplate. This field is also applicable when VfilerTemplateNameOrId is not given, but cifs setup needs To be done on the vFiler. Default Value is "WORKGROUP" and this will be used during CIFS setup of the vFiler if RunCifsSetup is true.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IpBindings" type="na:ArrayOfIpBindingInfo">
                            <xsd:annotation>
                                <xsd:documentation>IP Address To Interface binding information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RootPassword" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Root Password of the new vFiler. This will be the Password for a new root account that will be created on the vFiler. If a root account already exists on this vFiler, then the Password for the root account will not be changed. Encrypted using 2-way encryption. &lt;br&gt; Length: [0..64] Default Value is empty. Ignored if IpBindings element is not present.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RunCifsSetup" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>Indicates whether CIFS setup should be performed on the vFiler Unit. Note that if this is true and CIFS is already running on the vFiler Unit, CIFS Service will be stopped, and then a setup will be performed. Default Value is FALSE.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ScriptPath" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Path To a script that will be run in pre setup and post setup mode when setting up the vFiler Unit.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VfilerNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Full Name or identifier of the vFiler To be setup.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VfilerTemplateNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of vFiler template. The vFiler is setup based on the settings specified in the template. If this is not specified, then DNS, NIS servers cannot be configured for the vFiler. Also, a CIFS setup cannot be done using active_directory. Ignored if IpBindings element is not present and RunCifsSetup is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerSetupResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="VfilerTemplateCopy">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a new vFiler template by copying all settings From an existing vFiler template. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have privileges To create the Vfiler template. &lt;LI&gt; EVFILERTEMPLATEEXISTS - A vFiler template already exists with this Name. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler template does not exist. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="VfilerTemplateName" type="na:ObjName">
                            <xsd:annotation>
                                <xsd:documentation>Name of the new vFiler template To be created.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VfilerTemplateNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>The Name or identifier of an existing vFiler template that is copied To create a new vFiler template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateCopyResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="VfilerTemplateId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly created vFiler template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateCreate">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Creates a vFiler template. A vFiler template contains configuration information that is used during vFiler setup. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have privileges To create the vFiler template. &lt;LI&gt; EVFILERTEMPLATEEXISTS - A vFiler template already exists with this Name. &lt;LI&gt; EINVALIDINPUT - Input validation failed. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="VfilerTemplate" type="na:WrapperOfVfilerTemplateInfo">
                            <xsd:annotation>
                                <xsd:documentation>vFiler template information.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateCreateResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="VfilerTemplateId" type="na:ObjId">
                            <xsd:annotation>
                                <xsd:documentation>Identifier of the newly created vFiler template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateDelete">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Deletes the vFiler template. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have Capabilities To delete the vFiler template. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler template does not exist. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="VfilerTemplateNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the vFiler template.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateDeleteResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="VfilerTemplateListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration of vFiler templates.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>An internal opaque handle used by the DFM station.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="VfilerTemplateListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next Records in the iteration started by VfilerTemplateListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous VfilerTemplateListInfoIterStart. It's an opaque handle used by the DFM station To identify the temporary store created by VfilerTemplateListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VfilerTemplates" type="na:ArrayOfVfilerTemplateInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of vFiler templates.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Lists vFiler templates. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To list vFiler templates. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler template does not exist. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="VfilerTemplateNameOrId" type="na:ObjNameOrId">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the vFiler template. If not specified, it lists all vFiler templates.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many Vfiler templates are present for future retrieval with VfilerTemplateListInfoIterNext. Range: [1..2^31-1]</xsd:documentation>
                            </xsd:annotation>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:integer">
                                    <xsd:minInclusive value="1"/>
                                    <xsd:maxInclusive value="2147483647"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To VfilerTemplateListInfoIterNext. It is an opaque handle used by the DFM station To identify a temporary store.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modifies the settings in a vFiler template. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have capabilties To create the vFiler template. &lt;LI&gt; EVFILERTEMPLATEEXISTS - A vFiler template already exists with this Name. &lt;LI&gt; EINVALIDINPUT - Input validation failed. &lt;/UL&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="VfilerTemplate" type="na:WrapperOfVfilerTemplateInfo">
                            <xsd:annotation>
                                <xsd:documentation>Information of the vFiler template To be modified.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VfilerTemplateModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="VolumeListInfoIterEnd">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Ends iteration To list Volumes.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous VolumeListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VolumeListInfoIterEndResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:element name="VolumeListInfoIterNext">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Get next few Records in the iteration started by VolumeListInfoIterStart.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element name="Maximum" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The Maximum number of entries To retrieve.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag From a previous VolumeListInfoIterStart.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VolumeListInfoIterNextResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>The number of Records actually returned.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Volumes" type="na:ArrayOfVolumeInfo">
                            <xsd:annotation>
                                <xsd:documentation>List of Volumes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VolumeListInfoIterStart">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Starts iteration To list Volumes.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="BlockType" type="na:FileSystemBlockType">
                            <xsd:annotation>
                                <xsd:documentation>Filter by file system block Type of the Volume. If no BlockType input is supplied, all types of Volumes will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeIsAvailable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, the IsAvailable Status is calculated for each Volume which may make the call To this zapi take much longer. Default is false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeMigrationInfo" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, IsCapableOfMigration information for each Volume is returned in VolumeListInfoIterNext. Default Value: false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IncludeNextScheduledBackupTime" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, return NextScheduledBackupTime for each Volume in VolumeListInfoIterNext. Default Value: false</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDirectMemberOnly" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only return the Volumes that are direct Members of the specified Resource Group. Default Value is false. This field is meaningful only if a Resource Group Name or Id is given for the ObjectNameOrId field.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Volumes that have been set To be ignored for purposes of data protection. If false, only list Volumes that have not been set To be ignored for purposes of data protection. If not specified, list all Volumes without taking into account whether they have been ignored or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsInDataset" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Volumes which only contain data which is protected by a Dataset. If false, only list Volumes containing data which is not protected by a Dataset. If not specified, list all Volumes whether they are in a Dataset or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSisVolume" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Single Instance Storage (SIS) Volumes. A SIS Volume is a flexible Volume that contains shared blocks. It has the ability To have multiple references To the same data block. Each block has a block reference Count stored in the Volume metadata. As additional indirect blocks point To it or existing ones stop pointing To it, this Value is incremented or decremented accordingly. If false, only list Volumes which are not SIS Volumes. If not specified, list all Volumes whether they are SIS Volumes or not.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSnapmirrorPrimaryCapable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list Volumes capable of being a primary for a SnapMirror relationship. This means the storage system is licensed for SnapMirror. Meaningless if present and false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSnapmirrorSecondaryCapable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list Volumes capable of being a secondary for a SnapMirror relationship. This means the storage system is licensed for SnapMirror and the Volume is not already a SnapMirror or SnapVault secondary. Meaningless if present and false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSnapvaultPrimaryCapable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list Volumes capable of being the Source of a SnapVault transfer. This means the storage system is licensed To be a SnapVault primary. Meaningless if present and false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsSnapvaultSecondaryCapable" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If present and true, only list Volumes capable of being the destination of SnapVault transfers. This means the storage system is licensed as a SnapVault secondary and the Volume is not a SnapMirror destination. Meaningless if present and false.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="IsUnprotected" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>If true, only list Volumes that are not protected, which means they are not in any SnapMirror or SnapVault relationship. If false or not set, list all Volumes.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectManagementFilter" type="na:ObjectManagementInterface">
                            <xsd:annotation>
                                <xsd:documentation>Filter the object based on the Data ONTAP Interface that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. If no filter is supplied, all Objects will be considered.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="ObjectNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of an object To list Volumes for. The allowed object types for this argument are: &lt;ul&gt; &lt;li&gt; Resource Group &lt;li&gt; Dataset &lt;li&gt; Storage Set &lt;li&gt; Host &lt;li&gt; Aggregate &lt;li&gt; Volume &lt;li&gt; Qtree &lt;/ul&gt; If ObjectNameOrId identifies a Volume, that single Volume will be returned. If ObjectNameOrId resolves To more than one Volume, all of them will be returned. If no ObjectNameOrId is provided, all Volumes will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="RbacOperation" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Names of an RBAC Operation. If specified, only return Volumes for which the current admin has Permission To perform that Operation. For example, caller can ask for only Volumes that current admin has DFM.Backupmanager.Backup Operation Privilege To when want To display list of Volume that can be backup by the current admin. When not specified, DFM.Database.Read is a default Operation requirement.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="SnapvaultSecondaryScheduleName" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name of a SnapVault backup schedule. If specified, SnapVault secondary Volumes that are using the specified backup schedule are listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element minOccurs="0" name="VolumeType" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Filter by Type of Volume. Possible Values are: &lt;ul&gt; &lt;li&gt; traditional &lt;li&gt; flexible &lt;li&gt; striped &lt;/ul&gt; If no VolumeType input is supplied, all types of Volumes will be listed.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VolumeListInfoIterStartResult">
                <xsd:complexType>
                    <xsd:all>
                        <xsd:element name="Records" type="xsd:integer">
                            <xsd:annotation>
                                <xsd:documentation>Number which tells you how many items have been saved for future retrieval with VolumeListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="Tag" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Tag To be used in subsequent calls To VolumeListInfoIterNext.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VolumeModify">
                <xsd:complexType>
                    <xsd:annotation>
                        <xsd:documentation>Modify a Volume's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Volume. &lt;li&gt; EINVALIDINPUT - When invalid input specified. &lt;li&gt; EOBJECTNOTFOUND - When the VolumeNameOrId does not correspond To a Volume. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</xsd:documentation>
                    </xsd:annotation>
                    <xsd:all>
                        <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                            <xsd:annotation>
                                <xsd:documentation>True if an administrator has chosen To ignore this object for purposes of data protection.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="VolumeNameOrId" type="xsd:string">
                            <xsd:annotation>
                                <xsd:documentation>Name or identifier of the Volume To modify.</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:all>
                </xsd:complexType>
            </xsd:element>
            <xsd:element name="VolumeModifyResult">
                <xsd:complexType/>
            </xsd:element>
            <xsd:complexType name="AggregateInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Aggregate.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AggregateFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate an "Aggregate full" event for this Aggregate. If the Value is empty, then the global setting for Aggregate full threshold is considered and this can be obtained From DfmGetOption API with OptionName as "aggregateFullThreshold". Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="AggregateId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Aggregate. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="AggregateName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Simple Name of the Aggregate. Always present in the output. The Name is any simple Name such as myaggr.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateNearlyFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate an "Aggregate nearly full" event for this Aggregate. If the Value is empty, then the global setting for Aggregate nearly full threshold is considered and this can be obtained From DfmGetOption API with OptionName as "aggregateNearlyFullThreshold". Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="AggregateNearlyOvercommittedThreshold" type="xsd:unsignedShort">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) is used To generate "Aggregate nearly overcommitted" event for this Aggregate. If the Value is empty, then the global setting for Aggregate nearly over committed threshold is considered and this can be obtained From DfmGetOption API with OptionName as "aggregateNearlyOverCommittedThreshold". Range: [0..65535]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateOvercommittedThreshold" type="xsd:unsignedShort">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) is used To generate "Aggregate overcommitted" event for this Aggregate. If the Value is empty, then the global setting for Aggregate over committed threshold is considered and this can be obtained From DfmGetOption API with OptionName as "aggregateOverCommittedThreshold". Range: [0..65535]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AggregatePerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Aggregate based on performance Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateSize" type="na:AggregateSize">
                        <xsd:annotation>
                            <xsd:documentation>Sizes of various parameters of the Aggregate.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateSpaceStatus" type="na:ObjectSpaceStatus">
                        <xsd:annotation>
                            <xsd:documentation>Space Status of the Aggregate. This indicates the fullness of the Aggregate in terms of whether the percentage of used space with respect To Total Size of the Aggregate has reached or crossed the fullness Thresholds given in AggregateNearlyFullThreshold and AggregateFullThreshold.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AggregateStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Aggregate based on all Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of Aggregate. Possible Values are: &lt;ul&gt; &lt;li&gt; traditional &lt;li&gt; Aggregate &lt;li&gt; striped &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BlockType" type="na:FileSystemBlockType">
                        <xsd:annotation>
                            <xsd:documentation>File system block Type of the Aggregate. The Volumes on both the Source and destination sides of a SnapMirror relationship must be of the same block Type.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Datasets" type="na:ArrayOfDatasetReference">
                        <xsd:annotation>
                            <xsd:documentation>List of Dataset IDs and names containing this Volume. If IsInDataset is false, this list will be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetsSpaceInfo" type="na:ArrayOfDatasetSpaceInfo">
                        <xsd:annotation>
                            <xsd:documentation>Space used by each Dataset in the Aggregate. Returned only when IncludeDatasetSpaceInfo is set To true in AggregateListInfoIterStart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FilerId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of controller when AggregateType is traditional or Aggregate. Identifier of cluster when AggregateType is striped. Always present in the output. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="FilerName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of controller when AggregateType is traditional or Aggregate. Name of cluster when AggregateType is striped. Always present in the output. The Name is any simple Name such as myhost.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this object and all of it's parents are up or online. Only output if the call To iter-start included the "IncludeIsAvailable" flag.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an admin wants To ignore this Aggregate for purposes of data protection.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True indicates if this Aggregate is a member of any Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool of which the Aggregate is a member. This element will not be present if the Aggregate is not a member of a Resource pool.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TimeToFull">
                        <xsd:annotation>
                            <xsd:documentation>Estimated amount of time left in seconds for the Aggregate To become full. This is returned as empty when the estimated amount of time is more than a year. This can happen due To very low or negative rate of consumption of space in the Aggregate. Range: [0..31536000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="31536000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="AggregateSize">
                <xsd:annotation>
                    <xsd:documentation>Sizes of various parameters of an Aggregate.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="SizeAvailable">
                        <xsd:annotation>
                            <xsd:documentation>Available bytes in the Aggregate. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SizeTotal">
                        <xsd:annotation>
                            <xsd:documentation>Aggregate Total Size in bytes. Range : [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SizeUsed">
                        <xsd:annotation>
                            <xsd:documentation>Aggregate bytes used. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceTotalCommitted">
                        <xsd:annotation>
                            <xsd:documentation>Total space committed in bytes. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="AggregateSpaceInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about space charecteristics of an Aggregate.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AggregateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Aggregate identifier</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Aggregate Name</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CommittedSpace">
                        <xsd:annotation>
                            <xsd:documentation>Information about committed space of an Aggregate in bytes. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="UsedSpace">
                        <xsd:annotation>
                            <xsd:documentation>Information about used space of an Aggregate in bytes. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="BackupDeletionRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of backup To be deleted.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BackupIds" type="na:ArrayOfBackupId">
                        <xsd:annotation>
                            <xsd:documentation>List of Backups To be deleted on a Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="BackupId">
                <xsd:annotation>
                    <xsd:documentation>Identifier of the backup Instance To be deleted. Range: [1..2^31-1]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:simpleType name="CleanupStaleStorage">
                <xsd:annotation>
                    <xsd:documentation>Indicates when the Volumes in the Source Aggregate should be destroyed after successful migration. Possible Values are: &lt;ul&gt; &lt;li&gt; cleanup_after_update &lt;li&gt; cleanup_after_migration &lt;li&gt; no_cleanup &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DedupeRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Deduplication Request details</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FullVolumeDedupe" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, full Volume dedupe scan is performed. Otherwise only new data since last deduplication Operation is scanned. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ObjectManagementInterface">
                <xsd:annotation>
                    <xsd:documentation>Specify the management Interface of ONTAP that provides complete management for the object i.e. ONTAP CLIs, SNMP, ONTAPI etc. Possible Values are: &lt;ul&gt; &lt;li&gt; "node" - For Objects manageable by node management Interface &lt;li&gt; "cluster" - For Objects manageable by cluster management Interface &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ResizeVolumeRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of the resize Request. Atleast one of NewSize, MaximumCapacity or SnapReserve needs To be specified.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="MaximumCapacity">
                        <xsd:annotation>
                            <xsd:documentation>Specify the new Maximum capacity Value for a flexbile Volume. The Value is specified in bytes. Valid only if the storage syste, To which the Volume belongs is of ONTAP Version 7.1 or above only and if autosize is enabled on the Volume. Range: [1..2^44-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="17592186044415"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NewSize">
                        <xsd:annotation>
                            <xsd:documentation>Specify the new Size of the Volume. The Value is specified in bytes. Range: [1..2^44-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="17592186044415"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapReserve">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the percetage of space set aside for Snapshots in a Volume. The Value is specified in percentage of the Total Size of the Volume. Range: [0..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="SnapshotDeletionRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of Snapshot deletion Request</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Snapshots" type="na:ArrayOfSnapshot">
                        <xsd:annotation>
                            <xsd:documentation>List of Snapshot copies To be deleted From the Volume. A minimum of 1 and a Maximum of 255 Snapshot copies can be listed for deletion.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="SpaceManagementOpType">
                <xsd:annotation>
                    <xsd:documentation>Type of space management Operation Possible Values: &lt;ul&gt; &lt;li&gt; resize_volume &lt;li&gt; delete_snapshot &lt;li&gt; delete_backup &lt;li&gt; migrate_volume &lt;li&gt; dedupe_volume &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="SpaceManagementOperationInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of a space management Operation. Only one of the Request info in SpaceManagementOperationInfo should be sent in input.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupDeletionRequestInfo" type="na:BackupDeletionRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Details of Backups To be deleted as part of this space management Operation. The Backups To be deleted should be on a Volume in the Aggregate on which the space management session was opened.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeRequestInfo" type="na:DedupeRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Details of deduplication scan To be run on a Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or Id of the Volume on which a space management Operation needs To be performed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResizeVolumeRequestInfo" type="na:ResizeVolumeRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Details of a resize Request To be carried out as part of this space management Operation. The resize Request should be on a Volume in the Aggregate on which the space management session was opened.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotDeletionRequestInfo" type="na:SnapshotDeletionRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Details of a Snapshot deletion Request To be carried out as part of this space management Operation. The Snapshot deletion Request should be on a Volume in the Aggregate on which the space management session was opened.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SpaceManagementOpType" type="na:SpaceManagementOpType">
                        <xsd:annotation>
                            <xsd:documentation>Type of space management Operation.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeMigrationRequestInfo" type="na:VolumeMigrationRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Details of Volume migration Operation To be carried out. The Volumes To be migrated should belong To the Aggregate on which the space management session was opened.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="SpaceManagementResultInfo">
                <xsd:annotation>
                    <xsd:documentation>Results of the space management session.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DryRunResults" type="na:ArrayOfDryRunResult">
                        <xsd:annotation>
                            <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action. Only returned if DryRun is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of job started for the provisioning Request. Returned only when DryRun is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the object on which the space management Operation is invoked.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the object on which space management Operation is invoked.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SpaceManagementOpType" type="na:SpaceManagementOpType">
                        <xsd:annotation>
                            <xsd:documentation>Type of space management Operation.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeMigrationRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of Volume migration Request</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CleanupStaleStorage" type="na:CleanupStaleStorage">
                        <xsd:annotation>
                            <xsd:documentation>Indicates when should the Volumes in the Source Aggregate should be destroyed after successful migration. Default Value is "cleanup_after_migration".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationAggregateNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the destination Aggregate To which all the Volumes has To be migrated To. If the destination Aggregate is not provided, the system will select a suitable Aggregate From the Resource pools associated with the Dataset node To which the Volumes belong To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Retention Type To which the backup Version created should be archived for the Backups created as part of running an on-demand update after successful migration. This element is ignored if RunOnDemandUpdate is false. Default Value is "daily".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RunDedupeScan" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether a full deduplication scan has To be run on the new Volume after migration. This Option is applicable only for Volumes that are enabled for deduplication and is useful To regenerate the fingerprint database used in deduplication and will be ignored for other Volumes. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RunOnDemandUpdate" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether an on-demand update has To be triggered after successful migration on the Dataset To which the Volumes that were migrated belong To. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="AdminName">
                <xsd:annotation>
                    <xsd:documentation>The Name of a DFM administrator To receive alarm notifications.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="AlarmDefaults">
                <xsd:annotation>
                    <xsd:documentation>The default Values of the Attributes defined by this ZAPI.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="GroupId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>The default Group Id for an alarm is 0, representing the "global Group". This Value is returned.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDisabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Unless otherwise specified, the IsDisabled attribute is set To false when the alarm is created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsRepeatNotify" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Unless otherwise specified, the IsRepeatNotify attribute is set To false when the alarm is created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RepeatInterval">
                        <xsd:annotation>
                            <xsd:documentation>Unless otherwise specified, the RepeatInterval is set To this default minimum number of seconds between repeat notifications. If IsRepeatNotify is false, it does not apply. Range: [60..3932100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="60"/>
                                <xsd:maxInclusive value="3932100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="TrapPort">
                        <xsd:annotation>
                            <xsd:documentation>The default port for trap destinations. Range: [1..65535].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="65535"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="AlarmInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a single alarm. This structure is used in three places: creating new alarms, modifying alarms, and listing alarms.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AdminLoginNames" type="na:ArrayOfAdminName">
                        <xsd:annotation>
                            <xsd:documentation>Names of DFM administrators who will receive an alarm email when the alarm is triggered. The alarm email is sent To the email Address configured for the administrator.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AlarmId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the alarm. Required for list and modify, ignored on create. Range: [1..2^15-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="32767"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AlarmScript" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Path on DFM station of a script To run when the alarm is triggered. The script Path is not validated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AlarmScriptRunas" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of user To run alarm script. If not present, the alarm script runs with the same user ID as the DFM event process. This may only be specified as an input if AlarmScript is set and may only be specified for DFM stations not running Windows.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EmailAddresses" type="na:ArrayOfEmailAddress">
                        <xsd:annotation>
                            <xsd:documentation>Email addresses of non administrators who will receive alarm email when this alarm is triggered.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EventClass" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Regular expression specifying the event class of Events that trigger this alarm. Only Events whose event class Match the regular expression will trigger the alarm. The regular expression is of POSIX.1 standard.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EventName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Event Name of Events that trigger this alarm. This should exactly Match the short Name or pretty Name of the event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EventSeverity" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Minimum event Severity To trigger this alarm. If an event's Severity is equal To or more severe than this Value, the alarm will be triggered. Valid Values are only 'normal', 'information', 'unknown', 'warning', 'Error', 'critical', 'emergency'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupId">
                        <xsd:annotation>
                            <xsd:documentation>DFM Group Id which triggers alarm. If the event Source object is in this Group, the alarm will be triggered. Default is 0 which is the global Group. Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DFM Group Name which triggers alarm. If the event Source object is in this Group, the alarm will be triggered. This is returned in the output of AlarmList. If GroupId element is not present during input, then this element is considered. If both GroupId and GroupName are not present, then the alarm is configured for global Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDisabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Whether this alarm is disabled. If it is disabled, it will never be triggered. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsRepeatNotify" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Whether To repeat the notification for this alarm if the triggering event is not acknowledged. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PagerAdminLoginNames" type="na:ArrayOfAdminName">
                        <xsd:annotation>
                            <xsd:documentation>Name of DFM administrators who will receive a shortened alarm email. The email messages are formatted To be easy To read on a pager. The alarm email is sent To the pager email Address configured for the administrator.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PagerEmailAddresses" type="na:ArrayOfEmailAddress">
                        <xsd:annotation>
                            <xsd:documentation>Email addresses of non administrators who will receive shortened alarm email. The email messages are formatted To be easy To read on a pager.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RepeatInterval">
                        <xsd:annotation>
                            <xsd:documentation>Seconds between repeat notifications of the alarm. This will only be returned if repeat-notify is true and may only be specified as an input if IsRepeatNotify is set To true. The Value is rounded off To the nearest minute. It can have a Maximum Value of 65535 minutes. Default Value is 1800 seconds (30 minutes) Range: [60..3932100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="60"/>
                                <xsd:maxInclusive value="3932100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TimeFrom">
                        <xsd:annotation>
                            <xsd:documentation>Start time of Day when alarm may be triggered, in seconds since Midnight UTC. The Value is rounded off To the nearest minute. The default is To always trigger the alarm. Range: [0..86399]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="86399"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TimeTo">
                        <xsd:annotation>
                            <xsd:documentation>End time of Day when alarm may be triggered, in seconds since Midnight UTC. The Value is rounded off To the nearest minute. The default is To always trigger the alarm. TimeTo Value is generally greater than TimeFrom Value. If it is lesser than TimeFrom Value, then it is considered as inverted TimeRange. In this case, if the Values of the fields are 20:00 and 2:00, then the alarm is triggered between 0:00 and 2:00 and 20:00 To 23:59. Range: [0..86399]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="86399"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TrapDestinations" type="na:ArrayOfTrapDestination">
                        <xsd:annotation>
                            <xsd:documentation>IP Address or Host Name, SNMP community and port To which a SNMP trap is sent as part of this alarm.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="EmailAddress">
                <xsd:annotation>
                    <xsd:documentation>A single email Address. It cannot contain spaces, semi-colons or unprintable characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="TrapDestination">
                <xsd:annotation>
                    <xsd:documentation>Destination parameters for a SNMP trap.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="TrapCommunity" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>SNMP community To use when sending trap. Default is "public".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TrapHost" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Hostname or IP Address of trap destination.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TrapPort">
                        <xsd:annotation>
                            <xsd:documentation>Port number where To send trap. Range: [1..65535]. Default Value is port 162.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="65535"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="Request">
                <xsd:annotation>
                    <xsd:documentation>One API Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Args">
                        <xsd:annotation>
                            <xsd:documentation>The API arguments.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:any maxOccurs="unbounded" minOccurs="0"/>
                            </xsd:sequence>
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>API Name. The proxy server may have a security Policy that restricts the accepted Values for this field. Invalid Values will cause EACCESSDENIED.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="Response">
                <xsd:annotation>
                    <xsd:documentation>One API Response.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Errno" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Error code. Only present if Status is "failed".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Reason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Reason string. Only present if Status is "failed".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Results">
                        <xsd:annotation>
                            <xsd:documentation>The API Results. Only present if Status is "passed".</xsd:documentation>
                        </xsd:annotation>
                        <xsd:complexType>
                            <xsd:sequence>
                                <xsd:any maxOccurs="unbounded" minOccurs="0"/>
                            </xsd:sequence>
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element name="Status" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Status of the Response. May be "passed" or "failed".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="CifsDomainInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of the cifs domain.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CifsDnsDomainName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the CIFS DNS domain Name. Maximum Length: 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CifsDomainId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the cifs domain. Range: [1..(2^16)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="65535"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="CifsDomainName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the NETBIOS Name of the cifs domain. Maximum Length: 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ClientOptionInfo">
                <xsd:annotation>
                    <xsd:documentation>Single name/value pair.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Option" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Key for the database To be stored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The data itself.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="CommentFieldId">
                <xsd:annotation>
                    <xsd:documentation>Identifier of the comment field. Range: [1..2^31-1]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="CommentFieldInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the comment field.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CommentFieldId" type="na:CommentFieldId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the comment field. This field is ignored on create.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CommentFieldName" type="na:CommentFieldName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the comment field. Required for create.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CommentFieldObjectTypes" type="na:ArrayOfCommentFieldObjectType">
                        <xsd:annotation>
                            <xsd:documentation>Object Type(s) of the comment field. If not specified, then no object Type will be associated with the comment field.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSystemComment" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether this is a system comment field. This field is returned in list output and ignored on create. By default, this is false. System comment fields cannot be modified or destroyed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="CommentFieldName">
                <xsd:annotation>
                    <xsd:documentation>Name of the comment field. Name can contain a Maximum of 255 characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="CommentFieldNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or identifier of the comment field. It must conform To one of the following formats: &lt;ul&gt; &lt;li&gt; It must be of the format of &lt;b&gt;CommentFieldName&lt;/b&gt; &lt;li&gt; It must be of the format of &lt;b&gt;CommentFieldId&lt;/b&gt; &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="CommentFieldObjectType">
                <xsd:annotation>
                    <xsd:documentation>Object Type of the comment field. Name can contain a Maximum of 64 characters. Possible input Values are 'Dataset', 'DP Policy', 'Prov Policy'.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="CommentFieldValue">
                <xsd:annotation>
                    <xsd:documentation>A single comment field Value.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CommentFieldId" type="na:CommentFieldId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the comment field.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CommentFieldName" type="na:CommentFieldName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the comment field.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CommentValue" type="na:CommentValue">
                        <xsd:annotation>
                            <xsd:documentation>Value of the comment field</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the managed object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the managed object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the managed object. Possible Values: &lt;ul&gt; &lt;li&gt; "Host" &lt;li&gt; "Volume" &lt;li&gt; "Resource Group" &lt;li&gt; "Qtree" &lt;li&gt; "Interface" &lt;li&gt; "Administrator" &lt;li&gt; "Network" &lt;li&gt; "Mgmt Station" &lt;li&gt; "Configuration" &lt;li&gt; "QuotaUser" &lt;li&gt; "Initiator Group" &lt;li&gt; "Lun Path" &lt;li&gt; "FCP Target" &lt;li&gt; "Directory" &lt;li&gt; "HBA" &lt;li&gt; "FCP Initiator" &lt;li&gt; "SAN Host Cluster" &lt;li&gt; "SRM Path" &lt;li&gt; "Mirror" &lt;li&gt; "Aggregate" &lt;li&gt; "Script" &lt;li&gt; "Script Schedule" &lt;li&gt; "Script Job" &lt;li&gt; "Role" &lt;li&gt; "Data Set" &lt;li&gt; "Storage Set" &lt;li&gt; "Resource Pool" &lt;li&gt; "DP Policy" &lt;li&gt; "DP Schedule" &lt;li&gt; "DP Throttle" &lt;li&gt; "OSSV Directory" &lt;li&gt; "Prov Policy" &lt;li&gt; "Schedule" &lt;li&gt; "Report Schedule" &lt;li&gt; "VFiler Template" &lt;li&gt; "Disk" &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="CommentValue">
                <xsd:annotation>
                    <xsd:documentation>Value of the specified comment field To be set on the object. This can be of Maximum 1024 characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ApplicationInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about an application.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ApplicationName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of an application, up To 255 characters long. For example: "SnapManager for Oracle"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ApplicationServerName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the server the application is running on, up To 255 characters long. This is the Name of the Host server, rather than the Name of the client application.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ApplicationVersion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Version of an application, up To 255 characters long. For example: "2.1"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CarryPrimaryBackupRetention" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If this input is true, Retention Type of the primary backup is assigned To its replicas on the other nodes of the Dataset. An exception is made if the DpBackupStart API with RetentionType specified, starts the replication. In that case, the Retention Type specified in DpBackupStart is assigned To the replicas thereby overriding the Retention Type of the primary backup. If a scheduled event starts the replication, Retention Type specified in the schedule event is ignored. &lt;P&gt; If this input is false, Retention Type of the primary backup is ignored when assigning Retention Type To its replicas. Depending on how the backup transfer job was started, the Retention Type specified either in DpBackupStart API or the one specified in the schedule is assigned To the replica of the primary backup. &lt;P&gt; When this input is false, replicas of the primary backup may get an undesired Retention Type if the schedules are not configured very carefully. Therefore, it is recommended that any new users of the API should always set this input To true. &lt;P&gt; Note that even if the Retention Type of primary and secondary Backups is the same, the Retention Duration may be different for them. The Retention Duration is specified for each node in the data protection Policy. See DpPolicyNodeInfo for more details. &lt;P&gt; Always present in the output. &lt;P&gt; Default is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsApplicationManagingPrimaryBackupRetention" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If this input is true, Protection Manager does not enforce Retention settings in the Policy on the primary Backups. Application is responsible for deleting primary Backups, possibly by invoking DpBackupVersionDelete API. &lt;P&gt; If this input is false, Protection Manager deletes the primary Backups according To the Retention settings specified in the Policy. &lt;P&gt; Always present in the output. &lt;P&gt; Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsApplicationResponsibleForPrimaryBackup" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>DFM creates primary backup versions only if this Option is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="CifsPermission">
                <xsd:annotation>
                    <xsd:documentation>Permission granted To a CIFS user on a share. Possible Values are 'no_access', 'read', 'change' and 'full_control'</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="CifsShareInfo">
                <xsd:annotation>
                    <xsd:documentation>Specifies the Properties of a CIFS share on Data ONTPAP system.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CifsShareName" type="na:CifsShareName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the CIFS share.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CifsSharePermissions" type="na:ArrayOfCifsSharePermission">
                        <xsd:annotation>
                            <xsd:documentation>ACL information of a CIFS share.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="CifsShareName">
                <xsd:annotation>
                    <xsd:documentation>CIFS share Name of the storage container (Volumes, Qtrees). Example \\server\sharename.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="CifsSharePermission">
                <xsd:annotation>
                    <xsd:documentation>CIFS ACL information configured for a CIFS share.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CifsUsername" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the user configured To access a CIFS share.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Permission" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>CIFS Permission configured for the user accessing a CIFS share.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ConformanceAlert">
                <xsd:annotation>
                    <xsd:documentation>A Description of one conformance check alert that should be noted by a user.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ConformanceAlertEffect" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The predicted Effect of the alert. If there is no Effect, this element will not be present</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceAlertReason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies possible reasons for alert.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceAlertSeverity" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Severity of the alert. Possible Values are "information", "Error" or "warning".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ConformanceAlertSuggestion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present only if Severity is Error or warning. Specifies any suggestions To rectify the warnings, Errors. If there are no suggestions To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceAlertType" type="na:ConformanceAlertType">
                        <xsd:annotation>
                            <xsd:documentation>Indicates the Type for this alert</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ConformanceAlertType">
                <xsd:annotation>
                    <xsd:documentation>The Type of alert that is being issued is indicated by a field of this Type. The alert-type may apply To the ConformanceAlerts. &lt;p&gt; Possible Values are: 'diskspace' and 'rebaseline'. &lt;ul&gt; &lt;li&gt;diskspace: An alert can be issued for when DFM station disk space is so low as To impact the Operation of DFM. &lt;li&gt;rebaseline: When the system detects that existing relationships are in need of migration an alert of this Type may be issued To warn that a rebaseline may be done should the user confirm conformance for non-conformant Datasets. &lt;/ul&gt; Please see ConformanceAlerts where the above Values may be used for additional information.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ConformanceRunResult">
                <xsd:annotation>
                    <xsd:documentation>A Description of one Action and the predicted effects of taking that Action.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ConformanceJobId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>job Id of the conformance job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceRunAction" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An Action the system has taken.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceRunEffect" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Result of the Action.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ConformanceRunReason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present only if Severity is Error or warning. Specifies possible reasons for Error, warning. If there are no reasons To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ConformanceRunReasonDetails" type="na:ArrayOfResultDetail">
                        <xsd:annotation>
                            <xsd:documentation>These details apply To the associated ConformanceRunReason within the same ConformanceRunResult. These offer additional information such as the reasons individual reasources may not have been selected for the ConformanceRunAction in this same ConformanceRunResult.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceRunSeverity" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Severity of conformance Action. Possible Values are "information", "Error", "warning".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ConformanceRunSuggestion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present only if Severity is Error or warning. Specifies any suggestions To rectify warnings or Errors. If there are no suggestions To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetAccessDetails">
                <xsd:annotation>
                    <xsd:documentation>The data access details of a Dataset. Currently, this is used To configure a Dataset in a way that it is capable of transparent migration. A Dataset can be configured and provisioned in a way that it is capable of transparent migration. IP Address and Netmask has To be configured on the Dataset in order To make the Dataset capable of transparent migration. Provisioning Manager will create a vFiler Unit with this IP Address and all the storage provisioned for this Dataset will be accessed From this vFiler Unit or this IP Address. As input, it is valid only when: - There are no Members in the Dataset. - There is no vFiler Unit attached To the Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="IpAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>IP Address in dotted decimal format. (for example, "192.168.11.12"). The Length of this string cannot be more than 16 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Netmask" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Netmask for the IP Address in dotted decimal notation. As input, this is valid only when IpAddress is also provided in DatasetAccessDetails. Provisioning Manager will create a vFiler Unit whose IP Address will be the one configured as IpAddress and it will be bound To an Interface with this Netmask.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetCifsExportSetting">
                <xsd:annotation>
                    <xsd:documentation>If storage inside this Dataset node is exported over CIFS, this specifies some of the common Properties that will be applied To all such provisioned storage.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CifsDomain" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the CIFS domain. If present, then only filers or vFilers belonging To this CIFS domain is considered for provisioning. If not present, then any Filer is picked. Up To 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetCifsSharePermissions" type="na:ArrayOfDatasetCifsSharePermission">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the permissions granted To users on storage provisioned in this Dataset node. This field may be present only if the DatasetExportProtocol is 'cifs' or 'mixed'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetCifsSharePermission">
                <xsd:annotation>
                    <xsd:documentation>A single Permission granted To a user on CIFS shares within a Dataset node.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CifsUsername" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of a user in the specified domain. The Username may be the Name of an actual domain user or one of the built-in names - 'administrator' or 'everyone'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Permission" type="na:CifsPermission">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the permissions granted To a user.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetDynamicReferenceInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one dynamic reference in a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Policy node To which the dynamic reference is attached. This element is only included if a data protection Policy is associated with the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DynamicReferenceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the dynamic reference.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DynamicReferenceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the dynamic reference.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DynamicReferenceStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the dynamic reference.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DynamicReferenceType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the dynamic reference. Possible Values are 'Filer', 'Vfiler', 'Aggregate' or 'ossv_host'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this member and all of it's parents are up or online. Only valid for Members of Type "ossv-host," "ossv-dir," "Filer," "Vfiler," "Aggregate," "Volume," or "Qtree".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the storage set To which the dynamic reference belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage set To which the dynamic reference belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetDynamicReferenceParameter">
                <xsd:annotation>
                    <xsd:documentation>Information about one dynamic reference in a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the data protection Policy node associated with the dynamic reference. If DpNodeName is not specified, the root data protection Policy node is assumed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the dynamic reference To add To or remove From the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetExportInfo">
                <xsd:annotation>
                    <xsd:documentation>Specifies the NAS or SAN export settings for a Dataset node.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetCifsExportSetting" type="na:DatasetCifsExportSetting">
                        <xsd:annotation>
                            <xsd:documentation>The CIFS export settings for storage exported over CIFS. This field may be present only if the DatasetExportProtocol is 'cifs' or 'mixed'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetExportProtocol" type="na:DatasetExportProtocol">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Protocol over which Members of the Dataset node will be exported. This Value is always returned. If omitted during a modify Operation, the existing Value is not changed. If specified as 'none' in a modify Operation, the existing settings will be cleared. Default Value is 'none'. Depending on the export Protocol, dataset-lun-mapping, or a combination of DatasetNfsExportSetting and DatasetCifsSharePermissions, should be specified in a modify Operation, and will be returned in the iterator output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetLunMappingInfo" type="na:DatasetLunMappingInfo">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Hosts and/or Initiators To which LUNs in this Dataset node will be mapped, and the igroup OS Type. This field may be present only if the DatasetExportProtocol is 'fcp' or 'iscsi'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetNfsExportSetting" type="na:DatasetNfsExportSetting">
                        <xsd:annotation>
                            <xsd:documentation>The NFS export settings for storage exported over NFS. This field may be present only if the DatasetExportProtocol is 'nfs' or 'mixed'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DatasetExportProtocol">
                <xsd:annotation>
                    <xsd:documentation>Specifies the export protocols that Members in this Dataset node will be exported over. Possible Values are 'nfs', 'cifs', 'mixed', 'fcp', 'iscsi' and 'none'. Specifying 'mixed' implies that the storage in the Dataset should be exported over both NFS and CIFS.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DatasetInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ApplicationInfo" type="na:ApplicationInfo">
                        <xsd:annotation>
                            <xsd:documentation>If IsApplicationData is true, then this element must be present and it will contain information about the application which manages this Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetAccessDetails" type="na:DatasetAccessDetails">
                        <xsd:annotation>
                            <xsd:documentation>Data access details for a Dataset. This is returned only when a Dataset is configured To be capable of transparent migration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetContact" type="na:EmailAddressList">
                        <xsd:annotation>
                            <xsd:documentation>Contact information for the Dataset, such as the owner's e-mail Address.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the Dataset, up To 255 characters long.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetExportInfo" type="na:DatasetExportInfo">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the NAS or SAN export settings for the root node of the Dataset. This field is present only if the IncludeExportSettings field was set To true in DatasetListInfoIterStart for this iteration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetMap" type="na:ArrayOfDatasetMapEntry">
                        <xsd:annotation>
                            <xsd:documentation>List the Policy node To storage set mapping. This shows how the storage set are wired together based on the Policy topology for the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetMetadata" type="na:ArrayOfDfmMetadataField">
                        <xsd:annotation>
                            <xsd:documentation>Opaque metadata for Dataset. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetMigrationInfo" type="na:DatasetMigrationInfo">
                        <xsd:annotation>
                            <xsd:documentation>Dataset's migration information. This will be present only if IncludeMigrationInfo is set To true in DatasetListInfoIterStart api. If the Dataset is not migrating this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetOwner" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the owner of the Dataset, up To 255 characters long.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetStatus" type="na:DatasetStatus">
                        <xsd:annotation>
                            <xsd:documentation>The complex Status of the Dataset at the time it was last calculated. If suppress-dataset-status was not set To true, then the Resource Status will be re-calculated as part of the iteration. The Resource Status is the only aspect of DatasetStatus that is ever refreshed when iterated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DrState" type="na:DrState">
                        <xsd:annotation>
                            <xsd:documentation>Disaster recovery state of the Dataset. &lt;P&gt; If the Dataset list iteration's output element &lt;b&gt;IsDrCapable&lt;/b&gt; is true, then this element appears in the output. Otherwise, if &lt;b&gt;IsDrCapable&lt;/b&gt; is false, this element does not appear in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DynamicReferenceCount">
                        <xsd:annotation>
                            <xsd:documentation>The Count of dynamic references To Members in the Dataset. Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="HasProtection" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this Dataset has a data protection Policy and it has at least 1 relationship associated with it, or if the Policy has only 1 node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HasProtectionPolicy" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this Dataset has a data protection Policy associated with it.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAllowCustomSettings" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, conformance check of some Volume Options is disabled for the Dataset. These Volume Options include, fractional-reserve, autodelete commitment and autodelete trigger Attributes only. This Option is applicable only for Datasets which have san thin provisioning Policy associated. For other Datasets the Option is ignored. default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsApplicationData" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, the Dataset is an application Dataset managed by an external application. ApplicationInfo element is required if this element is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To ignore this Dataset for purposes of data protection. Data sets with this attribute set To true are not returned when the client requests Datasets which are not ignored. This attribute has no other significance To the system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpSuspended" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To suspend data protection of this Dataset. &lt;P&gt; Deprecated field. Retained for backward compatibility. This field is deprecated in favour of IsSuspended, which suspends the Dataset for all automated actions (data protection and conformance check of the Dataset).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDrCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this Dataset has a data protection Policy associated with it that is disaster recovery capable.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsEnableWriteGuaranteeChecks" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, periodic write guarantee checks are enabled for the Dataset. This Option is applicable only for Datasets which have SAN thin provisioning Policy associated. Presence of lun-clones, flex-clones, SFSR operations in the Volume may Effect write guarantees in SAN thin provisioning configurations. Periodic write guarantee checks detect such Condition and generate alerts. For other Datasets the Option is ignored. default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsProtected" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this Dataset has a data protection Policy associated with it. &lt;P&gt; Deprecated field. Retained for backward compatibility. This field is deprecated and To be replaced by HasProtectionPolicy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSuspended" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To suspend this Dataset for all automated actions (data protection and conformance check of the Dataset).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsVfilerCreatedForMigration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the vFiler Unit attached To the Dataset node was created by Provisioning Manager for migration. This element is present only when VfilerId element is present. Default: false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumLunsPerVolume" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Dataset level Option that specifies the Maximum number of Luns that can be provisioned in a Volume. If the Value is empty, then the Value of the global Option maxLUNsPerVolume is applicable for the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumQtreesPerVolume" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Dataset level Option that specifies the Maximum number of Qtrees that can be provisioned in a Volume. If the Value is empty, then the Value of the global Option maxQtreesPerVolume is applicable for the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberCount">
                        <xsd:annotation>
                            <xsd:documentation>The Count of direct Members in the Dataset. Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OnlineMigration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates, that this Dataset is capable of non-disruptive migration. This field is valid only when either DatasetAccessDetails or VfilerId is not empty. By default the migration will be assumed To be disruptive. Default: false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the protection Policy governing this Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionPolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the protection Policy governing this Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the provisioning Policy associated with primary node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the provisioning Policy associated with the primary node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RequiresNonDisruptiveRestore" type="na:RequiresNonDisruptiveRestore">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether the Dataset is configured To enable non-disruptive restores.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Resource pool assigned To the root storage set. The output element is omitted if no resouce pool has been assigned To the root storage set. &lt;P&gt; If more than one Resource pool is assigned To the Dataset node, then the Resource pool with the least valued identifier is returned in this field. &lt;P&gt; This is a legacy parameter and Resourcepools field should be used instead To get the list of all Resource pools assigned To the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool assigned To the root storage set. The output element is omitted if no Resource pool has been assigned To the root storage set. &lt;P&gt; If more than one Resource pool is assigned To the Dataset node, then the Name of the Resource pool with the least valued identifier is returned in this field. &lt;P&gt; This is a legacy parameter and Resourcepools field should be used instead To get the list of all Resource pools assigned To the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Resourcepools" type="na:ArrayOfDatasetResourcepoolInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information of the Resource pool(s) assigned To the root storage set. The output element is omitted if no Resource pool(s) has been assigned To the root storage set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageServiceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the storage Service To which this Dataset is attached. This will not be present if the Dataset is not attached To a storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageServiceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage Service To which this Dataset is attached. This will not be present if the Dataset is not attached To a storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the storage set representing the primary data, or "root," of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage set representing the primary data, or "root," of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetTimezone" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Time zone, if any, of the root storage set. Return an empty string if no time zone has been assigned To the root storage set. Currently valid time zones can be listed by TimezoneListInfoIterStart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the vFiler Unit attached To the primary node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the vFiler Unit attached To the primary node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeQtreeNamePrefix" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Prefix for Volume and Qtree names, up To 60 characters long.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetLunMappingInfo">
                <xsd:annotation>
                    <xsd:documentation>Specifies the Hosts and/or Initiators To which LUNs in this Dataset node will be mapped, and the igroup OS Type.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="IgroupOsType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the OS Type for Initiators To map LUNs in the Dataset node To. Possible Values are: 'windows', 'windows_gpt', 'windows_2008', 'hpux', 'aix, 'linux, 'solaris', 'vmware' and 'netware'. Here "windows_gpt" refers To Windows using GPT (GUID Partition Type) partitioning style and "windows_2008" refers To Windows Longhorn systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunMappingInitiators" type="na:ArrayOfLunMappingInitiator">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Initiators To map LUNs in the Dataset node To, and, optionally, the Host To which they belong.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetMapEntry">
                <xsd:annotation>
                    <xsd:documentation>Map a storage set To a Policy node. The root node is not included in the map.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetAccessDetails" type="na:DatasetAccessDetails">
                        <xsd:annotation>
                            <xsd:documentation>Data access details for a Dataset. This is returned only when a Dataset is configured To be capable of transparent migration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetExportInfo" type="na:DatasetExportInfo">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the NAS or SAN export settings for the storage set. This field is present only if the IncludeExportSettings field was set To true in DatasetListInfoIterStart for this iteration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpNodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the node in the data protection Policy. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node in the data protection Policy topology.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDrCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this node is the destination of a disaster recovery capable connection in the data protection Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsVfilerCreatedForMigration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the vFiler Unit attached To the Dataset node was created by Provisioning Manager for migration. This element is present only when VfilerId element is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the provisioning Policy associated with the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the provisioning Policy associated with the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Resource pool assigned To the storage set that maps To the Policy node. The output element is omitted if no Resource pool has been assigned To the storage set. &lt;P&gt; If more than one Resource pool is assigned To the Dataset node, then one of them is returned in this field. &lt;P&gt; This is a legacy parameter and Resourcepools field should be used instead To get the list of all Resource pools assigned To the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool assigned To the storage set that maps To the Policy node. The output element is omitted if no Resource pool has been assigned To the storage set. &lt;p&gt; If more than one Resource pool is assigned To the Dataset node, then the Name of the Resource pool with the least valued identifier is returned in this field. &lt;P&gt; This is a legacy parameter and Resourcepools field should be used instead To get the list of all Resource pools assigned To the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Resourcepools" type="na:ArrayOfDatasetResourcepoolInfo">
                        <xsd:annotation>
                            <xsd:documentation>Name Information of the Resource pool(s) assigned To the storage set that maps To the Policy node. The output element is omitted if no Resource pool(s) has been assigned To the storage set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the storage set that maps To the Policy node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage set that maps To the node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetTimezone" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Time zone specification, if any, of the storage set. Storage sets without time zones use a time zone From the Resource pool the storage came From, or From a default time zone. Return an empty string if no time zone has been assigned To the storage set. Currently valid time zones can be listed by TimezoneListInfoIterStart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the vFiler Unit attached To the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the vFiler Unit attached To the Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetMemberInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one member of a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CifsShareNames" type="na:ArrayOfCifsShareName">
                        <xsd:annotation>
                            <xsd:documentation>List of share names for accesing the storage container (volume/qtree) when access Protocol of storage set is "CIFS" or "Mixed".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CifsSharesInfo" type="na:ArrayOfCifsShareInfo">
                        <xsd:annotation>
                            <xsd:documentation>CIFS share settings of a Dataset member. Applicable is the Dataset member (volume/qtree) is exported over CIFS Protocol.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the Policy node To which the member is attached. This element is only included if a data protection Policy is associated with the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this object and all of its parents are up or online. Only valid for Members of Type "ossv-host," "ossv-dir," "Filer," "Vfiler," "Aggregate," "Volume," or "Qtree".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LunIgroupsInfo" type="na:ArrayOfLunIgroupInfo">
                        <xsd:annotation>
                            <xsd:documentation>If the LUN has been mapped To any igroups or Hosts, this field contains information relevant To the same. This field is present only for LUNs, and absent if the LUN is not mapped To any initiator Groups.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberPerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the member based on the worst performance event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the member. Possible Values for direct Members are: "Volume", "Qtree" or "ossv_directory". When IncludeExportsInfo is true in DatasetMemberListInfoIterStart, this can also be "lun_path".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name by which the storage container(volume/qtree) has been exported. The Volume or Qtree can be exported with a different Path From its physical Path on the Filer (with -actual Option in the NFS export rule. Example: "/vol/myvol/myqtree" can be exported as "myexport") if not this will be same as full Path of the container.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="NfsExportRules" type="na:NfsExportRules">
                        <xsd:annotation>
                            <xsd:documentation>NFS export rule information of a Dataset member. Applicatble if the Dataset member (volume/qtree) is exported over NFS Protocol.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceInfo" type="na:SpaceInfo">
                        <xsd:annotation>
                            <xsd:documentation>Space related information of a Dataset member. Included in the output only if IncludeSpaceInfo was true in the call To DatasetMemberListInfoIterStart. Note that some Members will not have space related information. Those Type of Members are: &lt;ul&gt; &lt;li&gt; Non Qtree data &lt;li&gt; Qtrees without hard disk quota limit. &lt;/ul&gt; In these cases, it is considered that the space Status of such Members is unknown.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the storage set To which the member belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StoragesetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage set To which the member belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetMemberParameter">
                <xsd:annotation>
                    <xsd:documentation>Information about one member of a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the data protection Policy node associated with the object. If DpNodeName is not specified, the object is added To the root data protection Policy node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the object To add To or remove From the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetMigrationInfo">
                <xsd:annotation>
                    <xsd:documentation>Dataset's migration information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description associated with the migration task</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationFilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the destination storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationFilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the destination storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationVfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the destination Vfiler. If the migration Status is 'migrate_failed' and the destination Vfiler has been destroyed as a Result of rollback activity. this field will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationVfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the destination Vfiler. If the migration Status is 'migrate_failed' and the destination Vfiler has been destroyed as a Result of rollback activity. this field will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MigrationStatus" type="na:MigrationStatus">
                        <xsd:annotation>
                            <xsd:documentation>Migration Status of the Dataset</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Provisioning Policy used To provision the migration destination</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the provisioning Policy used To provision the migration destination.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceFilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the Source storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceFilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Source storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceVfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the Source Vfiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceVfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Source Vfiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetNfsExportSetting">
                <xsd:annotation>
                    <xsd:documentation>If storage inside this Dataset node is exported over NFS, this specifies some of the common Properties that will be applied To all such provisioned storage.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AnonymousAccessUser">
                        <xsd:annotation>
                            <xsd:documentation>If the client accessing the export is not present in the root access list for the export, the effective user for root is the Value specified for this field. Default Value is 65534 which maps To user nobody. It could be an integer Range: [0..65534] or a user Name not more than 255 characters.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="65534"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DisableSetuid" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, causes the server file system To ignore attempts To enable the setuid or setgid mode bits. Default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsReadonlyForAllHosts" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies that all Hosts receive read-only permissions on nfs exports in this Dataset node. Equivalent To specifying "ro" on the Filer. Default Value is false. If true, IsReadwriteForAllHosts must be false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsReadwriteForAllHosts" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies that all Hosts receive read-write permissions on nfs exports in this Dataset node. Equivalent To specifying "rw" on the Filer. Default Value is false. If true, IsReadonlyForAllHosts must be false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportRoHosts" type="na:ArrayOfNfsExportHost">
                        <xsd:annotation>
                            <xsd:documentation>A list of Hosts with read-only permissions on exports in this Dataset node. If a non empty list of NfsExportRoHosts is present along with IsReadonlyForAllHosts as true, then ZAPI will throw an Error.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportRootHosts" type="na:ArrayOfNfsExportHost">
                        <xsd:annotation>
                            <xsd:documentation>A list of Hosts with the root user having read-only or read-write permissions on exports in this Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportRwHosts" type="na:ArrayOfNfsExportHost">
                        <xsd:annotation>
                            <xsd:documentation>A list of Hosts with read-write permissions on exports in this Dataset node. If a non empty list of NfsExportRwHosts is present along with IsReadwriteForAllHosts as true, then ZAPI will throw an Error.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsProtocolVersion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>NFS Protocol Version, valid Values are "v2", "v3" and "v4". Default Value is "v3". If set, the storage systems that have the given Version enabled will be selected To provision storage for the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsSecurityFlavors" type="na:ArrayOfNfsSecurityFlavor">
                        <xsd:annotation>
                            <xsd:documentation>List of strings specifying the security flavors supported on exports in this Dataset node. If this field is not specified, the default Value of 'sys' is assumed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetNodeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Dataset node.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Dataset. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name or the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpNodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the node in the data protection Policy associated with the Dataset. If there is no protection Policy assigned To the Dataset, then the Value 1 is returned. Range:[1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node in the data protection Policy associated with the Dataset. If there is no data protection Policy assigned To the Dataset, then the Name of the Dataset is returned as the node Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpNodeEffectivePrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>This Value will be true when the node in the Dataset is the effective primary node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetResourcepoolInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about Resource pools associated with Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ResourcepoolId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Resource pool assigned To the storage set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ResourcepoolName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool assigned To the storage set. storage set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetStatus">
                <xsd:annotation>
                    <xsd:documentation>The complex Status of the Dataset at the time it was last re-calculated.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ConformanceCheckResults" type="na:ArrayOfConformanceRunResult">
                        <xsd:annotation>
                            <xsd:documentation>Results of the most recent conformance check. If the Dataset does not have a data protection Policy assigned To it, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ConformanceStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A Dataset is in conformance if it is configured according To Policy. For example, a data protection Policy might require provisioned secondary and tertiary Volumes and the creation of backup and mirroring relationships. If they are properly configured, then the Dataset is conformant. &lt;p&gt; If the Dataset is not conformant, but the system is currently in the process of bringing the data set into conformance, then the Dataset is conforming. If the system is unable To satisfy one or more Policy requirements, then the Dataset is nonconformant. &lt;p&gt; Possible Values are: 'conformant', 'conforming', 'nonconformant'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DrProtectionStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The DR protection Status only applies To Datasets with data protection policies and only To protection Policy connections which are disaster recovery capable. &lt;p&gt; A system may be up and running and properly configured, yet not protecting data. For example, if the Lag Thresholds specified by the Policy are exceeded, then the data is not being sufficiently protected. &lt;p&gt; &lt;P&gt; Possible Values are &lt;ul&gt; &lt;li&gt; &lt;b&gt;protected&lt;/b&gt; : Dataset has complete backup versions on all nodes of the Dataset that are To retain Backups as per Policy. This is a normal Condition. &lt;li&gt; &lt;b&gt;uninitialized&lt;/b&gt; : Dataset is missing some data protection relationships. This is a warning Condition. &lt;li&gt; &lt;b&gt;protection_suspended&lt;/b&gt; : Dataset has been suspended as administrator requested and is not performing data protection or conformance operations. This is a warning Condition. &lt;li&gt; &lt;b&gt;protection_failure&lt;/b&gt; : Dataset has a job failure while protecting data. This is a warning Condition. &lt;li&gt; &lt;b&gt;lag_warning&lt;/b&gt; : Last successful data transfer on the connection or the most recent protected data on the primary node is older than the Lag warning threshold. This is a warning Condition. &lt;li&gt; &lt;b&gt;lag_error&lt;/b&gt; : Last successful data transfer on the connection or the most recent protected data on the primary node is older than the Lag Error threshold. This is an Error Condition. &lt;li&gt; &lt;b&gt;baseline_failure&lt;/b&gt; : Dataset has a baseline job failure and is not able To register any backup Version. This is an Error Condition. &lt;/ul&gt; &lt;P&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DrStatus" type="na:DrStatus">
                        <xsd:annotation>
                            <xsd:documentation>The Status of the Dataset with regard To Disaster Recovery. The DR Status determines how successful a DR Operation such as a failover likely would be if it were performed on the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DrStatusProblems" type="na:ArrayOfDrStatusProblem">
                        <xsd:annotation>
                            <xsd:documentation>A list of the problems found that cause the data set not To have a &lt;b&gt;DrStatus&lt;/b&gt; of "normal". This list is not guaranteed To contain all problems related To DR Status. &lt;P&gt; If &lt;b&gt;DrStatus&lt;/b&gt; is present and does not have the Value "normal", then this element appears in the output, and the list contains at least one item. Otherwise, it does not appear.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PerformanceStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Performance Status of the Dataset based on the worst performance Events on its Members.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The protection Status only applies To Datasets with data protection policies. &lt;p&gt; A system may be up and running and properly configured, yet not protecting data. For example, if the Lag Thresholds specified by the Policy are exceeded, then the data is not being sufficiently protected. &lt;p&gt; &lt;P&gt; Possible Values are &lt;ul&gt; &lt;li&gt; &lt;b&gt;protected&lt;/b&gt; : Dataset has complete backup versions on all nodes of the Dataset that are To retain Backups as per Policy. This is a normal Condition. &lt;li&gt; &lt;b&gt;uninitialized&lt;/b&gt; : The Dataset either doesn't have any data in it or it has a "local Snapshots only" Policy (it is a one-node Dataset) and the schedule for that Policy haven't kicked off any Jobs as of yet (or there is no schedule at all). An application Dataset could also reach this Status after it has been created and no scheduled job is run. This is a warning Condition. &lt;li&gt; &lt;b&gt;protection_suspended&lt;/b&gt; : Dataset has been suspended as administrator requested and is not performing data protection or conformance operations. This is a warning Condition. &lt;li&gt; &lt;b&gt;protection_failure&lt;/b&gt; : Dataset has a job failure while protecting data. This is a warning Condition. &lt;li&gt; &lt;b&gt;lag_warning&lt;/b&gt; : Last successful data transfer on the connection or the most recent protected data on the primary node is older than the Lag warning threshold. This is a warning Condition. &lt;li&gt; &lt;b&gt;lag_error&lt;/b&gt; : Last successful data transfer on the connection or the most recent protected data on the primary node is older than the Lag Error threshold. This is an Error Condition. &lt;li&gt; &lt;b&gt;baseline_failure&lt;/b&gt; : Dataset has a baseline job failure and is not able To register any backup Version. This is an Error Condition. &lt;/ul&gt; &lt;P&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionStatusProblems" type="na:ArrayOfProtectionStatusProblem">
                        <xsd:annotation>
                            <xsd:documentation>A list of the problems found that cause the Dataset not To have a &lt;b&gt;ProtectionStatus&lt;/b&gt; of "protected". This list is not guaranteed To contain all problems related To protection Status. &lt;P&gt; If &lt;b&gt;ProtectionStatus&lt;/b&gt; does not have the Value "protected", then this element will be present in the output as long as the IncludeProtectionStatusProblems is set To true and only one Dataset is specified in the DatasetListInfoIterStart api. Otherwise, it does not appear.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ResourceStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>The Resource Status is the "worst" Status of the resources relevant To the Dataset. Resource Status is calculated using the same rules as for DFM Resource Group Status.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceStatus" type="na:SpaceStatus">
                        <xsd:annotation>
                            <xsd:documentation>Space Status of the Dataset. Space Status of every member of every node of the data set is considered and the worst space Status is considered as the space Status of the Dataset. Space Status for Members of a Dataset node is calculated only if a provisioning Policy is associated with that Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DedupeMemberRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of the dedupe member Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FullVolumeDedupe" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, full Volume dedupe scan is performed. Otherwise only new data since last deduplication Operation is scanned. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of a Volume member of a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of a Volume member of the Dataset. Either VolumeId or VolumeName has To be specified. If VolumeId is specified then VolumeName is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DeleteSnapshotsRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details on which Snapshot copies are To be deleted.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Snapshots" type="na:ArrayOfSnapshot">
                        <xsd:annotation>
                            <xsd:documentation>List of Snapshot copies To be deleted From the Volume. A minimum of 1 and a Maximum of 255 Snapshot copies can be listed for deletion.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Volume whose Snapshot copies are To be deleted. This Volume should be a member of the effective primary node of the Dataset either through direct or indirect membership.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Volume whose Snapshot copies are To be deleted. This Volume should be a member of the effective primary node of the Dataset either through direct or indirect membership. Either VolumeId or VolumeName has To be specified. If VolumeId is specified then VolumeName is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DfmMetadataField">
                <xsd:annotation>
                    <xsd:documentation>Named field in the metadata.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="FieldName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the metadata field. Field names are up To 255 characters in Length and are case- insensitive.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FieldValue" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Arbitrary, user-defined data expressed as a string. The string is opaque To the server and must not exceed 16384 (16k) characters in Length.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DrState">
                <xsd:annotation>
                    <xsd:documentation>Disaster recovery states of a Dataset. Possible Values are: &lt;ul&gt; &lt;li&gt; "ready": The Dataset is prepared To fail over. &lt;li&gt; "failing_over": The Dataset is in the process of failing over. Eventually, the state of the Dataset will change To either "failed_over" or "failover_error". &lt;li&gt; "failed_over": The Dataset has failed over. The primary data is now considered unavailable and the mirror relationships From the primary To the DR node have been broken. &lt;li&gt; "failover_error": The Dataset attempted To fail over but encountered an Error. User intervention is required To change the state To either "failed_over" or "ready". &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="DrStatus">
                <xsd:annotation>
                    <xsd:documentation>The DR Status has one of the following Values: &lt;ul&gt; &lt;li&gt; &lt;b&gt;normal&lt;/b&gt; : A DR Operation would likely succeed, and the amount of lost data would be within the Duration specified by the Lag warning threshold. &lt;li&gt; &lt;b&gt;warning&lt;/b&gt; : A DR Operation would likely succeed, but the amount of lost data would exceed that specified by the Policy's Lag warning threshold. &lt;li&gt; &lt;b&gt;Error&lt;/b&gt; : A DR Operation would likely fail, or would succeed but the amount of lost data would be unacceptable. &lt;/ul&gt; &lt;P&gt; The DR Status is computed based on all of the following: &lt;ul&gt; &lt;li&gt; The Resource Status of the Dataset's DR secondaries. The specific Condition that impacts the Resource Status is the availability of the secondary filers and Volumes. The Status will be Error if either is unavailable. &lt;li&gt; Whether there is sufficient space on the DR secondaries To meet the space guarantees of the primaries. &lt;li&gt; The existence and state of the relationships associated with the Dataset's disaster recovery capable connection. &lt;li&gt; Whether the relationships associated with the Dataset's DR-capable connection are within their Thresholds for Lag warnings and Errors. &lt;/ul&gt; &lt;P&gt; If the Dataset list iteration's output element &lt;b&gt;IsDrCapable&lt;/b&gt; is true, then this element appears in the output. Otherwise, if &lt;b&gt;IsDrCapable&lt;/b&gt; is false, this element does not appear in the output.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DrStatusProblem">
                <xsd:annotation>
                    <xsd:documentation>An explanation of a single problem that causes the Dataset not To have a &lt;b&gt;DrStatus&lt;/b&gt; of "normal".</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DrStatusDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A human-readable message describing the problem.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DrStatusSeverity" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Value is "warning" if the problem causes the data set To have a &lt;b&gt;DrStatus&lt;/b&gt; of at least "warning". Value is "Error" if the problem causes the Dataset To have a &lt;b&gt;DrStatus&lt;/b&gt; of at least "Error".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DryRunResult">
                <xsd:annotation>
                    <xsd:documentation>A Description of one Action and the predicted effects of taking that Action.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DryRunAction" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An Action the system would take.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DryRunEffect" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The predicted Effect of the Action.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DryRunReason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present only if Severity is Error or warning. Specifies possible reasons for the Error, warning. If there are no reasons To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DryRunReasonDetails" type="na:ArrayOfResultDetail">
                        <xsd:annotation>
                            <xsd:documentation>These details apply To the associated DryRunReason within the same DryRunResult. These offer additional information such as the reasons individual reasources may not have been selected for the DryRunAction in this same DryRunResult.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DryRunSeverity" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Severity of the DryRun Result. Possible Values are "information", "Error" or "warning".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DryRunSuggestion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present only if Severity is Error or warning. Specifies any suggestions To rectify the warnings, Errors. If there are no suggestions To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="InitiatorId">
                <xsd:annotation>
                    <xsd:documentation>For FCP Initiators, this is a string composed of 16 hexadecimal digits. For iSCSI Initiators, this is an initiator Name in the dotted-domain notation.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="JobInfo">
                <xsd:annotation>
                    <xsd:documentation>Job information of provisioning Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="JobId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of job started for the provisioning Request.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="LunIgroupInfo">
                <xsd:annotation>
                    <xsd:documentation>If the LUN has been mapped To any igroups or Hosts, this structure contains information relevant To the same.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IgroupInitiators" type="na:ArrayOfLunMappingInitiator">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Initiators and/or Hosts To which the LUN is mapped, if any.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IgroupLunId">
                        <xsd:annotation>
                            <xsd:documentation>If the LUN has been mapped To any initiator Groups, this field contains the ID generated by the storage system for the LUN. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="IgroupName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the igroup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IgroupOsType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the OS Type of the igroup. Possible Values: "solaris", "windows_gpt", "windows_2008", "windows", "hpux", "aix", "linux", "netware", "vmware". Here "windows_gpt" refers To Windows using GPT (GUID Partition Type) partitioning style and "windows_2008" refers To Windows Longhorn systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IgroupProtocol" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Protocol for the initiator Group. Possible Values: "fcp", "iscsi".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="LunMappingInitiator">
                <xsd:annotation>
                    <xsd:documentation>Specifies an initiator To map LUNs in the Dataset node To, and, optionally, the Host To which it belongs.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Hostname" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the Host which owns the initiator.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="InitiatorId" type="na:InitiatorId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies an initiator Id on a Host To which a LUN should be mapped.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="MigrationStatus">
                <xsd:annotation>
                    <xsd:documentation>Migration Status for an ongoing vFiler Unit migration. Possible Values: "in_progress", "migrating", "migrated", "migrated_with_errors", "migrate_failed", "rolled_back", "rolled_back_with_errors".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="MissingMemberInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one missing member of a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AggregateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Aggregate To which the member belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Aggregate To which the member belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CifsShareNames" type="na:ArrayOfCifsShareName">
                        <xsd:annotation>
                            <xsd:documentation>List of share names for accesing the storage container (volume/qtree) when access Protocol of storage set is "CIFS" or "Mixed". Example \\server\sharename.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DeletedTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>The time and date when the object was deleted.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Host To which the member belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Hostname" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host To which the member belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the missing member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the missing member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the missing member. Possible Values are 'Volume', 'Qtree'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name by which the storage container(volume/qtree) has been exported, when access Protocol of storage set is "NFS" or "Mixed". The Volume or Qtree can be exported with a different Path From its physical Path on the Filer (with -actual Option in the NFS export rule. Ex "/vol/myvol/myqtree" can be exported as "myexport") if not this will be same as full Path of the container.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QuotaHardLimit">
                        <xsd:annotation>
                            <xsd:documentation>The hard limit on the amount of space a user can use in kilobytes. Range: [1..2^63-1] Valid only for Qtree Members.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QuotaSoftLimit">
                        <xsd:annotation>
                            <xsd:documentation>The soft limit on the amount of space a user can use in kilobytes. Range: [1..2^63-1] Valid only for Qtree Members.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceGuarantee" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The space guarantee setting for a Volume member. Possible Values are "none," "file," or "Volume." Valid only for Volume Members.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TotalSpace">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Total capacity of the Dataset member, in kilobytes. Range: [1..2^63-1] Valid only for Volume Members.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="NfsExportHost">
                <xsd:annotation>
                    <xsd:documentation>Specifies a single Host or all-hosts. A Host can be a Host Name (DNS Name), an IP Address, a subnet or a domain Name. If an 'all-hosts' entry is present, all other Host Name entries must be negated.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Hostname" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies a single Host Name entry. A Host Name may be a DNS Name, an IP Address, a subnet (specified as &amp;lt;subnet Address&amp;gt;/&amp;lt;prefix Length&amp;gt; i.e. CIDR notation or '[network] &amp;lt;subnet-address&amp;gt; [netmask] &amp;lt;Netmask&amp;gt;'), a domain, or a workgroup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAnException" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies that the rule does not apply To this Host. Should be used when it is required To grant permissions To Hosts in a subnet or a domain or all Hosts excluding some. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="NfsExportRules">
                <xsd:annotation>
                    <xsd:documentation>Specifies the NFS security configuration Options provided by Data ONTAP operating system.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AnonymousAccessUser">
                        <xsd:annotation>
                            <xsd:documentation>If the client accessing the export is not present in the root access list for the export, the effective user for root is the Value specified for this field. Default Value is 65534 which maps To user nobody. It could be an integer Range: [0..65534] or a user Name not more than 255 characters.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="65534"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DisableSetuid" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, causes the server file system To ignore attempts To enable the setuid or setgid mode bits. Default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsReadonlyForAllHosts" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies that all Hosts receive read-only permissions on nfs exports in this Dataset node. Equivalent To specifying "ro" on the Filer. Default Value is false. If true, IsReadwriteForAllHosts must be false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsReadwriteForAllHosts" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies that all Hosts receive read-write permissions on nfs exports in this Dataset node. Equivalent To specifying "rw" on the Filer. Default Value is false. If true, IsReadonlyForAllHosts must be false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportRoHosts" type="na:ArrayOfNfsExportHost">
                        <xsd:annotation>
                            <xsd:documentation>A list of Hosts with read-only permissions on exports in this Dataset node. If a non empty list of NfsExportRoHosts is present along with IsReadonlyForAllHosts as true, then ZAPI will throw an Error.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportRootHosts" type="na:ArrayOfNfsExportHost">
                        <xsd:annotation>
                            <xsd:documentation>A list of Hosts with the root user having read-only or read-write permissions on exports in this Dataset node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsExportRwHosts" type="na:ArrayOfNfsExportHost">
                        <xsd:annotation>
                            <xsd:documentation>A list of Hosts with read-write permissions on exports in this Dataset node. If a non empty list of NfsExportRwHosts is present along with IsReadwriteForAllHosts as true, then ZAPI will throw an Error.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsSecurityFlavors" type="na:ArrayOfNfsSecurityFlavor">
                        <xsd:annotation>
                            <xsd:documentation>List of strings specifying the security flavors supported on exports in this Dataset node. If this field is not specified, the default Value of 'sys' is assumed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="NfsSecurityFlavor">
                <xsd:annotation>
                    <xsd:documentation>A security flavor To be applied on nfs exports. Possible Values are 'none', 'sys' (Unix Style), 'krb5' (Kerberos v5) , krb5i' (Kerberos v5 integrity) and 'krb5p' (Kerberos v5 privacy). Default Value is 'sys'.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ProtectionStatusJobDetail">
                <xsd:annotation>
                    <xsd:documentation>Details about a job that led To a ProtectionStatusProblem</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ProtectionStatusJobDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of what the job is trying To accomplish.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProtectionStatusJobId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the job. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ProtectionStatusJobStatus" type="na:DpJobOverallStatus">
                        <xsd:annotation>
                            <xsd:documentation>Overall Status of the job based on JobProgress and JobState.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProtectionStatusJobType" type="na:DpJobType">
                        <xsd:annotation>
                            <xsd:documentation>Type of data protection job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProtectionStatusProblem">
                <xsd:annotation>
                    <xsd:documentation>Information about a problem that resulted in the Dataset To not have &lt;b&gt;ProtectionStatus&lt;/b&gt; as "protected".</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ProtectionStatusDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A human readable Description of why ProtectionStatus was not found To be "protected". The Description may also contain suggestions that may be helpful in resolving the protection Status problem.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionStatusJobDetails" type="na:ArrayOfProtectionStatusJobDetail">
                        <xsd:annotation>
                            <xsd:documentation>Details about one or more Jobs that caused this ProtectionStatusProblem.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProtectionStatusName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A short Name for a Type of ProtectionStatus problem. This Name is intended To ease machine readability and is not expected To be displayed To a user. &lt;P&gt; Possible Values are &lt;ul&gt; &lt;li&gt; &lt;b&gt;uninitialized_no_dp_policy&lt;/b&gt; : No protection Policy is assigned. &lt;li&gt; &lt;b&gt;uninitialized_dp_policy_none&lt;/b&gt; : The Policy named 'No Protection' is assigned. &lt;li&gt; &lt;b&gt;uninitialized_no_data_to_protect&lt;/b&gt; : The Dataset does not contain any data To be protected. &lt;li&gt; &lt;b&gt;uninitialized_no_destination_storage&lt;/b&gt; : The Dataset does not contain storage for one or more destination nodes. &lt;li&gt; &lt;b&gt;uninitialized_no_relationships&lt;/b&gt; : The Dataset has no relationships in one or more connections. &lt;li&gt; &lt;b&gt;uninitialized_conforming&lt;/b&gt; : The Dataset is conforming. &lt;li&gt; &lt;b&gt;uninitialized_nonconformant&lt;/b&gt; : The Dataset is not in a conformant state. &lt;li&gt; &lt;b&gt;suspended&lt;/b&gt; : Dataset is suspended so no protection schedules will create backup versions in this state. &lt;li&gt; &lt;b&gt;uninitialized_single_node_no_backups&lt;/b&gt; : Dataset has one node and no Backups have finished &lt;li&gt; &lt;b&gt;no_backup_version&lt;/b&gt; : The multi-node Dataset does not have any backup versions. &lt;li&gt; &lt;b&gt;uninitialized_application_dataset&lt;/b&gt; : Application Dataset requires at least one backup Version. &lt;li&gt; &lt;b&gt;failed_baseline&lt;/b&gt; : At least one initial baseline data transfer failed To create a relationship. &lt;li&gt; &lt;b&gt;failed_local_backup&lt;/b&gt; : Local Backups failed on the primary node. &lt;li&gt; &lt;b&gt;failed_backup_job&lt;/b&gt; : One or more backup Jobs has failed. &lt;li&gt; &lt;b&gt;failed_mirror_job&lt;/b&gt; : One or more mirror copy Jobs has failed. &lt;li&gt; &lt;b&gt;lag_warning_local_backup&lt;/b&gt; : The most recent local backup (Snapshot copy) on the primary node is older than the threshold setting permits. &lt;li&gt; &lt;b&gt;lag_warning_since_last_backup&lt;/b&gt; : The time since the last successful backup job exceeds the Lag warning threshold. &lt;li&gt; &lt;b&gt;lag_warning_since_last_mirror&lt;/b&gt; : The time since the last successful mirror copy job exceeds the Lag warning threshold. &lt;li&gt; &lt;b&gt;lag_error_local_backup&lt;/b&gt; : The most recent local backup (Snapshot copy) on the primary node is older than the threshold setting permits. &lt;li&gt; &lt;b&gt;lag_error_since_last_backup&lt;/b&gt; : The time since the last successful backup job exceeds the Lag Error threshold. &lt;li&gt; &lt;b&gt;lag_error_since_last_mirror&lt;/b&gt; : The time since the last successful mirror copy job exceeds the Lag Error threshold. &lt;/ul&gt; &lt;P&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProvisionMemberComment">
                <xsd:annotation>
                    <xsd:documentation>One comment field To fill in as part of the Request</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CommentFieldNameOrId" type="na:CommentFieldNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the comment field.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CommentValue" type="na:CommentValue">
                        <xsd:annotation>
                            <xsd:documentation>Value of the comment field. An empty string can be used To unset the Value of the comment field for this object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProvisionMemberRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details specific To the 'provision_member' Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Comments" type="na:ArrayOfProvisionMemberComment">
                        <xsd:annotation>
                            <xsd:documentation>Comment Values To assign To the newly provisioned storage object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CreateNewVfiler" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True, if new vFiler Unit needs To be created during provisioning. The provisioned storage container is then moved To the vFiler Unit. This input is applicable only in the context of ResourcepoolMemberListInfoIterStart zapi and RunProvisioningChecks is specified as 'true'. This input is ignored in DatasetProvisionMember and StorageServiceDatasetProvision zapi. The default Value is 'false'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetExportInfo" type="na:DatasetExportInfo">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the NAS or SAN export settings for the the provisioning member. Member level export settings cannot be specified, if export settings have been configured at node level.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the provisioning Request. The Length of this string cannot be more than 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InitialSnapshotSpace">
                        <xsd:annotation>
                            <xsd:documentation>Applicable when provisioning Members in SAN data sets (i.e. Datasets associated with provisioning Policy of Type 'san'). Specify the initial disk space in bytes that needs To be allocated upfront for Snapshot copies of the member. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumDataSize">
                        <xsd:annotation>
                            <xsd:documentation>Maximum storage space for the Dataset member. Applicable when provisioning Members in NFS data sets (i.e. Datasets associated with provisioning Policy of Type 'nas' and export over 'NFS' Protocol). Storage clients can write data up To this limit if the containing Aggregate has space. The Value is specified in bytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumSnapshotSpace">
                        <xsd:annotation>
                            <xsd:documentation>Applicable when provisioning Members in SAN data sets (i.e. Datasets associated with provisioning Policy of Type 'san'). Specify the Maximum disk space in bytes for the Snapshot copies of the member. Once the space consumed by Snapshot copies reaches this Value, further Snapshot copies will fail. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage container. If this is a NAS Dataset, i.e the provisioning Policy associated with the primary node of the Dataset is of Type 'nas', then this Name corresponds To the Qtree created. If this is a SAN Dataset, i.e the provisioning Policy associated with the primary node of the Dataset is of Type 'san', then this Name corresponds To the LUN or Volume that will be provisioned as part of this Request. The Length of this string cannot be more than 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OnlineMigration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether pre checks related To online migration has To be performed on the storage system during provisioning. This input is applicable only in the context of ResourcepoolMemberListInfoIterStart API and RunProvisioningChecks is specified as true and either CreateNewVfiler is true or VfilerNameOrId is specified. This input is ignored in StorageServiceDatasetProvision and DatasetProvisionMember APIs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the provisioning Policy used with this Request. Ignored for DatasetProvisionMember and StorageServiceDatasetProvision and is used only when listing provisioning requests and Jobs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the provisioning Policy used with this Request. Present only if the Request Type is 'provision_member'. Ignored for DatasetProvisionMember and StorageServiceDatasetProvision and is used only when listing provisioning requests and Jobs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourceNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the Resource object From which storage space will be provisioned. valid types of Objects are:- &lt;UL&gt; &lt;LI&gt; Filer &lt;LI&gt; Aggregate &lt;/UL&gt; The Filer or Aggregate specified should belong To the Resource pool(s) associated with primary node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Size">
                        <xsd:annotation>
                            <xsd:documentation>Amount of storage space for data. Whether this space has To allocated on demand or reserved upfront From an Aggregate in Resource pool is decided based on the provisioning Policy settings. The Value is specified in bytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or Id of the vFiler Unit, if specified the newly provisioned Dataset member will be moved To the specified vFiler Unit and accessed via the vFiler Unit's IP addresses. Ignored for StorageServiceDatasetProvision.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ReplaceResult">
                <xsd:annotation>
                    <xsd:documentation>A Description of one replace Action.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the data protection Policy node associated with the secondary Volume or Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the object replaced. Possible Values are "Volume", or "Qtree".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NewPrimaryMemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the new primary member replacing the old. NewPrimaryMemberId is omitted if the ReplaceStatus is "not_found".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NewPrimaryMemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the new primary member replacing the old. NewPrimaryMemberName is omitted if the ReplaceStatus is "not_found".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OldPrimaryMemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the primary member that needs To be replaced. OldPrimaryMemberId is omitted if the ReplaceStatus is "not_required".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OldPrimaryMemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the primary member that was replaced. OldPrimaryMemberName is omitted if the ReplaceStatus is "not_required".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReplaceStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Possible Values are "not_found", "not_required", or "replaced". "not_found" is returned if a replacement primary was not found. "not_required" is returned if the primary did not need To be replaced. "replaced" is returned if the primary was successfully replaced.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SecondaryMemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the secondary member whose primary member needs To be replaced.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SecondaryMemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Displayed Name of the secondary member whose primary member needs To be replaced.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="RequiresNonDisruptiveRestore">
                <xsd:annotation>
                    <xsd:documentation>When this attribute is set, the Dataset is configured To allow LUNs To be restored From Backups in such a way that the Host need not detach From the LUN. &lt;P&gt;Configuring the Dataset for non-disruptive restore does not guarantee that all backup Instances may be restored non-disruptively. It only applies To backup Instances reached through a &lt;b&gt;Backup&lt;/b&gt; connection. The caller must check the &lt;b&gt;SupportsNonDisruptiveRestore&lt;/b&gt; output element returned by &lt;b&gt;dp-backup-list-info-next&lt;/b&gt; To tell whether a given backup Instance can be restored non-disruptively. &lt;P&gt;Specifically, when this attribute is set: &lt;ul&gt; &lt;li&gt;All storage systems must be running ONTAP 7.3 or later. &lt;li&gt;Protection Manager must have working ZAPI credentials for all storage systems in use by this Dataset. &lt;li&gt;All &lt;b&gt;Backup&lt;/b&gt; connections will be implemented using SnapVault, not Qtree SnapMirror. &lt;li&gt;All non-primary storage systems used by the data set must have a SnapVault Secondary License. &lt;/ul&gt; &lt;P&gt;If any of these constraints is not met when adding a member To the Dataset, the Dataset will not be in conformance and the addition will generate conformance Errors. Addition of Members with ONTAP Version less than 7.3 To the primary node of the Dataset will fail with Errors. &lt;P&gt;&lt;b&gt;requires-nondisruptive-restore&lt;/b&gt; may only be specified if: &lt;ul&gt; &lt;li&gt; No &lt;b&gt;Backup&lt;/b&gt; connection in the protection Policy used by the Dataset is DR capable (i.e. the &lt;b&gt;IsDrCapable&lt;/b&gt; attribute may not be set for any &lt;b&gt;Backup&lt;/b&gt; connection of the Policy). &lt;li&gt; The Dataset must be an application Dataset. &lt;/ul&gt; Thus, if &lt;b&gt;RequiresNonDisruptiveRestore&lt;/b&gt; is specified as true, &lt;b&gt;IsApplicationData&lt;/b&gt; must also be present and true. Callers may check the &lt;b&gt;non-disruptive-restore-compatible&lt;/b&gt; output element of the &lt;b&gt;dp-policy-list-info-iter-next&lt;/b&gt; API To tell which policies may be applied To Datasets requiring non-disruptive restores.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:boolean"/>
            </xsd:simpleType>
            <xsd:complexType name="ResizeMemberRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of the resize Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="MaximumCapacity">
                        <xsd:annotation>
                            <xsd:documentation>Specify the new Maximum capacity Value for a flexbile Volume. The Value is specified in bytes. Valid only if the Filer To which the Volume belongs is of ONTAP Version 7.1 or above only. This input is valid only if MemberId or MemberName refers To a flexible Volume. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Dataset member on which the resize Operation has To be carried out. This member can be either a flexible Volume or a Qtree which is a member of the effective primary node of the Dataset either through direct or indirect membership.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset member on which the resize Operation has To be carried out. This member can be either a flexible Volume or a Qtree which is a member of the effective primary node of the Dataset either through direct or indirect membership. Either MemberId or MemberName has To be specified. If MemberId is specified then MemberName is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NewSize">
                        <xsd:annotation>
                            <xsd:documentation>Specify the new Size of the Dataset member. The Value is specified in bytes. If the member is a Volume, this corresponds To the Size of the Volume. If the member is a Qtree, this corresponds To hard disk quota limit for the Qtree. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapReserve">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the percetage of space set aside for Snapshots in a Volume. The Value is specified in percentage of the Total Size of the Volume. This input is valid only if MemberId or MemberName refers To a flexible Volume. Range: [0..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResultDetail">
                <xsd:annotation>
                    <xsd:documentation>Details on a specific Action that adds information intended To explain more about a higher level Result. For example, the detail may be used To explain a DryRun Result by explaining why resources were not selected.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Action" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An Action or check the system had taken.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Effect" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Result of the Action or check.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Reason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies possible reasons for the this Result. If there are no reasons To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Severity" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Severity of the Result Result. Possible Values are "information", "Error" "warning". It is normal for "information" To be used To explain why a Resource was not selected.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Suggestion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies any suggestions To rectify the information, warnings, Errors. If there are no suggestions To specify, this element will not be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="SpaceCondition">
                <xsd:annotation>
                    <xsd:documentation>Represents a space Condition of a Dataset member.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Condition" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Space Condition. Possible Values: &lt;ul&gt; &lt;li&gt;"volume-used-vs-size-above-nearly-full" Used space of the Volume vs Volume usable data space has crossed nearly full threshold specified in the Policy &lt;li&gt;"volume-used-vs-size-above-full" Used space of the Volume vs Volume usable data space has crossed full threshold specified in the Policy &lt;li&gt;"volume-used-vs-maximum-size-above-nearly-full" Used space of the Volume vs Volume usable Maximum data space has crossed nearly full threshold specified in the Policy &lt;li&gt;"volume-used-vs-maximum-size-above-full" Used space of the Volume vs Volume usable Maximum data space has crossed full threshold specified in the Policy &lt;li&gt;"qtree-used-vs-quota-above-nearly-full" Qtree used space vs Qtree hard limit has crossed nearly full threhsold specified in Policy &lt;li&gt;"qtree-used-vs-quota-above-full" Qtree used space vs Qtree hard limit has crossed full threhsold specified in Policy &lt;li&gt;"volume-snapshot-used-above-full-threshold" Snapshot used space in the Volume has crossed volSnapshotFullThreshold specified in Operations Manager. &lt;li&gt;"volume-no-next-snapshot" Next Snapshot is not possible in the Volume due To space contraints &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Reason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Reason for this space Condition. This can be a Maximum of 1024 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Severity" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Severity of this space Condition. Possible Values are: "unknown", "ok", "warning", "Error"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Suggestion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Possible Action that can be taken To correct this. This can be a Maximum of 1024 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="SpaceInfo">
                <xsd:annotation>
                    <xsd:documentation>Specifies the Total, available and used space in a Dataset member, the space Status and various space related conditions of the member.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AvailableSpace">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the space available in the Dataset member, in bytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceConditions" type="na:ArrayOfSpaceCondition">
                        <xsd:annotation>
                            <xsd:documentation>Various space conditions of a Dataset member. Present only if the SpaceStatus of the Dataset member is one of 'Error' or 'warning'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceStatus" type="na:SpaceStatus">
                        <xsd:annotation>
                            <xsd:documentation>Space Status of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TotalSpace">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Total capacity of the Dataset member, in bytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="UsedSpace">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the capacity used in the Dataset member, in bytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="SpaceStatus">
                <xsd:annotation>
                    <xsd:documentation>Worst space Status of a Dataset or a member. Possible Values are: 'unknown', 'ok', 'warning', 'Error'</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="UndedupeMemberRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of the undedupe member Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of a Volume member of a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of a Volume member of the Dataset. Either VolumeId or VolumeName has To be specified. If VolumeId is specified then VolumeName is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ApiStat">
                <xsd:annotation>
                    <xsd:documentation>Statistics about a single server API</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ApiName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the API</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CallCount">
                        <xsd:annotation>
                            <xsd:documentation>The number of times the API has been invoked. Range:[1..2^32-1)]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="4294967295"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="CpuMaxTime">
                        <xsd:annotation>
                            <xsd:documentation>Maximum CPU time spent during the API execution Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="CpuMeanTime">
                        <xsd:annotation>
                            <xsd:documentation>Mean CPU time spent during the API execution Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="CpuMinTime">
                        <xsd:annotation>
                            <xsd:documentation>Minimum CPU time spent during the API execution Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DbMaxCalls" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of database operations by this API Range:[0..2^32-1)]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DbMaxTime">
                        <xsd:annotation>
                            <xsd:documentation>Maximum database time spent during the API execution Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DbMeanCalls" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Mean number of database operations by this API Range:[0..2^32-1)]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DbMeanTime">
                        <xsd:annotation>
                            <xsd:documentation>Mean database time spent during the API execution Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DbMinCalls" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Minimum number of database operations by this API Range:[0..2^32-1)]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DbMinTime">
                        <xsd:annotation>
                            <xsd:documentation>Minimum database time spent during the API execution Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="MaxTime">
                        <xsd:annotation>
                            <xsd:documentation>Maximum execution time for the API. Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="MeanTime">
                        <xsd:annotation>
                            <xsd:documentation>Mean execution time for the API. Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="MinTime">
                        <xsd:annotation>
                            <xsd:documentation>Minimum execution time for the API. Range:[0..2^63-1]Units: Wall-clock milliseconds</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ChildCount">
                <xsd:annotation>
                    <xsd:documentation>Count of children of one Type for the specified object. An element of this Type is returned if Count is 1 or more.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Count">
                        <xsd:annotation>
                            <xsd:documentation>Number of children of this Type. &lt;p&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Object Type of the child object. Valid Values are: 'Vfiler', 'Aggregate' 'Volume', 'Qtree', 'Lun' and 'disk'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DfmDiagCounterGroup">
                <xsd:annotation>
                    <xsd:documentation>Descriptive diagnostic information about a counter Group.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="GroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the counter Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Histogram" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Comma delimited list of counter Values.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the monitored Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LastUpdated" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp of the last time this counter Group was monitored (seconds since 1/1/1970).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DirectoryInfo">
                <xsd:annotation>
                    <xsd:documentation>Lists the information about DFM Directories. These Directories include Performance Advisor data Directory, Database Backup Directory, Data Export Directory and Reports Archival Directory.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FileCount">
                        <xsd:annotation>
                            <xsd:documentation>Number of files in the Directory. This field is returned only for Performance Data Directory. Range:[0..2^31-1] This field is not returned if the file Count of the Directory is unknown.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Directory. For example, "opt/NTAPdfm/perfdata".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Size">
                        <xsd:annotation>
                            <xsd:documentation>Size of the Directory in bytes. Range:[0..2^63-1] This field is not returned if the Size is unknown.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the DFM Directory. Possible Values: "performance_data", "database_backup", "reports_archive" and "data_export".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="Feature">
                <xsd:annotation>
                    <xsd:documentation>Information about a licensed Feature.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsLicenseExpired" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the License for the Feature has expired. Returned only when the License has expired. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Feature</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Summary" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Information about the License for the Feature such as Status, Type and expiration date.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="MonitorName">
                <xsd:annotation>
                    <xsd:documentation>Specifies Name of a monitor To be scheduled To run. Possible Values are as follows: &lt;UL&gt; &lt;LI&gt;"agent" - refreshes agent information &lt;LI&gt;"cache" - refreshes net cache information &lt;LI&gt;"cluster_failover" - refreshes cluster fail over information &lt;LI&gt;"config_conformance" - checks a storage system's configuration for conformance &lt;LI&gt;"connectivity" - checks connectivity of a given Host &lt;LI&gt;"cpu" - refreshes cpu related information &lt;LI&gt;"disk_free_space" - refreshes disk free space of a Host &lt;LI&gt;"disk_status" - refreshes disk Status of a Host &lt;LI&gt;"env" - refreshes environmentals of a Host &lt;LI&gt;"fibre_channel" - refreshes fibre channel information &lt;LI&gt;"file_system" - refreshes file system information of Host &lt;LI&gt;"interface_status" - refreshes network related information of a Host &lt;LI&gt;"License" - collects License information From Hosts &lt;LI&gt;"Lun" - collects Lun information From Host &lt;LI&gt;"ndmp" - refreshes ndmp ping Timestamp &lt;LI&gt;"ndmp_credentials" - refreshes ndmp credentials Timestamp &lt;LI&gt;"ops" - refreshes file system Operation Count of a Host &lt;LI&gt;"ping" - refreshes ping Status of a Host &lt;LI&gt;"Qtree" - refreshes Qtree data using snmp &lt;LI&gt;"qtree_xml" - refreshes Qtree data using zapi &lt;LI&gt;"san" - refresh SAN information of a Host Agent &lt;LI&gt;"share" - refreshes shares information of a Host &lt;LI&gt;"snapmirror" - refreshes snap mirror information &lt;LI&gt;"Snapshot" - refreshes snap shot information &lt;LI&gt;"snapvault" - refreshes snap vault information &lt;LI&gt;"snapvault_dir" - refreshes Directories on OSSV Hosts; monitor applicable only for OSSV Hosts &lt;LI&gt;"srm" - refresh SRM information of a Host Agent &lt;LI&gt;"Status" - refreshes global Status of a Host &lt;LI&gt;"sysinfo" - refreshes system information of a Host &lt;LI&gt;"userquota" - refreshes user quota information of a Host &lt;LI&gt;"Vfiler" - refreshes Vfiler information of a hosting storage system &lt;/UL&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ObjStatusInfo">
                <xsd:annotation>
                    <xsd:documentation>Status of the dfm object</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the dfm object. This corresponds To an entry in the input "Objects" array.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectPerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Status for the object based on performance Events If the object is not present or is ambiguous, the Status is set To "Unknown"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Status for the object based on all Events If the object is not present or is ambiguous, the Status is set To "Unknown"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ParentDataset">
                <xsd:annotation>
                    <xsd:documentation>Information about one Dataset. A parent Dataset is returned if the authenticated user has DFM.Database.Read Privilege on the Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Id" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Dataset</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ParentGroup">
                <xsd:annotation>
                    <xsd:documentation>Information about one Resource Group. A parent Group is returned if the user has DFM.Database.Read Privilege on the Group.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="FullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Group</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Id" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Group</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Group</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ParentObject">
                <xsd:annotation>
                    <xsd:documentation>Information about one parent object. A parent object is returned if the authenticated user has DFM.Database.Read Privilege on that object.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="FullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the parent</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Id" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the parent</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the parent</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Object Type of the parent object. Valid Values are: 'Filer', 'Vfiler', 'Aggregate' 'Volume' and 'Qtree'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ParentResourcepool">
                <xsd:annotation>
                    <xsd:documentation>Information about one Resource pool. A parent Resource pool is returned if the authenticated user has DFM.Database.Read Privilege on that Resource pool.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Id" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Resource pool</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="Plugin">
                <xsd:annotation>
                    <xsd:documentation>Installed plugins.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="PluginType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the Plugin. The possible types are, 'filer-config' for storage system plugins, 'netcache-config' for NetCache plugins and 'unknown' for unknown Type plugins.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProductVersion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>product and Version of the product</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SpecialBuild" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>information about the build of the Plugin used</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResourcePropertyValues">
                <xsd:annotation>
                    <xsd:documentation>Provides information on Resource Properties and the possible Values</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ResourceProperty" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Resource property Name</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Values" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A comma seperated list of possible Values for the Resource Properties Maximum Length of 2048 characters</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DailyInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a daily schedule. May only be used in a daily schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ItemId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the daily item within the schedule. Ignored for dfm-schedule-create/modify and Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartHour">
                        <xsd:annotation>
                            <xsd:documentation>Start hour of the daily schedule. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartMinute">
                        <xsd:annotation>
                            <xsd:documentation>Start minute of the daily schedule. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HourlyInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of an hourly schedule. May only be used in a daily schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EndHour">
                        <xsd:annotation>
                            <xsd:documentation>End hour of the hourly schedule. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="EndMinute">
                        <xsd:annotation>
                            <xsd:documentation>End minute of the hourly schedule. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Frequency">
                        <xsd:annotation>
                            <xsd:documentation>Number of minutes between each schedule. Range: [5..1440]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="5"/>
                                <xsd:maxInclusive value="1440"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ItemId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the hourly item within the schedule. Ignored for dfm-schedule-create/modify and Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartHour">
                        <xsd:annotation>
                            <xsd:documentation>Start hour of the hourly schedule. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartMinute">
                        <xsd:annotation>
                            <xsd:documentation>Start minute of the hourly schedule. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="MonthlyInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a monthly schedule. May only be used in a monthly schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DayOfMonth">
                        <xsd:annotation>
                            <xsd:documentation>If DayOfMonth is 29, 30, or 31, it will be interpretted as the last Day of the Month for Months with fewer than that many Days. if DayOfMonth is set, then both WeekOfMonth and DayOfWeek must not be set. Range: [1..31]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="31"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DayOfWeek">
                        <xsd:annotation>
                            <xsd:documentation>Day of week for the schedule. If DayOfWeek is set, then WeekOfMonth must also be set and DayOfMonth must not be set. Range: [0..6] (0 = "Sun")</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="6"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ItemId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the monthly item within the schedule. Ignored for dfm-schedule-create/modify and Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartHour">
                        <xsd:annotation>
                            <xsd:documentation>Start hour of the monthly schedule. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartMinute">
                        <xsd:annotation>
                            <xsd:documentation>Start minute of the monthly schedule. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="WeekOfMonth">
                        <xsd:annotation>
                            <xsd:documentation>A Value of 5 indicates the last week of the Month. If WeekOfMonth is set, then DayOfWeek must also be set and DayOfMonth must not be set. Range: [1..5]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="5"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="MonthlySubscheduleInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a monthly subschedule. May only be used in a monthly schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="SubscheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the subschedule To be used. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SubscheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the subschedule To be used Ignored for dfm-schedule-create/modify. Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ScheduleAssignee">
                <xsd:annotation>
                    <xsd:documentation>Description of a DFM object using the schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AssigneeFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of a DFM object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AssigneeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identification number of a DFM object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AssigneeType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of DFM object. Possible Values are: 'dp_policy', 'dp_schedule', 'dfm_schedule' and 'report_schedule'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ScheduleContentInfo">
                <xsd:annotation>
                    <xsd:documentation>Detailed schedule contents. A schedule can be a daily, weekly, or monthly schedule. A daily schedule may include both multiple recurring hourly schedules (HourlyList element) and/or individual non-recurring daily schedules (DailyList element). A weekly schedule may include multiple references To daily schedules To be run on specific Days of the week (WeeklySubscheduleList element) and/or individual non-recurring weekly schedules (WeeklyList element). A monthly schedule may include multiple non-recurring monthly schedules (MonthlyList element). In addition, a monthly schedule may include a single reference To either a daily schedule or a montly schedule, not both. User may only specify one MonthlySubscheduleInfo element in the MonthlySubscheduleList.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DailyList" type="na:ArrayOfDailyInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of daily schedules. May only be used in a daily schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HourlyList" type="na:ArrayOfHourlyInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of hourly schedules. May only be used in a daily schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsModifiable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If &lt;b&gt;false&lt;/b&gt;, this schedule is one of the sample schedules that is created at installation time, therefore it may not be modified, renamed or destroyed. If &lt;b&gt;true&lt;/b&gt;, it is not one of the sample schedules, therefore it may be modified, renamed or destroyed. &lt;b&gt;IsModifiable&lt;/b&gt; always appears in the output. It is not possible To use it as input.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MonthlyList" type="na:ArrayOfMonthlyInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of monthly schedules. May only be used in a monthly schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MonthlySubscheduleList" type="na:ArrayOfMonthlySubscheduleInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of monthly sub-schedules used by the schedule. May only be used in a monthly schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScheduleCategory" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the category of the schedule. Possible Values are: 'dfm_schedule', 'dp_schedule'. The default Value is 'dp_schedule'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScheduleDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the schedule. It may contain From 0 To 255 characters. The &lt;b&gt;Description&lt;/b&gt; always appears in the output. If the Description is omitted, then the default Value is the empty string "".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the schedule. Ignored for DfmScheduleCreate. Required for all other calls. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the schedule. May not be numeric.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ScheduleType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of schedule. Possible Values are: 'daily', 'weekly', 'monthly'. Note that the Type cannot be changed once the schedule is created. User has To delete the schedule before creating a new schedule using the same Name with different Type</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="WeeklyList" type="na:ArrayOfWeeklyInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of weekly schedules. May only be used in a weekly schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="WeeklySubscheduleList" type="na:ArrayOfWeeklySubscheduleInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of weekly sub-schedules used by the schedule. May only be used in a weekly schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ScheduleIdInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a Id list</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Id" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the schedule. May not be numeric.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of schedule. Possible Values are: daily, weekly, monthly</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="WeeklyInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a weekly schedule. May only be used in a weekly schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DayOfWeek">
                        <xsd:annotation>
                            <xsd:documentation>Day of week for the schedule. Range: [0..6] (0 = "Sun")</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="6"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ItemId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the weekly item within the schedule Ignored for dfm-schedule-create/modify and Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartHour">
                        <xsd:annotation>
                            <xsd:documentation>Start hour of the weekly schedule. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartMinute">
                        <xsd:annotation>
                            <xsd:documentation>Start minute of the weekly schedule. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="WeeklySubscheduleInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a weekly subschedule. May only be used in a weekly schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EndDayOfWeek">
                        <xsd:annotation>
                            <xsd:documentation>End Day To be applied To the schedule being used. Range: [0..6] (0 = "Sun")</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="6"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ItemId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the use Type within the schedule. Ignored for dfm-schedule-create/modify and Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartDayOfWeek">
                        <xsd:annotation>
                            <xsd:documentation>Start Day To be applied To the schedule being used. Range: [0..6] (0 = "Sun")</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="6"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SubscheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the subschedule To be used. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SubscheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the subschedule To be used Ignored for dfm-schedule-create/modify. Required for all other calls. Will be presented in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="EmailAddressList">
                <xsd:annotation>
                    <xsd:documentation>A list of email addresses. If more than one email Address is specified, the addresses must be seperated by a ','. Spaces (and other white space) are not allowed, either between addresses or in them. Unprintable characters are also invalid. The list may contain up To 255 characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="FileSystemBlockType">
                <xsd:annotation>
                    <xsd:documentation>Block Type of the file system. The Volumes on both the Source and destination sides of a SnapMirror relationship must be of the same block Type. Volumes contained in a larger parent agregate may have a BlockType of 64_bit. For upgraded systems it is possible that this Value may be unknown until the system can determine the BlockType. Possible Values are: &lt;ul&gt; &lt;li&gt; 32_bit &lt;li&gt; 64_bit &lt;li&gt; unknown &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="KeyValuePair">
                <xsd:annotation>
                    <xsd:documentation>The key/value for a generic object attribute.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Key" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Key of the generic object attribute</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Value of the generic object attribute</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ObjFullName">
                <xsd:annotation>
                    <xsd:documentation>Full Name of a DFM object. This typedef is an alias for the builtin ZAPI Type &lt;b&gt;string&lt;/b&gt;. An object full Name conforms To all the rules of an ObjName, except that the full Name may be up To 255 characters long. &lt;P&gt; DFM creates full names by concatenating an object Name with any parent object names, so as To create a unique Name for an object. The format of full names is as follows: &lt;ul&gt; &lt;li&gt; &lt;B&gt;Host&lt;/B&gt; full names are the either the fully-qualified domain Name or the IP Address of the Host. &lt;li&gt; &lt;B&gt;Aggregate&lt;/B&gt; full names are the Host Name and the Aggregate Name, separated by a colon, e.g. &lt;I&gt;Hostname:aggr0&lt;/I&gt;. &lt;li&gt; &lt;B&gt;Volume&lt;/B&gt; full names are the Host Name and the Volume Name, separated by ":/", e.g. &lt;I&gt;Hostname:/volume&lt;/I&gt;. Note this does not include "/vol". Volume and Aggregate full names are distinguished by the presence of a forward slash after the colon. &lt;li&gt; &lt;B&gt;Qtree&lt;/B&gt; full names are the containing Volume full Name and the Qtree Name, separated by a slash, e.g. &lt;I&gt;Hostname:/volume/qtree&lt;/I&gt;. The data not contained by any Qtree may be represented by "-", e.g. &lt;I&gt;Hostname:/volume/-&lt;/I&gt;. &lt;li&gt; &lt;B&gt;Lun Path&lt;/B&gt; full names are either a Volume or Qtree full Name and the LUN Path, separated by a slash, e.g. &lt;I&gt;Hostname:/volume/LUN&lt;/I&gt; or &lt;I&gt;Hostname:/volume/qtree/LUN&lt;/I&gt;. &lt;li&gt; &lt;B&gt;Network&lt;/B&gt; full names are a network Address block in CIDR format, e.g. &lt;I&gt;1.2.3.0/8&lt;/I&gt;. &lt;li&gt; &lt;B&gt;OSSV Directory&lt;/B&gt; full names are the OSSV Host Name and the OSSV Path, separated by a colon, e.g. &lt;I&gt;host-lnx:/usr/local&lt;/I&gt; or &lt;I&gt;host-w2k:c:/temp&lt;/I&gt; &lt;li&gt; &lt;I&gt;Include any others here...&lt;/I&gt; &lt;li&gt; &lt;B&gt;Initiator Group&lt;/B&gt; full names are Host Name and the initiator Group Name, separated by a colon, e.g. &lt;I&gt;Hostname:igroup&lt;/I&gt;. &lt;/ul&gt; &lt;P&gt; For any DFM object not listed above, the ObjName and ObjFullName are identical.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="ObjId">
                <xsd:annotation>
                    <xsd:documentation>Identification number (ID) for a DFM object. This typedef is an alias for the builtin ZAPI Type &lt;b&gt;integer&lt;/b&gt;. Object IDs are unsigned integers in the range [1..2^31 - 1]. In some contexts, an object ID is also allowed To be 0, which is interpreted as a null Value, e.g., a reference To no object at all. &lt;p&gt; The ID for a DFM object is always assigned by the system; the user is never allowed To assign an ID To an object. Therefore, an input element of Type &lt;b&gt;ObjId&lt;/b&gt; is always used To refer To an existing object by its ID. The ZAPI must specify the object's DFM object Type (e.g. Dataset, Host, DP Policy, etc.). Some ZAPIs allow the object To be one of several different types. &lt;p&gt; If the Value of an &lt;b&gt;ObjId&lt;/b&gt; input element does not Match the ID of any existing DFM object of the specified Type or types, then typically the ZAPI fails with Error code &lt;b&gt;EOBJECTNOTFOUND&lt;/b&gt;. A ZAPI may deviate From this general rule, for example, it may return a more specific Error code. In either case, the ZAPI specification must document its behavior.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:simpleType name="ObjName">
                <xsd:annotation>
                    <xsd:documentation>Name of a DFM object. This typedef is an alias for the built in ZAPI Type &lt;b&gt;string&lt;/b&gt;. An object Name must conform To the following format: &lt;ul&gt; &lt;li&gt; It must contain between 1 and 64 characters. &lt;li&gt; It may start with any character and may contain any combination of characters, except that it may not consist solely of decimal digits ('0' through '9'). &lt;li&gt; In some contexts, a Name may be the empty string (""), which is interpreted as a null Value, e.g., a reference To no object at all. &lt;/ul&gt; The behavior of a ZAPI when it encounters an Error involving an &lt;b&gt;ObjName&lt;/b&gt; input element depends on how the ZAPI uses the input element. Here are the general rules: &lt;ul&gt; &lt;li&gt; If the input Name element is used To create a new object with the given Name, or rename an existing object To that Name, and the Name does not conform To the above format, then the ZAPI fails with Error code &lt;b&gt;EINVALIDINPUTERROR&lt;/b&gt;. Note that because &lt;b&gt;EINVALIDINPUTERROR&lt;/b&gt; is such a common Error code, ZAPI specifications are not required To document cases when they may return it. &lt;li&gt; If the input Name element is used To refer To an existing object with that Name, and there is no object with that Name, then the ZAPI fails with Error code &lt;b&gt;EOBJECTNOTFOUND&lt;/b&gt;. Generally the ZAPI specification documents cases when it may return this Error code. &lt;/ul&gt; A ZAPI may deviate From these general rules, for example, it may return more specific Error codes. In such cases, the ZAPI specification must document its behavior. &lt;p&gt; If an input Name element is used To refer To an existing object, then the ZAPI specification must specify which DFM object Type (e.g. data set, Host, DP Policy, etc.) is allowed. Some ZAPIs allow the object To be one of several different types. See the Description of ObjFullName for examples of valid input formats. &lt;p&gt; Note that there is no requirement that all object names must be unique. However, the names for some specific types of Objects are constrained such that no two Objects of that Type may have the same Name. For example, this constraint applies To Datasets, DP schedules, and DP policies. This means that no two Datasets may have the same Name, but a Dataset may have the same Name as a DP schedule or DP Policy. &lt;p&gt; In general, object names are compared in a case-insensitive manner. This means that, for example, "MyObject" and "MYOBJECT" are considered To be the same Name for purposes of: creating new Objects, renaming existing Objects, or looking up an object by Name. On the other hand, ZAPIs that return an &lt;b&gt;ObjName&lt;/b&gt; generally do not change the capitalization at all. For example, if an object's Name has been set To "MyObject", then list iteration ZAPIs that return the object's Name return it as "MyObject" rather than "MYOBJECT" or "myobject". &lt;p&gt; ZAPIs that operate on &lt;b&gt;ObjName&lt;/b&gt; Values and do not follow these general rules about case sensitivity must document the rules that they do follow. &lt;p&gt; One important exception To these general rules is that Volumes, Qtrees, OSSV Directories, SRM Paths, Interfaces, FCP Targets and FC switch ports all have case-sensitive names. When looking up Objects of these types by Name, the case must Match the object Name.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="ObjNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or internal ID of a DFM object. This typedef is an alias for the builtin ZAPI Type &lt;b&gt;string&lt;/b&gt;. An &lt;b&gt;ObjNameOrId&lt;/b&gt; must contain between 1 and 64 characters, and must conform To one of the following formats: &lt;ul&gt; &lt;li&gt; It must have the format of an &lt;b&gt;ObjName&lt;/b&gt;, or &lt;li&gt; It must be the decimal numeric string form of a positive integer whose Value is in the range [1..2^31 - 1]. &lt;/ul&gt; Elements of Type &lt;b&gt;ObjNameOrId&lt;/b&gt; are used only as inputs To ZAPIs. The Value must Match either the Name or internal ID of an existing DFM object. The ZAPI must specify the object's DFM object Type (e.g. Dataset, Host, DP Policy, etc.). Some ZAPIs allow the object To be one of several different types. &lt;p&gt; If the format of an &lt;b&gt;ObjNameOrId&lt;/b&gt; input element does not conform, or the Value does not Match the Name or ID of an existing object, then generally the ZAPI documents that it fails with Error code &lt;b&gt;EOBJECTNOTFOUND&lt;/b&gt;. A ZAPI may return more specific Error codes. In such cases, the ZAPI specification must document its behavior. &lt;p&gt; If a ZAPI can accept a null Value (e.g. reference To no object at all) for such an element, then the element is declared &lt;b&gt;optional&lt;/b&gt;, and the absence of the input element represents a null Value.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="ObjStatus">
                <xsd:annotation>
                    <xsd:documentation>A Status Value which can be associated with a DFM object. This typedef is an alias for the builtin ZAPI Type &lt;b&gt;string&lt;/b&gt;. The Severity associated with an event has this Type.&lt;p&gt; Possible Values are: 'unknown', 'normal', 'information', 'unmanaged' 'warning', 'Error', 'critical', 'emergency'. &lt;ul&gt; &lt;li&gt;unknown: An object has an unknown Status when it transitions From one state To another. Ideally, an object will have this Status briefly. For example, when an object has been added, but not yet discovered. &lt;li&gt;normal: An object has normal Status when it is working within the Thresholds specified in DFM. &lt;li&gt;information: The information Events are normal occurrences on an object for which you can define alarms. &lt;li&gt;unmanaged: An object is considered To be unmanaged when the login and Password are not set for the storage system or agent. &lt;li&gt;warning: An object has the warning Status when an event related To the object occurred that an administrator should know about. The event will not cause Service disruption. &lt;li&gt;Error: An object has Error Status when it does not cause any Service disruption, but it may affect performance. &lt;li&gt;critical: An object has critical Status when it is still performing, but Service disruption may occur if corrective Action is not taken immediately. &lt;li&gt;emergency: An object is in emergency Status when it stops performing unexpectedly and could lose data. &lt;/ul&gt; In some contexts, it is important that severities are ordered (as above). For example, an alarm might be triggered if an event with a given Severity "or worse" occurs. In this example, worse means "after" in the list above.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DiskInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a disk.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AggregateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Aggregate To which the disk belongs. When Aggregate the disk belongs To is not known or disk is a spare disk, AggregateId will not be returned.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AggregateName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of Aggregate To which the disk belongs. When Aggregate the disk belongs To is not known or disk is a spare disk, AggregateName will not be returned. The Name is any simple Name such as myaggr.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DiskId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the disk. Always present in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DiskName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the disk. Always present in the output. The Name will look like "data disk 0b.18", "parity disk 0b.17", "dparity disk 0b.16" etc. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DiskSize">
                        <xsd:annotation>
                            <xsd:documentation>Disk Size in bytes. Range : [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DiskType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the disk. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DiskUidOrWwn" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the disk. For Hosts running Data ONTAP versions prior To 7.0.1, this will be the World Wide Name (WWN) of the disk. For Hosts running Data ONTAP versions 7.0.1 and later, this will be the Unique Identifier (UID) of the disk. When UID or WWN of a disk is not known, this field will not be returned. Maximum Length of 90 characters. Format of disk WWN will look like: 20:00:00:0c:50:45:7d:bc Format of disk UUID will look like: 2000000C:50A9022F:00000000:00000000:00000000:00000000: 00000000:00000000:00000000:00000000</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Host To which the disk belongs. Always present in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of Host To which the disk belongs. Always present in the output. The Name is any simple Name such as myhost.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PlexName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of plex To which the disk belongs. The Name is any simple Name such as plex0. When plex the disk belongs To is not known or disk is a spare disk, PlexName will not be returned. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RaidgroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of raidgroup To which the disk belongs. The Name is any simple Name such as rg0. When raidgroup the disk belongs To is not known or disk is a spare disk, RaidgroupName will not be returned. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="BackupLocationInfo">
                <xsd:annotation>
                    <xsd:documentation>location information for backup. Only the Members which are found are returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupId">
                        <xsd:annotation>
                            <xsd:documentation>Actual backup Instance used To restore Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="MemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Qtree or OSSV Directory. MemberId is for the primary Qtree or OSSV dir.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Qtree or OSSV Directory. MemberName is for the primary Qtree or OSSV dir.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Path. The Maximum Path Length is 32767 characters. This Path is relative To 'MemberId' Path in the storage system or OSSV Host. For storage system and ossv unix Hosts this is a unix-like Path (ex: '/dir1/dir2'). For ossv windows Host this is a windows Path (ex: '\dir1\dir2').</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PathFound" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>TRUE if the Path is found in a BackupVersion. The following elements will be set only if PathFound is TRUE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy on the primary where the data originated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data originated. Currently, this is the Snapshot copy's creation time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SecondaryQtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the secondary Qtree which is protecting the MemberId.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SecondaryQtreeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the secondary Qtree which is protecting the MemberId.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot in the backup which contains the backup of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageSystemId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the storage system on which the secondary Snapshot copy resides. Always present in the output if the Path is found.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageSystemName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage system on which the secondary Snapshot copy resides. Always present in the output if the Path is found.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Volume on which the Snapshot resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DfmMetadata">
                <xsd:annotation>
                    <xsd:documentation>Named field in the metadata.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="FieldName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the metadata field. Field names are up To 255 characters in Length and are case- insensitive.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FieldValue" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Arbitrary, user-defined data expressed as a string. The string is opaque To the server and must not exceed 16384 (16k) characters in Length.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpBackupContentInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about contents of a backup of Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpFileInfo" type="na:DpFileInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about file (or Directory etc.) in a backup. This element will not be present in case of top-level contents.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy on the primary where the data originated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data originated. Currently, this is the Snapshot copy's creation time. This can be used To differentiate between versions of the same file in the same backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RootObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of a Dataset member that is at the root of the file tree. This may be Qtree, ossv Directory or Volume that is Source of the physical data protection relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RootObjectName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Object Name for RootObjectId.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RootObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Object Type for RootObjectId. Possible Values: 'Qtree', 'Directory', 'Volume', 'virtual_machine'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpBackupIdInfo">
                <xsd:annotation>
                    <xsd:documentation>Backup-version Instance information including Id and node Name for this Version.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BackupId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the backup Instance. The management station assigns a unique Id To each backup Instance. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BackupMetadata" type="na:ArrayOfDfmMetadata">
                        <xsd:annotation>
                            <xsd:documentation>Opaque metadata for the backup. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier for the job creating this backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="NodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the node in the data protection Policy. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Policy node that corresponds To the storage set that holds backup. May not be present if a different Policy has been associated with this Dataset, and the storage set containing this backup has no corresponding node in the current Policy. It may be possible To restore contents From such orphaned Backups if the physical relationships continue To exist.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpBackupInfo">
                <xsd:annotation>
                    <xsd:documentation>Backup is a single backed up image of a Dataset. If backup is too large To fit on a single Volume, the management station uses multiple Volumes in the same storageset. In such cases, a single backup may span multiple Volumes in a single storageset. The management station keeps track of actual Volumes that hold the backup. Caller can identify backup by its numeric identifier.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User specified Description of backup for unscheduled backup started by DpBackupStart. The Maximum Length of this string is 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BackupId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the backup Instance. The management station assigns a unique Id To each backup Instance. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BackupMetadata" type="na:ArrayOfDfmMetadata">
                        <xsd:annotation>
                            <xsd:documentation>Opaque metadata for the backup. Metadata is usually set and interpreted by an application that is using the Dataset. DFM does not look into the contents of the metadata.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BackupTransferInfos" type="na:ArrayOfDpBackupTransferInfo">
                        <xsd:annotation>
                            <xsd:documentation>Indicates the transfer Status of this backup To each of the destination nodes directly connected To the node on which this backup exists.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BackupTransferStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This field has been deprecated, use BackupTransferInfos instead. Indicates the transfer Status of this backup. This field is meant for internal use. It is set by backup transfer job only for Backups on the Primary node of an application Dataset. Possible Values: 'transferring', 'transferred', 'transfer_failed', and ''.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BackupVersion" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when the backup was taken. Backups of same Dataset at different locations have same Version if their contents are identical. The management station keeps track of which Backups have identical contents and assigns same Version To them. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsAddingMembers" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether more Members are being added To the VersionMembers element of this backup. &lt;P&gt; If this element is true, Protection Manager expects more Members To be added To the VersionMembers element of this backup. The job that is transferring this backup, periodically checks To see if the new Members have been added and starts transferring them. The transfer job does not exit until this input is set To false by calling DpBackupVersionModify API (or until the Timeout occurs). &lt;P&gt; If this element is false, the job exits after transferring any Members that it could find in this backup. Any new Members that got added To the backup will be transferred by the next job. &lt;P&gt; This element can be used when creating a local backup potentially takes a very long time and you want the Protection Manager To start the transfers without waiting for the local backup To complete.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsForPropagation" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether or not this backup Version should be propagated according To the data protection Policy. If false, the backup Version will not be propagated To other nodes. Default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NodeId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Id of Policy node that corresponds To the storageset that holds backup. May not be present if Policy has been modified in such a way that storageset has no corresponding node in Policy. It may be possible To restore contents From such orphaned backup if the physical relationships continue To exist. The NodeId Values start at 1. The node Id of the primary node is always 1.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Policy node that corresponds To the storageset that holds backup. May not be present if Policy has been modified in such a way that storageset has no corresponding node in Policy. It may be possible To restore contents From such orphaned backup if the physical relationships continue To exist.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Type of Retention for the backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SupportsNonDisruptiveRestore" type="na:RequiresNonDisruptiveRestore">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether a non disruptive restore is possible From this backup Version. If true then non disruptive restore is possible.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VersionMembers" type="na:ArrayOfVersionMemberInfo">
                        <xsd:annotation>
                            <xsd:documentation>describes Snapshot Members of this backup Version.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpBackupPathInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about backup Path</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="MemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>The Qtree or OSSV dir ID. Either MemberId or MemberName must be supplied. If MemberId is supplied MemberName should not be supplied.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MemberName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>The Qtree or OSSV dir Name. Either MemberId or MemberName must be supplied. MemberName is only used if MemberId is not supplied</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Path. The Maximum Path Length is 32767 characters. This Path is relative To 'MemberId' Path in the storage system or OSSV Host. For storage system and ossv unix Hosts this is a unix-like Path (ex: '/dir1/dir2'). For ossv windows Host this is a windows Path (ex: '\dir1\dir2').</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy on the primary where the data originated. This is ignored if PrimarySnapshotUniqueId is specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data originated. Currently, this is the Snapshot copy's creation time. This should be specified when member exists in more than one Snapshot copies in the same backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DpBackupRetentionType">
                <xsd:annotation>
                    <xsd:documentation>Retention Type To which the backup should be archived. Possible Values are: 'hourly', 'daily', 'weekly', 'monthly' and 'unlimited'.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpBackupTransferInfo">
                <xsd:annotation>
                    <xsd:documentation>Indicates the transfer Status of the backup between the two nodes directly connected To each other. When present in the input, you must specify at least one of DestinationStoragesetId, DestinationNodeName or DestinationNodeId.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupTransferNeeded" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if the backup needs To be transferred To the destination storage set. This field is for internal use by the Protection Manager.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BackupTransferStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Indicates the transfer Status of the backup To the destination node. &lt;P&gt; Possible Values: 'transferring', 'transferred', 'transfer_failed', and ''. &lt;P&gt; 'transferring' indicates that a job is currently transferring the backup To the destination node. &lt;P&gt; 'transferred' indicates that backup was successfully transferred To the destination node. &lt;P&gt; '' indicates that no transfer has started. &lt;P&gt; In the case of a mirror relationship, transfer_failed is not a terminal state. The transfer could be retried as part of a subsequent mirror update.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ConnectionType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the Policy connection between Source and destination nodes. Possible Values: 'backup', 'mirror'. Present in the output only. Ignored if present in the input. May not be present in the output if the Policy connection could not be found.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationBackupId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of backup on the destination node. Present in the output only. Ignored if specified in the input. May not be present in the output if the backup Version does not exist on the destination node yet. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationNodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of destination node in the data protection Policy that corresponds To the destination storage set. May not be present in the output if the destination storage set cannot be mapped To any node in the Policy. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of destination node in the data protection Policy that corresponds To the destination storage set. May not be present in the output if the destination storage set cannot be mapped To any node in the Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationStoragesetId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the destination storage set. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="JobId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier for the job that is transferring or has transferred this backup To the destination storage set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceBackupId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of backup on the Source node. Present in the output only. Ignored if specified in the input. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceNodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of Source node in the data protection Policy that corresponds To the Source storage set. Present in the output only. Ignored if specified in the input. May not be present in the output if the Source storage set cannot be mapped To any node in the Policy. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Source node in the data protection Policy that corresponds To the Source storage set. Present in the output only. Ignored if specified in the input. May not be present in the output if the destination storage set cannot be mapped To any node in the Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceStoragesetId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Source storage set. Present in the output only. Ignored if specified in the input. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpBackupVersionInfo">
                <xsd:annotation>
                    <xsd:documentation>Backup-version information including list of all Instances of this Version.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description for the backup. It may be any arbitrary string meaningful To the agent spawning the backup. The Maximum Length of this string is 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BackupIdInfos" type="na:ArrayOfDpBackupIdInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of backup Instances.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BackupTransferInfos" type="na:ArrayOfDpBackupTransferInfo">
                        <xsd:annotation>
                            <xsd:documentation>Indicates the transfer Status of this backup Version between each pairs of the Source and destination nodes which have direct connection in the data protection Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BackupVersion" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when the backup was taken. Backups of same Dataset at different locations have same Version if their contents are identical. The management station keeps track of which Backups have identical contents and assigns same Version To them. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsFullyPropagated" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates that this Version is a complete backup of the Dataset on all nodes specified by the protection Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Type of Retention for the backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VersionMembers" type="na:ArrayOfVersionMemberInfo">
                        <xsd:annotation>
                            <xsd:documentation>Describes Snapshot Members of this backup Version.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpFileInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about file, Directory, Qtree, drive etc. on a primary Host or in a backup.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ChildCount">
                        <xsd:annotation>
                            <xsd:documentation>Count of children. This is zero when Value of FileType element is 'file'. Otherwise, it can be zero or non-zero. Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="FileName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the file.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FileSize" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>Size of file in bytes. Range: [0..2^64-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FileType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the file. Possible Values: 'file', 'Directory', 'Qtree', 'Volume', 'drive', 'fifo', 'cspec', 'bspec', 'symlink', 'socket', 'registry', 'stream', 'Lun', and 'other'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsEmpty" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>This element is present only if the FileType is a Directory and the Version of ONTAP on the storage systems in 7.3.2 and higher. For all other cases, this element will be absent. It determines if the Directory is is an empty Directory. The Value of the element is TRUE is Directory is empty, it is FALSE otherwise. Directory is considered empty if it only contains entries for "." and ".."</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastModifiedTimestamp" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when the file was last modified. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpJobData">
                <xsd:annotation>
                    <xsd:documentation>Describes an unscheduled data protection job. Type of job is specified in DpJobType element. Only one of all possible dp-*-job-data elements can be present.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Dataset being protected by the job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpJobType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the dp job. Possible Values: 'snapvault', 'snapmirror' and 'local_snapshot'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpLocalSnapshotJobData" type="na:DpLocalSnapshotJobData">
                        <xsd:annotation>
                            <xsd:documentation>Data for local-snapshot job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpSnapmirrorTransferJobData" type="na:DpSnapmirrorTransferJobData">
                        <xsd:annotation>
                            <xsd:documentation>Data for snapmirror-transfer job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpSnapvaultTransferJobData" type="na:DpSnapvaultTransferJobData">
                        <xsd:annotation>
                            <xsd:documentation>Data for snapvault-transfer job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="SnapshotMemberInfo">
                <xsd:annotation>
                    <xsd:documentation>Information of one Qtree or ossv dir that is in Snapshot.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="PrimaryId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Always returned on output, either PrimaryId or PrimaryName must be specified on input. Primary Qtree or OSSV Directory ID.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimaryName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Always returned on output, either PrimaryId or PrimaryName must be specified on input. The Name of a Qtree or OSSV Directory whose data is in the Snapshot.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy on the primary where the data originated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data originated. Currently, this is the Snapshot copy's creation time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SecondaryQtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Corresponding secondary Qtree Id. This legacy parameter if supplied along with SecondaryQtreeNameOrId will be ignored unless it references a different Qtree in which case an Error will be returned. Not included if the backup Version consists of local Snapshots.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SecondaryQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Corresponding secondary Qtree Name. This is ignored on input. Use SecondaryQtreeNameOrId To specify by Name. On output this will be returned along with SecondaryQtreeId. Not included if the backup Version consists of local Snapshots.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SecondaryQtreeNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Corresponding secondary Qtree Name or identifier. This is used To lookup the SecondaryQtreeId if present. If this is present, SecondaryQtreeId will be ignored. Not included if the backup Version consists of local Snapshots.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VersionMemberInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes one Snapshot member of a backup Version.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Whether this Snapshot is available for a restore. A Snapshot is considered available if the containing Filer is responding To ping requests and the containing Volume is online. These Values will be based on information returned by the most recent DFM pass, not by querying the Filer in RealTime.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SnapshotContents" type="na:ArrayOfSnapshotMemberInfo">
                        <xsd:annotation>
                            <xsd:documentation>Contents of the Snapshot.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot. currently this is Snapshot creation time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Always included in output, either VolumeId or VolumeName must be specified in input. ID of the Volume corresponding To member Snapshot.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Always included in output, either VolumeId or VolumeName must be specified in input. The Name of the Volume this Snapshot resides on.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpDatasetLagInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a single Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LagStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Lag Status of the relationship Lag versus the DP Policy Lag threshold settings. Possible Values are "unknown", "normal", "warning" and "Error".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="WorstLag">
                        <xsd:annotation>
                            <xsd:documentation>Worst Lag time of all the relationships in the Datasets. The Lag time is the number of seconds since the completion of the last successful transfer To the destination for each relationship. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpRelationshipLagInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a single SnapVault or SnapMirror relationship.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Lag">
                        <xsd:annotation>
                            <xsd:documentation>Seconds since the completion of the last successful transfer To the destination. If no transfer has ever succeeded, this Value is 0. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="RelationshipId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipSource" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Full Path of the Source object of the relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipState" type="na:RelationshipState">
                        <xsd:annotation>
                            <xsd:documentation>State of the relationship</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipType" type="na:RelationshipType">
                        <xsd:annotation>
                            <xsd:documentation>Type of the relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DrStateStatusCount">
                <xsd:annotation>
                    <xsd:documentation>Number of DR-enabled Datasets with a single distinct dr-state/dr-status combination.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Count">
                        <xsd:annotation>
                            <xsd:documentation>Number of DR-enabled Datasets with a state of DrState and Status of DrStatus. Only return state and Status combinations which have at least one Dataset in them. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DrState" type="na:DrState">
                        <xsd:annotation>
                            <xsd:documentation>DR state of all Datasets</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DrStatus" type="na:DrStatus">
                        <xsd:annotation>
                            <xsd:documentation>DR Status of all Datasets</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="CifsAcl">
                <xsd:annotation>
                    <xsd:documentation>Information about the user and the Permission with which the user can access the CIFS share.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AccessRights" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Access right of the user accessing the CIFS share. Possible Values are 'no_access', 'read', 'change' and 'full_control'</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="UserName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the user accessing the CIFS share. The Username may be the Name of an actual domain user or one of the built-in names like 'administrator' or 'everyone'. This can be a Maximum of 128 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DestroyMemberRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details specific To the 'destroy_member' Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="MemberId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>This is the Id of the Dataset member on which the Action was performed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>This is the full Name of the Dataset member on which the Action is performed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the Dataset member on which the Action was or is To be performed. Possible Values are 'Volume', 'Qtree' and 'Lun'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpJobInfo">
                <xsd:annotation>
                    <xsd:documentation>A job is used To run one or more Data Protection or provisioning operations.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AbortRequestedTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when Request was received To abort job. If unspecified, no such Request was received.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BytesTransferred">
                        <xsd:annotation>
                            <xsd:documentation>Bytes transferred in this Operation. Zero when transfer starts. Range: [0..2^63-1]. It will be always zero for a provisioning job.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CompletedTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when the job was completed. If unspecified, the job has not yet reached completion.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the Dataset on which this job was carried out. This field is optional and will be returned only when the job is carried out on a Dataset. This field is deprecated in favor of ObjectName and ObjectType. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset on which this job was carried out. This field is optional and will be returned only when the job is carried out on a Dataset. This field is deprecated in favor of ObjectName and ObjectType.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationNodeId">
                        <xsd:annotation>
                            <xsd:documentation>Destination Policy node Id associated with this job. Not present if this job is only associated with a single node (e.g. a Snapshot job or a provisioning job). Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Destination Policy node Name associated with this job. Not present if this job is only associated with a single node (e.g. a Snapshot job or provisioning job).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobContextObjId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the job context object. If there was no job context when the job is submitted, then the identifier of the job object on which the job ran will be returned as the job context object identifier. &lt;P&gt; Refer To &lt;b&gt; JobContextObjType&lt;/b&gt; for valid types of job context Objects.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobContextObjName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the job context object. If there was no job context when the job is submitted, then the full Name of the job object on which the job ran will be returned as the job context object full Name. &lt;P&gt; Refer To &lt;b&gt; JobContextObjType&lt;/b&gt; for valid types of job context Objects.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobContextObjType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the job context object. Possible Values are :- &lt;UL&gt; &lt;LI&gt; Aggregate &lt;LI&gt; Dataset &lt;LI&gt; Vfiler &lt;/UL&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of what job is trying To accomplish.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the job. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="JobOverallStatus" type="na:DpJobOverallStatus">
                        <xsd:annotation>
                            <xsd:documentation>Overall Status of the job based on JobProgress and JobState.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobProgress" type="na:DpJobProgress">
                        <xsd:annotation>
                            <xsd:documentation>The current progress of the data protection or provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobState" type="na:DpJobState">
                        <xsd:annotation>
                            <xsd:documentation>State of the job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobType" type="na:DpJobType">
                        <xsd:annotation>
                            <xsd:documentation>Type of data protection or provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the object on which this job was carried out.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the object on which this job was carried out.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the object on which this job was carried out. Possible Values: &lt;UL&gt; &lt;LI&gt; Dataset &lt;LI&gt; Vfiler &lt;LI&gt; Volume &lt;/UL&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PolicyId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the data protection Policy responsible for spawning this job. If unspecified, the job was not invoked in Response To a Policy. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PolicyName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the data protection Policy responsible for spawning this job. If unspecified, the job was not invoked in Response To a Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisionRequestInfo" type="na:ProvisionRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information of the provisioning Request. Present only if the JobType is one of 'provision_member', 'resize_member', 'delete_snapshots', 'destroy_member', 'dedupe_member' or 'undedupe_member'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceNodeId">
                        <xsd:annotation>
                            <xsd:documentation>Source Policy node Id associated with this job. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SourceNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Source Policy node Name associated with this job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StartedTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when job was started. If unspecified, the job has not yet started running and is queued.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SubmittedBy" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User who submitted the job. If unspecified, the job was submitted by one of the internal DFM services such as the scheduler. The Length of this string cannot be more than 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DpJobOverallStatus">
                <xsd:annotation>
                    <xsd:documentation>The overall Status of the data protection/provisioning job. The possible Values are "queued", "canceling", "canceled", "running", "running_with_failures", "partially_failed", "succeeded", and "failed". This field is derived From DpJobState and DpJobProgress. &lt;BR&gt; The current mappings are as follow: &lt;PRE&gt; DpJobState DpJobProgress DpJobOverallStatus &lt;BR&gt; ===================================================== &lt;BR&gt; queued * queued &lt;BR&gt; running in_progress running &lt;BR&gt; running success running &lt;BR&gt; running partial_success running_with_failures &lt;BR&gt; running failure running_with_failures &lt;BR&gt; aborting * canceling &lt;BR&gt; aborted * canceled &lt;BR&gt; completed partial_success partially_failed &lt;BR&gt; completed failure failed &lt;BR&gt; completed success succeeded &lt;BR&gt; completed in_progress canceled &lt;BR&gt; &lt;/PRE&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="DpJobProgress">
                <xsd:annotation>
                    <xsd:documentation>The progress of data protection job. Valid Values are "in_progress", "partial_success", "success" and "failure".&lt;BR&gt; "in_progress" - No transfers have completed till now.&lt;BR&gt; "success" - Atleast one transfer succeeded, none failed till now &lt;BR&gt; "failure" - Atleast one transfer failed, none succeeded till now. &lt;BR&gt; "partial_success" - Atleast one transfer failed and atleast one transfer succeeded till now. &lt;BR&gt; The progress of the data protection job follows the following state diagram, depending on the success and failure of the transfers handled by the data protection job. &lt;PRE&gt; +------"in_progress"---+&lt;BR&gt; | |&lt;BR&gt; | |&lt;BR&gt; failure? success?&lt;BR&gt; | |&lt;BR&gt; v v&lt;BR&gt; "failure" "success"&lt;BR&gt; | |&lt;BR&gt; | |&lt;BR&gt; success? failure?&lt;BR&gt; | |&lt;BR&gt; +--&gt;"partial_success"&lt;-+&lt;BR&gt; &lt;/PRE&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpJobProgressEventInfo">
                <xsd:annotation>
                    <xsd:documentation>One historical progress event for a data protection or provisioning job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpProgressBackupInfo" type="na:DpProgressBackupInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the creation or deletion of a backup Version.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressFailoverInfo" type="na:DpProgressFailoverInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about a failover job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressJobAbortInfo" type="na:DpProgressJobAbortInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the abort of a job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressRelationshipInfo" type="na:DpProgressRelationshipInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about creation or destruction of a SnapVault or SnapMirror relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressRestoreInfo" type="na:DpProgressRestoreInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about restore of a Path.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressSnapmirrorInfo" type="na:DpProgressSnapmirrorInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about a SnapMirror transfer. SnapMirror transfers will generally log a start message, zero or more progress messages, and finally either an end or Error message.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressSnapshotInfo" type="na:DpProgressSnapshotInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about a newly created Snapshot.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpProgressSnapvaultInfo" type="na:DpProgressSnapvaultInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about a SnapVault transfer. SnapVault transfers will generally log a start message, zero or more progress messages, and finally either an end or Error message.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ErrorMessage" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>If present, a human readable Error message. If absent, there has been no Error.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventId">
                        <xsd:annotation>
                            <xsd:documentation>Unique ID of this progress event. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="EventMessage" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Human-readable message describing event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>The Status of the progress event. Possible Values: 'normal', 'warning' and 'Error'</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Time of event</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of event. Values are: &lt;ul&gt; &lt;li&gt; 'job-start' &lt;li&gt; 'JobProgress' &lt;li&gt; 'job-abort' (DpProgressJobAbortInfo) &lt;li&gt; 'job-end' &lt;li&gt; 'job-retry' &lt;li&gt; 'rel-create-start' (DpProgressRelationshipInfo) &lt;li&gt; 'rel-create-progress' (DpProgressRelationshipInfo) &lt;li&gt; 'rel-create-end' (DpProgressRelationshipInfo) &lt;li&gt; 'rel-destroy-start' (DpProgressRelationshipInfo) &lt;li&gt; 'rel-destroy-progress' (DpProgressRelationshipInfo) &lt;li&gt; 'rel-destroy-end' (DpProgressRelationshipInfo) &lt;li&gt; 'snapshot-create' (DpProgressSnapshotInfo) &lt;li&gt; 'snapshot-delete' (DpProgressSnapshotInfo) &lt;li&gt; 'backup-create' (DpProgressBackupInfo) &lt;li&gt; 'backup-delete' (DpProgressBackupInfo) &lt;li&gt; 'snapvault-start' (DpProgressSnapvaultInfo) &lt;li&gt; 'snapvault-progress' (DpProgressSnapvaultInfo) &lt;li&gt; 'snapvault-end' (DpProgressSnapvaultInfo) &lt;li&gt; 'snapmirror-start' (DpProgressSnapmirrorInfo) &lt;li&gt; 'snapmirror-progress' (DpProgressSnapmirrorInfo) &lt;li&gt; 'snapmirror-end' (DpProgressSnapmirrorInfo) &lt;li&gt; 'restore-start' (DpProgressRestoreInfo) &lt;li&gt; 'restore-progress' (DpProgressRestoreInfo) &lt;li&gt; 'restore-end' (DpProgressRestoreInfo) &lt;li&gt; 'MigrateStart' (DpProgressRestoreInfo) &lt;li&gt; 'migrate-progress' (DpProgressRestoreInfo) &lt;li&gt; 'migrate-end' (DpProgressRestoreInfo) &lt;li&gt; 'mirror-break-script-start' (DpProgressFailoverInfo) &lt;li&gt; 'mirror-break-script-end' (DpProgressFailoverInfo) &lt;li&gt; 'mirror-break-quiesce-start' (DpProgressFailoverInfo) &lt;li&gt; 'mirror-break-quiesce-end' (DpProgressFailoverInfo) &lt;li&gt; 'mirror-break-start' (DpProgressFailoverInfo) &lt;li&gt; 'mirror-break-end' (DpProgressFailoverInfo) &lt;li&gt; 'volume-create' (ProgressVolumeInfo) &lt;li&gt; 'volume-option-set' (ProgressVolumeOptionInfo) &lt;li&gt; 'snapshot-reserve-resize' (ProgressVolumeInfo) &lt;li&gt; 'volume-autosize' (ProgressVolumeInfo) &lt;li&gt; 'snapshot-autodelete' (ProgressVolumeInfo) &lt;li&gt; 'lun-create' (ProgressLunInfo) &lt;li&gt; 'lun-destroy' (ProgressLunInfo) &lt;li&gt; 'lun-map' (ProgressLunMapInfo) &lt;li&gt; 'lun-unmap' (ProgressLunMapInfo) &lt;li&gt; 'igroup-create' (ProgressIgroupInfo) &lt;li&gt; 'igroup-destroy' (ProgressIgroupInfo) &lt;li&gt; 'igroup-add' (ProgressIgroupConfigInfo) &lt;li&gt; 'igroup-remove' (ProgressIgroupConfigInfo) &lt;li&gt; 'qtree-create' (ProgressQtreeInfo) &lt;li&gt; 'quota-set' (ProgressQuotaInfo) &lt;li&gt; 'nfsexport-create' (ProgressNfsexportInfo) &lt;li&gt; 'cifs-share-create' (ProgressCifsShareInfo) &lt;li&gt; 'cifs-share-modify' (ProgressCifsShareInfo) &lt;li&gt; 'cifs-share-delete' (ProgressCifsShareInfo) &lt;li&gt; 'volume-offline' (ProgressVolumeInfo) &lt;li&gt; 'volume-destroy' (ProgressVolumeInfo) &lt;li&gt; 'qtree-destroy' (ProgressQtreeInfo) &lt;li&gt; 'vfiler-storage-add' (ProgressVfilerStorageInfo) &lt;li&gt; 'script-run' (ProgressScriptRunInfo) &lt;li&gt; 'VfilerCreate' (ProgressVfilerInfo) &lt;li&gt; 'VfilerSetup' (ProgressVfilerInfo) &lt;li&gt; 'volume-dedupe' (ProgressVolumeDedupeInfo) &lt;li&gt; 'volume-dedupe-enable' (ProgressVolumeDedupeInfo) &lt;li&gt; 'volume-dedupe-disable' (ProgressVolumeDedupeInfo) &lt;li&gt; 'volume-dedupe-schedule-set' (ProgressVolumeDedupeInfo) &lt;li&gt; 'aggregate-space' (ProgressAggregateInfo) &lt;/ul&gt; &lt;P&gt; Each event Type has a corresponding element with event-specific fields broken out. The Name of the event-specific element is listed after the event Type. Only the Name of the event is returned. The Value in the parenthesis is the Type of element returned for that Type of event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="JobId">
                        <xsd:annotation>
                            <xsd:documentation>The ID of the job that generated this event. Range: [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="JobType" type="na:DpJobType">
                        <xsd:annotation>
                            <xsd:documentation>Type of data protection or provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressAggregateInfo" type="na:ProgressAggregateInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about Aggregate.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressCifsShareInfo" type="na:ProgressCifsShareInfo">
                        <xsd:annotation>
                            <xsd:documentation>CIFS share information.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressIgroupConfigInfo" type="na:ProgressIgroupConfigInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Initiators added or removed From an initiator Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressIgroupInfo" type="na:ProgressIgroupInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the initiator Group on which the mapping Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressLunInfo" type="na:ProgressLunInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Lun being provisioned.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressLunMapInfo" type="na:ProgressLunMapInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Lun on which the mapping Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressNfsexportInfo" type="na:ProgressNfsexportInfo">
                        <xsd:annotation>
                            <xsd:documentation>NFS export information.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressQtreeInfo" type="na:ProgressQtreeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Qtree provisioned.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressQuotaInfo" type="na:ProgressQuotaInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the quota being modified/set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressScriptRunInfo" type="na:ProgressScriptRunInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the script which is run.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressVfilerInfo" type="na:ProgressVfilerInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Vfiler which is being created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressVfilerStorageInfo" type="na:ProgressVfilerStorageInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Vfiler on which storage is added or removed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressVolumeDedupeInfo" type="na:ProgressVolumeDedupeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about dedupe Operation on the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressVolumeInfo" type="na:ProgressVolumeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Volume on which the provisioning Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProgressVolumeOptionInfo" type="na:ProgressVolumeOptionInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Name and Value of various Volume Options.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DpJobState">
                <xsd:annotation>
                    <xsd:documentation>The state of the data protection/provisioning job. The possible Values are "queued", "running", "completed", "aborting", "aborted". This state is derived From CompletedTimestamp, AbortRequestedTimestamp and StartedTimestamp.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="DpJobType">
                <xsd:annotation>
                    <xsd:documentation>The Type of data protection, provisioning, migration or space management job. Valid Values for data protection Jobs are "local_backup", "local_backup_confirmation", "remote_backup", "mirror", "restore", "create_relationship", "destroy_relationship", "on_demand_backup" and "failover". &lt;p&gt; Valid Values for provisioning job types are "provision_member", "resize_member", "destroy_member", "delete_snapshots", "dedupe_member", "undedupe_member", "dedupe_volume" and "pm_re_export". &lt;P&gt; Valid space management Jobs are: "dedupe_volume", "migrate_volume", "resize_volume", "delete_snapshot" and "delete_backup". &lt;P&gt; Valid migration job types are: "migrate_start", "migrate_complete", "migrate_cancel", "migrate_cleanup", "migrate_update".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpLocalSnapshotJobData">
                <xsd:annotation>
                    <xsd:documentation>Data for local-snapshot job. If this element is present, job is responsible for taking a local Snapshot of data on the storageset associated with the specified node.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsConfirmationData" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If the element: "IsConfirmationData" is set To 'true', this job only confirms Backups have been created on the primary node. An external agent, such as a SnapManager/SnapDrive, is responsible for creating these Backups. This element can only be true for application data sets. If set To true, the job Type will be "local_backup_confirmation" and the job will update the protection Status without creating a local backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="NodeId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the node that needs local Snapshot. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Retention To be used for the local Snapshot.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressBackupInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the creation or deletion of a backup Version.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BackupId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the new backup Instance. Each copy of a backup Version gets a unique backup ID. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="BackupVersion" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Time at which backup image was created. All Backups with the same BackupVersion are copies of the same point-in-time image of the original data.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Retention" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Retention Type of backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressFailoverInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a failover job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DestinationPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Destination Path for the SnapMirror break Operation. This element is not present for event Type 'mirror-break-script-start' and 'mirror-break-script-end'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EnvironmentVariableList" type="na:ArrayOfEnvironmentVariableInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of environment variables related To the Dataset To be passed To the failover script. This element is present only for event Type 'mirror-break-script-start'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RelationshipId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>The relationship ID for performing mirror break. This element is not present for event Type 'mirror-break-script-start' and 'mirror-break-script-end'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScriptExitStatus" type="xsd:int">
                        <xsd:annotation>
                            <xsd:documentation>Exit code of the script. This element is present only for event Type 'mirror-break-script-end'. Range: [-2^31..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScriptPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Path of the failover script. This element is present only for event Type 'mirror-break-script-start' and 'mirror-break-script-end'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScriptRunAs" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Username used To run the failover script. This element is present only for event Type 'mirror-break-script-start' and 'mirror-break-script-end'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScriptSummary" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Detailed output From the failover script. This element is present only for event Type 'mirror-break-script-end'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressJobAbortInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the abort of a job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AbortedBy" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User who aborted the job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressRelationshipInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the creation or destruction of a SnapVault or SnapMirror relationship.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BytesTransferred">
                        <xsd:annotation>
                            <xsd:documentation>Bytes transferred as a Result of creating a relationship. Zero when for relationship Destroy messages. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DestinationVolumeOrQtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of destination Volume or Qtree. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DestinationVolumeOrQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the destination Volume or Qtree. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;/&lt;QtreeName&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of relationship being created or destroyed. Legal Values are "snapvault" or "snapmirror".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceVolumeOrQtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of the Source Volume or Qtree. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SourceVolumeOrQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of the Source Volume or Qtree. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;/&lt;QtreeName&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressRestoreInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about restore of a Path.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BackupId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the backup Instance used for restore. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="BackupVersion" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>The backup Version used for restore.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BytesTransferred">
                        <xsd:annotation>
                            <xsd:documentation>Bytes transferred in this Operation. Zero when transfer starts. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The full Path To restore the Dataset member To. The format is &lt;HostName&gt;:/&lt;full-path&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberId">
                        <xsd:annotation>
                            <xsd:documentation>The ID of the Dataset member To be restored. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="MemberName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The full Name of the Dataset member To be restored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Path To be restored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressSnapmirrorInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the start and end of a SnapMirror transfer.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BytesTransferred">
                        <xsd:annotation>
                            <xsd:documentation>Bytes transferred in this Operation. Zero when transfer starts. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DestinationVolumeOrQtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of destination Volume or Qtree of the mirror. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DestinationVolumeOrQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of destination Volume or Qtree of the mirror. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceVolumeOrQtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of Volume or Qtree being mirrored. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SourceVolumeOrQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Volume or Qtree being mirrored. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressSnapshotInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the creation or deletion of a Snapshot.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="SnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Snapshot</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of Volume getting Snapshot. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume object getting the Snapshot. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpProgressSnapvaultInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the start and end of a SnapVault transfer.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BytesTransferred">
                        <xsd:annotation>
                            <xsd:documentation>Bytes transferred in this Operation. Zero when transfer starts. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DestinationQtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of Qtree receiving back up. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DestinationQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Qtree receiving backed up. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;/&lt;QtreeName&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceQtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric ID of Qtree being backed up. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SourceQtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Qtree being backed up. The format is &lt;HostName&gt;:/&lt;VolumeName&gt;/&lt;QtreeName&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpScheduledJob">
                <xsd:annotation>
                    <xsd:documentation>Describes a scheduled data protection job. Each job has a scheduled start time and protects a single Dataset. Scheduler Service is responsible for starting job at its scheduled time. Type of job is inferred From which dp-*-job-data element is present. Only one of all possible dp-*-job-data elements can be present. Scheduled job does not have a job Id. When scheduler Service is about To start the job, it creates a job record in the persistent database and at that time job gets its Id.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DatasetId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Dataset being protected by the job. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpLocalSnapshotJobData" type="na:DpLocalSnapshotJobData">
                        <xsd:annotation>
                            <xsd:documentation>Data for local-snapshot job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpSnapmirrorTransferJobData" type="na:DpSnapmirrorTransferJobData">
                        <xsd:annotation>
                            <xsd:documentation>Data for snapmirror-transfer job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpSnapvaultTransferJobData" type="na:DpSnapvaultTransferJobData">
                        <xsd:annotation>
                            <xsd:documentation>Data for snapvault-transfer job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StartTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Time when job needs To start. Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. Scheduler Service is responsible for starting the job at this time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpSnapmirrorTransferJobData">
                <xsd:annotation>
                    <xsd:documentation>Data for snapmirror-transfer job. If this element is present, job is responsible for transferring data between two storagesets associated with the specified connection using SnapMirror Protocol.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ConnectionId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Policy connection that needs SnapMirror transfer. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Retention To be used for the pre/post backup script in the snapmirror-transfer job only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpSnapvaultTransferJobData">
                <xsd:annotation>
                    <xsd:documentation>Data for snapvault-transfer job. If this element is present, job is responsible for transferring data between two storagesets associated with the specified connection using SnapVault Protocol.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ConnectionId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Policy connection that needs SnapVault transfer. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Retention To be used for the backup created by snapvault-transfer job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DpTimestamp">
                <xsd:annotation>
                    <xsd:documentation>Seconds since 1/1/1970 in UTC. Range: [0..2^31-1]. This runs out in 2036, so update the API some time before then.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="EnvironmentVariableInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about an environment variable.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Environment variable Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Value of an environment variable.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="JobType">
                <xsd:annotation>
                    <xsd:documentation>Job Type.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="na:DpJobType"/>
            </xsd:simpleType>
            <xsd:complexType name="ProgressAggregateInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the Aggregate</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AggregateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Aggregate</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Aggregate</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressCifsShareInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the CIFS share created as part of provisioning Operation.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CifsAclList" type="na:ArrayOfCifsAcl">
                        <xsd:annotation>
                            <xsd:documentation>CIFS access control list set on the CIFS share.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CifsShareName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the CIFS share.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolOrQtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Volume or Qtree for which the CIFS share is created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolOrQtreeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume or Qtree for which the CIFS share is created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressIgroupConfigInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about Initiators being added or removed to/from an initiator Group of a job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="IgroupId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the initiator Group To which Initiators are added or destroyed in a provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IgroupName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the initiator Group To which Initiators are added or destroyed in a provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Initiators" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Comma separated list of Initiators that are added or removed in this provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressIgroupInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the initiator Group of a job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="IgroupId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the initiator Group which is created or destroyed in the provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IgroupName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the initiator Group which is created or destroyed in the provisioning job.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressLunInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the Lun being provisioned or destroyed in a provisioning job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="LunName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the LUN that is provisioned or destroyed</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunPathId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the LUN.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressLunMapInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the mapping of a LUN.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="IgroupId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the initiator Group To which the LUN is mapped.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IgroupName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the initiator Group To which the LUN is mapped.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the LUN that is mapped.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunPathId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the LUN that is mapped.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressNfsexportInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the NFS export created as part of provisioning Operation.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the NFS export by which it can be accessed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Qtree for which the NFS export is created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Qtree for which the NFS export is created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressQtreeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Qtree which is created or destroyed in the provisioning job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="QtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Qtree provisioned or destroyed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Qtree provisioned or destroyed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Volume To which the Qtree belongs To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume To which the Qtree belongs To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressQuotaInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the quota of a Qtree.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DefaultGroupQuota">
                        <xsd:annotation>
                            <xsd:documentation>Default Group quota Value set in bytes. Range: [1..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DefaultUserQuota">
                        <xsd:annotation>
                            <xsd:documentation>Default user quota Value set in bytes. Range: [1..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="QtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Qtree on which the quotas are set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Qtree on which the quotas are set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TreeQuota">
                        <xsd:annotation>
                            <xsd:documentation>Tree quota Value set in bytes. Range: [1..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressScriptRunInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the post provisioning script which is run.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ScriptName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the script with its absolute Path.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressVfilerInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about creating a Vfiler</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="FilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the storage system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the storage system on which the Vfiler is being created.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Ipaddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>IP Address of the Vfiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Ipspace" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>IPspace of the Vfiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the vFiler Unit</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the vFiler Unit which is created</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressVfilerStorageInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about adding storage To a vFiler.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="VfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the vFiler To which storage is added.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the vFiler To which storage is added.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Volume which is added To the vFiler.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume which is added To the vFiler.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressVolumeDedupeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the deduplication Operation on the Volume.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DedupeProgress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The progress of the current deduplication Operation on the Volume with information as To which stage of deduplication is currently in progress and how much data is processed for that stage. For eg: "25 MB Scanned, 20MB Searched, 40MB (20%) Done , 30MB Verified".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeSchedule" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the deduplication schedule set on the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Deduplication Operation Status of the Volume. Possible Values: "idle", "active", "pending", or "undoing".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Volume on which the deduplication is run.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume on which the deduplication Operation is run.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressVolumeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the Volume of on which a provisioning Operation is executed.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Volume on which the provisioning Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume on which the provisioning Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProgressVolumeOptionInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about the Volume Options set.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Volume on which the provisioning Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume on which the provisioning Operation is executed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeOptions" type="na:ArrayOfVolumeOption">
                        <xsd:annotation>
                            <xsd:documentation>A list of of Volume Options and its Values.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProvisionRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Information of a single provisioning Request</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DedupeMemberRequestInfo" type="na:DedupeMemberRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information specific To the 'dedupe_member' Request. Returned only when JobType is 'dedupe_member'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DeleteSnapshotsRequestInfo" type="na:DeleteSnapshotsRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information specific To the Snapshot deletion Request. Returned only when the JobType is 'delete_snapshots'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestroyMemberRequestInfo" type="na:DestroyMemberRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information specific To the 'destroy_member' Request. Returned only when JobType is 'destroy_member'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisionMemberRequestInfo" type="na:ProvisionMemberRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information specific To the 'provision_member' Request. Returned only when JobType is 'provision_member'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResizeMemberRequestInfo" type="na:ResizeMemberRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information specific To the resize related provisioning Request. Returned only when JobType is 'resize_member'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="UndedupeMemberRequestInfo" type="na:UndedupeMemberRequestInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information specific To the 'undedupe_member' Request. Returned only when JobType is 'undedupe_member'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeOption">
                <xsd:annotation>
                    <xsd:documentation>Information about Option and its Value.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="OptionName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of a Volume Option as defined in ONTAP.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OptionValue" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Value of the Volume Option as allowed in ONTAP.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetReference">
                <xsd:annotation>
                    <xsd:documentation>The Name and Id of a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier for the Dataset. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpOssvDirectoryInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one Directory.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>If IsInDataset is true, then this is the ID number of the Dataset To which the Directory belongs. This field is deprecated in favor of Datasets, which lists all Datasets the Directory belongs To. It is still populated with one of the Dataset ids.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Datasets" type="na:ArrayOfDatasetReference">
                        <xsd:annotation>
                            <xsd:documentation>A list of the names and identifiers of the Datasets this Directory belongs To. If IsInDataset is false, this list will be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DirId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Directory. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="HostId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Host that contains this Directory. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host that contains this Directory.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this Directory and it's parent Host are up and online. Since OSSV Hosts can only be contacted with valid credentials, if the login credentials are unset or invalid, the IsAvailable Status will be false. Only output if the call To iter-start included the "IncludeIsAvailable" flag.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsBrowsable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Set To true if the Directory Path can be used as an input To DpOssvDirectoryBrowseIterStart. If set To false, this Path is guaranteed not To have browsable child Paths.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates that the Directory is marked as ignored by Freya/DFM for the purposes of data protection.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInBackupRelationship" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates that the Directory is in a backup relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if the Directory is a member of any Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Path of the Directory.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DpOssvDirectoryName">
                <xsd:annotation>
                    <xsd:documentation>Name of one subdirectory. The Name is relative To the parent Directory ("DirectoryPath" in the DpOssvDirectoryBrowseIterStart API). If the parent Directory was empty, then this will be an absolute Path. The Name will always end with a slash character appropriate To the Host operating system of the OSSV agent, unless the Path is a special Directory which has no children.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpOssvDirectoryRootInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one filesystem root.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FilesystemDevice" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Filesystem device From NDMP. Included only if FsInfo is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FilesystemState" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Filesystem state From NDMP. Included only if FsInfo is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FilesystemType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Filesystem Type From NDMP. Included only if FsInfo is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Host that contains this root. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host that contains this root.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RootPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Path of the filesystem root. For example: "C:\" or "/".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="OssvApplicationInfo">
                <xsd:annotation>
                    <xsd:documentation>Application related information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CanBackup" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true this component can be added To a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsLeaf" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true this Path cannot be browsed further. If false the Path can be specified as input To the DpOssvApplicationListInfoIterStart zapi.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The display Name for the application component.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The application Path To be used for further browsing components under this Path.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="UniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Universal unique identifier for the application component.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="OssvApplicationRestoreDestinationInfo">
                <xsd:annotation>
                    <xsd:documentation>OSSV Host related information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HostFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>The fully qualified domain Name of the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>The ID of the OSSV Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the OSSV Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="OssvHostNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or ID of a Host. IP addresses are also accepted.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpPolicyConnectionInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a connection From one node To another in a DP Policy. The connection's Properties are represented by optional elements. The rules for when a property is present or absent are defined in the property's &lt;b&gt;Description&lt;/b&gt;, and depend on the Type of connection.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>An object ID for the backup schedule for this connection. The backup schedule specifies when To create backup Snapshots and transfer them To backup secondaries. &lt;p&gt; The Value of &lt;b&gt;BackupScheduleId&lt;/b&gt; may be 0, in which case no backup schedule is set for this connection, and Backups will be created only when initiated by the user. If the Value is not 0, it must be the ID of a DP schedule object. &lt;p&gt; If both &lt;b&gt;BackupScheduleId&lt;/b&gt; and &lt;b&gt;BackupScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;BackupScheduleId&lt;/b&gt; determines the ID of the backup schedule, and the Value of &lt;b&gt;BackupScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;BackupScheduleId&lt;/b&gt; nor &lt;b&gt;BackupScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is an ID of 0 (equivalent To a Name of ""), which means no backup schedule is set. &lt;p&gt; Both &lt;b&gt;BackupScheduleId&lt;/b&gt; and &lt;b&gt;BackupScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; for backup connections. &lt;p&gt; This property is present only for backup connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BackupScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>An object Name for the backup schedule for this connection. The backup schedule specifies when To create backup Snapshots and transfer them To backup secondaries. The Value of &lt;b&gt;BackupScheduleName&lt;/b&gt; may be the empty string (""), in which case no backup schedule is set for this connection, and Backups will be created only when initiated by the user. If the Value is not "", it must be the Name of a DP schedule object. &lt;p&gt; If both &lt;b&gt;BackupScheduleId&lt;/b&gt; and &lt;b&gt;BackupScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;BackupScheduleId&lt;/b&gt; determines the ID of the backup schedule, and the Value of &lt;b&gt;BackupScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;BackupScheduleId&lt;/b&gt; nor &lt;b&gt;BackupScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is a Name of "" (equivalent To an ID of 0), which means no backup schedule is set. &lt;p&gt; Both &lt;b&gt;BackupScheduleId&lt;/b&gt; and &lt;b&gt;BackupScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; for backup connections. &lt;p&gt; This property is present only for backup connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FromNodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of node at Source of the connection. This is assigned by the system, and therefore may not be modified. The node at the root of the graph is Id 1. Range: [1..2^31 - 1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="FromNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of node at Source of the connection. It is returned in the Policy list Query with a Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Id">
                        <xsd:annotation>
                            <xsd:documentation>ID of the connection. This is assigned by the system, and therefore may not be modified. Range: [1..2^31 - 1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="IsDrCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether this link is DR capable. This read only flag cannot be changed by DpPolicyModify but will be returned by the DpPolicyListIterNext ZAPI.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsLagErrorEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the system should generate an Error event when the newest backup or mirrored copy is older than &lt;b&gt;LagErrorThreshold&lt;/b&gt;. The default Value of this property is &lt;b&gt;true&lt;/b&gt;. &lt;p&gt; This property is present for both backup and mirror connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsLagWarningEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the system should generate a warning event when the newest backup or mirrored copy is older than &lt;b&gt;LagWarningThreshold&lt;/b&gt;. The default Value of this property is &lt;b&gt;true&lt;/b&gt;. &lt;p&gt; This property is present for both backup and mirror connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LagErrorThreshold">
                        <xsd:annotation>
                            <xsd:documentation>Lag, in seconds. If backup or mirrored copy is older than this amount and if &lt;b&gt;IsLagErrorEnabled&lt;/b&gt; is set, the system generates an Error event. The default Value of this property is 172800 seconds (which is 2 Days). Range: [1..2^31 - 1]. &lt;p&gt; This property is present for both backup and mirror connections.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LagWarningThreshold">
                        <xsd:annotation>
                            <xsd:documentation>Lag, in seconds. If backup or mirrored copy is older than this amount and if &lt;b&gt;IsLagWarningEnabled&lt;/b&gt; is set, the system generates a warning event. The default Value of this property is 129600 seconds (which is 1.5 Days). Range: [1..2^31 - 1]. &lt;p&gt; This property is present for both backup and mirror connections.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MirrorScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>An object ID for the mirror schedule for this connection. The mirror schedule specifies when To transfer data via an &lt;b&gt;asynchronous&lt;/b&gt; mirror. Synchronous and semi-synchronous mirrors are not supported. &lt;p&gt; The Value of &lt;b&gt;MirrorScheduleId&lt;/b&gt; may be 0, in which case no mirror schedule is set for this connection. If the Value is not 0, it must be the ID of a DP schedule object. &lt;p&gt; If no mirror schedule is set for this connection, then the mirror relationship is &lt;b&gt;idle&lt;/b&gt;, which means mirroring occurs only when the user initiates it manually. &lt;p&gt; If both &lt;b&gt;MirrorScheduleId&lt;/b&gt; and &lt;b&gt;MirrorScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;MirrorScheduleId&lt;/b&gt; determines the ID of the mirror schedule, and the Value of &lt;b&gt;MirrorScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;MirrorScheduleId&lt;/b&gt; nor &lt;b&gt;MirrorScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is an ID of 0 (equivalent To a Name of ""), which means no mirror schedule is set. &lt;p&gt; Both &lt;b&gt;MirrorScheduleId&lt;/b&gt; and &lt;b&gt;MirrorScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; for mirror connections. &lt;p&gt; This property is present only for mirror connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MirrorScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>An object Name for the mirror schedule for this connection. The mirror schedule specifies when To transfer data via an &lt;b&gt;asynchronous&lt;/b&gt; mirror. Synchronous and semi-synchronous mirrors are not supported. &lt;p&gt; The Value of &lt;b&gt;MirrorScheduleName&lt;/b&gt; may be the empty string (""), in which case no mirror schedule is set for this connection. If the Value is not "", it must be the Name of a DP schedule object. &lt;p&gt; If no mirror schedule is set for this connection, then the mirror relationship is &lt;b&gt;idle&lt;/b&gt;, which means mirroring occurs only when the user initiates it manually. &lt;p&gt; If both &lt;b&gt;MirrorScheduleId&lt;/b&gt; and &lt;b&gt;MirrorScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;MirrorScheduleId&lt;/b&gt; determines the ID of the mirror schedule, and the Value of &lt;b&gt;MirrorScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;MirrorScheduleId&lt;/b&gt; nor &lt;b&gt;MirrorScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is a Name of "" (equivalent To an ID of 0), which means no mirror schedule is set. &lt;p&gt; Both &lt;b&gt;MirrorScheduleId&lt;/b&gt; and &lt;b&gt;MirrorScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; for mirror connections. &lt;p&gt; This property is present only for mirror connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThrottleScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>An object ID that specifies the throttle schedule for this connection. A throttle schedule specifies an upper limit, varying over time, on the network bandwidth used To make Backups for a single Dataset. This limit applies To the Total amount of bandwidth that may be used at one time by all active transfers over protection relationships associated with this connection. &lt;p&gt; The Value of &lt;b&gt;ThrottleScheduleId&lt;/b&gt; may be 0, in which case no throttle is set for this connection, and there is no limit on data transfer bandwidth. If the Value is not 0, it must be the ID of a DP throttle object. &lt;p&gt; If both &lt;b&gt;ThrottleScheduleId&lt;/b&gt; and &lt;b&gt;ThrottleScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;ThrottleScheduleId&lt;/b&gt; determines the ID of the throttle, and the Value of &lt;b&gt;ThrottleScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;ThrottleScheduleId&lt;/b&gt; nor &lt;b&gt;ThrottleScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is an ID of 0 (equivalent To a Name of ""), which means no throttle is set. &lt;p&gt; Both &lt;b&gt;ThrottleScheduleId&lt;/b&gt; and &lt;b&gt;ThrottleScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. &lt;p&gt; This property is present for both backup and mirror connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThrottleScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>An object Name that specifies the throttle schedule for this connection. A throttle schedule specifies an upper limit, varying over time, on the network bandwidth used To make Backups for a single Dataset. This limit applies To the Total amount of bandwidth that may be used at one time by all active transfers over protection relationships associated with this connection. &lt;p&gt; The Value of &lt;b&gt;ThrottleScheduleName&lt;/b&gt; may be the empty string (""), in which case no throttle is set for this connection, and there is no limit on data transfer bandwidth. If the Value is not "", it must be the Name of a DP throttle object. &lt;p&gt; If both &lt;b&gt;ThrottleScheduleId&lt;/b&gt; and &lt;b&gt;ThrottleScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;ThrottleScheduleId&lt;/b&gt; determines the ID of the throttle, and the Value of &lt;b&gt;ThrottleScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;ThrottleScheduleId&lt;/b&gt; nor &lt;b&gt;ThrottleScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is a Name of "" (equivalent To an ID of 0), which means no throttle is set. &lt;p&gt; Both &lt;b&gt;ThrottleScheduleId&lt;/b&gt; and &lt;b&gt;ThrottleScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. &lt;p&gt; This property is present for both backup and mirror connections.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ToNodeId">
                        <xsd:annotation>
                            <xsd:documentation>ID of node at destination of the connection. This is assigned by the system, and therefore may not be modified. The node at the root of the graph is Id 1. Range: [1..2^31 - 1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ToNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of node at destination of the connection. It is returned in the Policy list Query with a Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the connection. Allowed Values are "backup" or "mirror". This element may not be modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpPolicyContent">
                <xsd:annotation>
                    <xsd:documentation>All content of a single Policy, including its Name, Description, topology (nodes and connections), and the Properties for each node and connection.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the Policy. It may contain From 0 To 255 characters. If the Length of a &lt;b&gt;Description&lt;/b&gt; passed as input To &lt;b&gt;DpPolicyModify&lt;/b&gt; is longer than 255 characters, then the ZAPI fails with Error code EINVALIDPOLICYPROPERTY. The &lt;b&gt;Description&lt;/b&gt; always appears in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. If the &lt;b&gt;Description&lt;/b&gt; is omitted From the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is the empty string "".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpPolicyConnections" type="na:ArrayOfDpPolicyConnectionInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of connections between nodes of the Policy. In the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;, this list is sorted in order of increasing connection ID. In the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, it need not be sorted. However, in input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, there must be a one-one mapping between entries in this array and connections in the Policy graph, or else the call fails because it is attempting To change the Policy's topology. &lt;p&gt; The default Value is an empty list. If a Policy has only a single node and therefore no connections, you may omit this element From the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;. It is always present in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpPolicyNodes" type="na:ArrayOfDpPolicyNodeInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of nodes in the Policy. In the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;, this list is sorted in order of increasing node ID. In the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, it need not be sorted. However, in input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, there must be a one-one mapping between entries in this array and nodes in the Policy graph, or else the call fails because it is attempting To change the Policy's topology.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Policy. Each DP Policy has a Name that is unique among DP policies, but may be the same as an object of some other Type.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpPolicyInfo">
                <xsd:annotation>
                    <xsd:documentation>Contains all information about a single DP Policy, including its content and metadata such as its ID.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DpPolicyContent" type="na:DpPolicyContent">
                        <xsd:annotation>
                            <xsd:documentation>Content of the Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Id" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Object ID for the Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsApplicationCompatible" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If &lt;b&gt;false&lt;/b&gt;, this Policy cannot be assigned To an application Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsModifiable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If &lt;b&gt;false&lt;/b&gt;, this Policy is one of the sample policies that is created at installation time, therefore it may not be deleted using &lt;b&gt;DpPolicyDestroy&lt;/b&gt; and may not be modified using &lt;b&gt;DpPolicyModify&lt;/b&gt;. If &lt;b&gt;true&lt;/b&gt;, it is not one of the sample policies, therefore it may be deleted or modified. This element cannot be modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsNonDisruptiveRestoreCompatible" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If &lt;b&gt;false&lt;/b&gt;, this Policy can not be assigned To a Dataset with the &lt;b&gt;RequiresNonDisruptiveRestore&lt;/b&gt; attribute set. If set To &lt;b&gt;true&lt;/b&gt; and applied To a data set with the &lt;b&gt;RequiresNonDisruptiveRestore&lt;/b&gt; attribute set To true, Protection Manager will configure the Dataset such that Backup connections will support non-disruptive restores. This does not mean that all backup versions and restore requests will support non-disruptive restore &amp;mdash; the caller must check the &lt;b&gt;SupportsNonDisruptiveRestore&lt;/b&gt; output element From the &lt;b&gt;dp-backup-list&lt;/b&gt; iterator.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpPolicyNodeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a node in a DP Policy. The node's Properties are represented by optional elements. The rules for when a property is present or absent are defined in the property's &lt;b&gt;Description&lt;/b&gt;, and depend on the Type of node. &lt;p&gt; There is a set of Properties associated with nodes that determine how long the system retains Backups. Each backup falls into one of these four &lt;b&gt;Retention classes&lt;/b&gt;: &lt;b&gt;hourly&lt;/b&gt;, &lt;b&gt;daily&lt;/b&gt;, &lt;b&gt;weekly&lt;/b&gt;, or &lt;b&gt;monthly&lt;/b&gt;. The following eight Properties determine how long Backups are retained for each of the Retention classes: &lt;UL&gt; &lt;LI&gt; &lt;b&gt;HourlyRetentionCount&lt;/b&gt; &lt;LI&gt; &lt;b&gt;HourlyRetentionDuration&lt;/b&gt; &lt;LI&gt; &lt;b&gt;DailyRetentionCount&lt;/b&gt; &lt;LI&gt; &lt;b&gt;DailyRetentionDuration&lt;/b&gt; &lt;LI&gt; &lt;b&gt;WeeklyRetentionCount&lt;/b&gt; &lt;LI&gt; &lt;b&gt;WeeklyRetentionDuration&lt;/b&gt; &lt;LI&gt; &lt;b&gt;MonthlyRetentionCount&lt;/b&gt; &lt;LI&gt; &lt;b&gt;MonthlyRetentionDuration&lt;/b&gt; &lt;/UL&gt; A backup &lt;b&gt;expires&lt;/b&gt; when its age, in seconds, exceeds the Retention Duration set for its Retention class on the node on which it is stored. After a backup expires, whenever the number of newer Backups in its Retention class at least equals the Retention Count for its class, then the expired backup is deleted. &lt;p&gt; All eight of the Retention Properties are present only on the root node and on backup secondary nodes. On the root node, the Retention Properties apply To local Snapshots created on the root node. On backup secondary nodes, the Retention Properties apply To Backups of primary node data that are stored on the backup secondary node. The Retention Properties are absent From mirror destination nodes because a mirror destination retains the same set of Backups as its mirror Source.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BackupScriptPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Absolute Path on the management station To the script To invoke both before and after backing up a backup primary node. The script is invoked when either a primary node is backed up To a secondary node or a local backup is created on the root node. &lt;p&gt; The Path consists of 0 To 255 characters. If the Length of a &lt;b&gt;BackupScriptPath&lt;/b&gt; passed as input To &lt;b&gt;DpPolicyModify&lt;/b&gt; is longer than 255 characters, then the ZAPI fails with Error code EINVALIDPOLICYPROPERTY. An empty string Value "" indicates no script is invoked. The system does not check whether a non-empty Path string actually refers To an executable script prior To attempting To run the script. The default Value of this property is the empty string "". &lt;p&gt; This property is present only for the root node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="BackupScriptRunAs" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The backup script is run on the management station by the user with this Username. The Value of this property is used only if the management system is running on a Unix Host. On Windows the script is always invoked using the LocalSystem account. &lt;p&gt; The Username consists of 0 To 64 characters. If the Length of a &lt;b&gt;BackupScriptRunAs&lt;/b&gt; passed as input To &lt;b&gt;DpPolicyModify&lt;/b&gt; is longer than 64 characters, then the ZAPI fails with Error code EINVALIDPOLICYPROPERTY. The system does not check whether a user with this Username actually exists prior To attempting To run the script. &lt;p&gt; The default Value of this property is the empty string "". If the property Value is "", then on Unix the script is run by the superuser ("root"). &lt;p&gt; This property is present only for the root node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DailyRetentionCount">
                        <xsd:annotation>
                            <xsd:documentation>Minimum number of Backups From the daily Retention class that the system retains on this node. Range: [0..252]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="252"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DailyRetentionDuration">
                        <xsd:annotation>
                            <xsd:documentation>The age, in seconds, after which a backup From the daily Retention class expires on this node. Range: [0..2^31 - 1]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FailoverScriptPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Absolute Path on the management station To the script To invoke both before and after breaking mirrors during a failover Operation. &lt;p&gt; The Path consists of 0 To 255 characters. If the Length of a &lt;b&gt;FailoverScriptPath&lt;/b&gt; passed as input To &lt;b&gt;DpPolicyModify&lt;/b&gt; is longer than 255 characters, then the ZAPI fails with Error code EINVALIDPOLICYPROPERTY. An empty string Value "" indicates no script is invoked. The system does not check whether a non-empty Path string actually refers To an executable script prior To attempting To run the script. The default Value of this property is the empty string "". &lt;p&gt; This property is present only for the root node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FailoverScriptRunAs" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The failover script is run on the management station by the user with this Username. The Value of this property is used only if the management system is running on a Unix Host. On Windows the script is always invoked using the LocalSystem account. &lt;p&gt; The Username consists of 0 To 64 characters. If the Length of a &lt;b&gt;FailoverScriptRunAs&lt;/b&gt; passed as input To &lt;b&gt;DpPolicyModify&lt;/b&gt; is longer than 64 characters, then the ZAPI fails with Error code EINVALIDPOLICYPROPERTY. The system does not check whether a user with this Username actually exists prior To attempting To run the script. &lt;p&gt; The default Value of this property is the empty string "". If the property Value is "", then on Unix the script is run by the superuser ("root"). &lt;p&gt; This property is present only for the root node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HourlyRetentionCount">
                        <xsd:annotation>
                            <xsd:documentation>Minimum number of Backups From the hourly Retention class that the system retains on this node. Range: [0..252]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="252"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HourlyRetentionDuration">
                        <xsd:annotation>
                            <xsd:documentation>The age, in seconds, after which a backup From the hourly Retention class expires on this node. Range: [0..2^31 - 1]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Id">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the node. This is assigned by the system, and therefore may not be modified. The node at the root of the graph is Id 1. Range: [1..2^31 - 1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsLagErrorEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the system should generate an Error event when the newest local backup copy is older than &lt;b&gt;LagErrorThreshold&lt;/b&gt;. The default Value of this property is &lt;b&gt;true&lt;/b&gt;. &lt;p&gt; This property is present for root node only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsLagWarningEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the system should generate a warning event when the newest local backup copy is older than &lt;b&gt;LagWarningThreshold&lt;/b&gt;. The default Value of this property is &lt;b&gt;true&lt;/b&gt;. &lt;p&gt; This property is present for root node only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LagErrorThreshold">
                        <xsd:annotation>
                            <xsd:documentation>Lag, in seconds. If local backup copy is older than this amount and if &lt;b&gt;IsLagErrorEnabled&lt;/b&gt; is set, the system generates an Error event. The default Value of this property is 172800 seconds (which is 2 Days). Range: [1..2^31 - 1]. &lt;p&gt; This property is present for root node only.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LagWarningThreshold">
                        <xsd:annotation>
                            <xsd:documentation>Lag, in seconds. If local backup copy is older than this amount and if &lt;b&gt;IsLagWarningEnabled&lt;/b&gt; is set, the system generates a warning event. The default Value of this property is 129600 seconds (which is 1.5 Days). Range: [1..2^31 - 1]. &lt;p&gt; This property is present for root node only.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MonthlyRetentionCount">
                        <xsd:annotation>
                            <xsd:documentation>Minimum number of Backups From the monthly Retention class that the system retains on this node. Range: [0..252]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="252"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MonthlyRetentionDuration">
                        <xsd:annotation>
                            <xsd:documentation>The age, in seconds, after which a backup From the monthly Retention class expires on this node. Range: [0..2^31 - 1]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Name" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node. Each node has a Name that is unique within its Policy, but nodes in different policies may share the same Name. If the Length of a &lt;b&gt;Name&lt;/b&gt; passed as input To &lt;b&gt;DpPolicyModify&lt;/b&gt; is longer than 64 characters, then the ZAPI fails with Error code EINVALIDPOLICYPROPERTY.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>An object ID for the Snapshot schedule for this node. The Snapshot schedule specifies when To create local point-in-time Snapshot images on the storage elements that map To this node. &lt;p&gt; The Value of &lt;b&gt;SnapshotScheduleId&lt;/b&gt; may be 0, in which case no Snapshot schedule is set for this node. If no Snapshot schedule is set, no local Snapshots are created. If the Value is not 0, it must be the ID of a DP schedule object. &lt;p&gt; If both &lt;b&gt;SnapshotScheduleId&lt;/b&gt; and &lt;b&gt;SnapshotScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;SnapshotScheduleId&lt;/b&gt; determines the ID of the Snapshot schedule, and the Value of &lt;b&gt;SnapshotScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;SnapshotScheduleId&lt;/b&gt; nor &lt;b&gt;SnapshotScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is an ID of 0 (equivalent To a Name of ""), which means no Snapshot schedule is set. &lt;p&gt; Both &lt;b&gt;SnapshotScheduleId&lt;/b&gt; and &lt;b&gt;SnapshotScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; for the root node of a Policy. &lt;p&gt; This property is present only for the root node. This is because all data on a non-root node comes From mirror or backup connections, and mirroring and Backups create their own Snapshots. Therefore there is no Reason for a non-root node To generate additional Snapshots on its own schedule, because they would contain no new data. &lt;p&gt; If a Policy has been applied To a Dataset whose root storage set contains OSSV Directories, then you cannot set a Snapshot schedule for the root node of the Policy. This restriction exists because OSSV Hosts cannot create local Snapshots.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>An object Name for the Snapshot schedule for this node. The Snapshot schedule specifies when To create local point-in-time Snapshot images on the storage elements that map To this node. &lt;p&gt; The Value of &lt;b&gt;SnapshotScheduleName&lt;/b&gt; may be the empty string (""), in which case no Snapshot schedule is set for this node. If no Snapshot schedule is set, no local Snapshots are created. If the Value is not "", it must be the Name of a DP schedule object. &lt;p&gt; If both &lt;b&gt;SnapshotScheduleId&lt;/b&gt; and &lt;b&gt;SnapshotScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then &lt;b&gt;SnapshotScheduleId&lt;/b&gt; determines the ID of the Snapshot schedule, and the Value of &lt;b&gt;SnapshotScheduleName&lt;/b&gt; is ignored. If neither &lt;b&gt;SnapshotScheduleId&lt;/b&gt; nor &lt;b&gt;SnapshotScheduleName&lt;/b&gt; appear in the input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, then the default Value is a Name of "" (equivalent To an ID of 0), which means no Snapshot schedule is set. &lt;p&gt; Both &lt;b&gt;SnapshotScheduleId&lt;/b&gt; and &lt;b&gt;SnapshotScheduleName&lt;/b&gt; always appear in the output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; for the root node of a Policy. &lt;p&gt; This property is present only for the root node. This is because all data on a non-root node comes From mirror or backup connections, and mirroring and Backups create their own Snapshots. Therefore there is no Reason for a non-root node To generate additional Snapshots on its own schedule, because they would contain no new data. &lt;p&gt; If a Policy has been applied To a Dataset whose root storage set contains OSSV Directories, then you cannot set a Snapshot schedule for the root node of the Policy. This restriction exists because OSSV Hosts cannot create local Snapshots.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="WeeklyRetentionCount">
                        <xsd:annotation>
                            <xsd:documentation>Minimum number of Backups From the weekly Retention class that the system retains on this node. Range: [0..252]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="252"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="WeeklyRetentionDuration">
                        <xsd:annotation>
                            <xsd:documentation>The age, in seconds, after which a backup From the weekly Retention class expires on this node. Range: [0..2^31 - 1]. The default Value of this property is 0. &lt;p&gt; This property is present only for root and backup secondary nodes. &lt;p&gt; For more details, see the Description of &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="DpPolicyNodeName">
                <xsd:annotation>
                    <xsd:documentation>Name of a node in a DP Policy graph. This typedef is an alias for the builtin ZAPI Type &lt;b&gt;string&lt;/b&gt;. A node Name may contain From 1 To 64 characters. It may start with any character and may contain any combination of characters, except that it may not consist solely of decimal digits ('0' through '9'). &lt;p&gt; The Name of each node in a DP Policy must be unique, but nodes in different policies may share the same Name. Node names are always compared in a case-insensitive manner. This means that, for example, "a" and "A" are considered To be the same Name for purposes of: creating new nodes for a new Policy, renaming nodes of an existing Policy, or looking up a Policy's nodes by Name. On the other hand, ZAPIs that return node names do not change the capitalization at all. For example, if a node's Name has been set To "Backup", then &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; returns its Name as "Backup". &lt;p&gt; Note that a node Name has the same format as an &lt;b&gt;ObjName&lt;/b&gt;, and has similar Properties such as case-insensitivity. However, a node Name is not a kind of &lt;b&gt;ObjName&lt;/b&gt; because a DP Policy node is a part of a DP Policy object, but is not itself a first-class DFM object.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpRelationshipInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a single SnapVault or SnapMirror relationship. Currently, there are three kinds of relationships: SnapVault, Qtree SnapMirror (QSM) and Volume SnapMirror (VSM).</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the Dataset this relationship is protecting. Not present if this relationship is not protecting a component of a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset this relationship is protecting. Not present if this relationship is not a protecting a component of a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DeletedBy" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The user who deleted the relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DeletedTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>The time and date when the relationship was deleted.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationAggregateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of destination Aggregate. If the destination object is a Qtree, this is the ID of the Aggregate containing the Volume that contains the Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of storage object where this relationship ends.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationHostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of destination Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationHostName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Fully-qualified domain Name of destination Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM Object ID of storage object where this relationship ends.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of storage object where this relationship ends.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationStoragesetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of the storage set for the destination for this relationship. This element is only valid for the Query if ConnectionId was supplied.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationType" type="na:RelationshipEndpointType">
                        <xsd:annotation>
                            <xsd:documentation>Type of the destination storage object. SnapVault and Qtree SnapMirror relationships always terminate at a Qtree. Volume SnapMirror relationships always terminate at a Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationVolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of destination Volume. If the destination object is a Qtree, this is the ID of the Volume containing that Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DiscoveredTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>The time and date when the relationship was discovered.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Source object for this relationship is being ignored by Protection Manager. See the discussion section for the meaning of "ignoring" Objects.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpImported" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this relationship was at some earlier time imported into a Protection Manager Dataset. A relationship may be marked as imported and dp managed and yet not be in a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpManaged" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this relationship is set To be managed by Protection Manager. See the discussion section for the meaning of "being managed".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpOrphan" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this relationship is considered an orphan by Protection Manager. An orphan relationship is a relationship that is managed by Protection Manager and was once part of a Dataset but is no longer contained in a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpRedundant" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this relationship is considered To be a redundant relationship by Protection Manager. A redundant relationship duplicates the need of a Dataset connection by having it's Source and destination between the same two nodes as another relationship in the same Dataset. It is possible To have more than one redundant relationship in the same Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Source object for this relationship matches a Dataset. &lt;P&gt; A relationship is considered To Match a data set if: &lt;ul&gt; &lt;li&gt; the Source object is a member of a storage set &lt;li&gt; the destination object is a member of a storage set &lt;li&gt; both storage sets are assigned To adjacent nodes of a single Dataset. &lt;/ul&gt; &lt;P&gt; If the relationship does not Match the above criteria, it is not considered part of a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Lag">
                        <xsd:annotation>
                            <xsd:documentation>Seconds since the completion of the last successful transfer To the destination. This Value is undefined and will be returned as 0 for Unintialized relationshaps. Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="LagStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Lag Status of the relationship Lag versus the DP Policy Lag threshold settings. Possible Values are "unknown", "normal", "warning" and "Error".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OperationalStatus" type="na:OperationalStatus">
                        <xsd:annotation>
                            <xsd:documentation>Status of the relationship</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipState" type="na:RelationshipState">
                        <xsd:annotation>
                            <xsd:documentation>State of the relationship</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RelationshipType" type="na:RelationshipType">
                        <xsd:annotation>
                            <xsd:documentation>Type of the relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceAggregateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of Source Aggregate. Not present if the Source object is an OSSV Directory.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of storage object where this relationship originates.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceHostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of Source Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceHostName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Fully-qualified domain Name of Source Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of storage object where this relationship originates.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of storage object where this relationship originates.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceStoragesetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of the storage set for the Source for this relationship. This element is only valid for the Query if ConnectionId was supplied.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceType" type="na:RelationshipEndpointType">
                        <xsd:annotation>
                            <xsd:documentation>Type of the Source storage object. SnapVault relationships originate at either a Qtree or OSSV Directory. Qtree SnapMirror relationships originate at a Qtree. Volume SnapMirror relationships originate at a Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SourceVolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>DFM object ID of Source Volume. Not present if the Source object is an OSSV Directory.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="OperationalStatus">
                <xsd:annotation>
                    <xsd:documentation>Status of the relationship. Possible Values are "idle", "transferring", "pending", "aborting", "migrating", "quiescing", "resyncing", "waiting", "syncing", "in_sync" or "paused". &lt;ul&gt; &lt;li&gt;idle: No data is being transferred. &lt;li&gt;transferring: Transfer has been initiated, but has not yet finished, or is just finishing. &lt;li&gt;pending: The secondary storage system cannot be updated because of a Resource issue; the transfer is retried automatically. &lt;li&gt;aborting: A transfer is being aborted and cleaned up. &lt;li&gt;migrating: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. &lt;li&gt;quiescing: The specified Volume or Qtree is waiting for all existing transfers To complete. The destination is being brought into a stable state. &lt;li&gt;resyncing: The specified Volume or Qtree is being matched with data in the common Snapshot copy. &lt;li&gt;waiting: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. SnapMirror is waiting for a new tape To be put in the tape device. &lt;li&gt;syncing: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. &lt;li&gt;in_sync: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. &lt;li&gt;paused: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="RelationshipEndpointType">
                <xsd:annotation>
                    <xsd:documentation>Type of an object at either the Source or destination of a data protection relationship. Values for Source Objects are "ossv_directory", "Volume" or "Qtree". Values for destination Objects are "Volume" or "Qtree".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="RelationshipState">
                <xsd:annotation>
                    <xsd:documentation>State of the relationship. Possible Values are "uninitialized", "snapvaulted", "snapmirrored", "broken_off", "quiesced", "Source", "unknown" or "restoring" &lt;ul&gt; &lt;li&gt;uninitialized: The destination storage Volume or Qtree is not yet initialized or is being initialized. &lt;li&gt;snapvaulted: Valid only in case of 'snapvault' relationships. The relationship is created and the Qtree is a SnapVault secondary destination. &lt;li&gt;snapmirrored: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. The destination Volume or Qtree is in a SnapMirror relationship. &lt;li&gt;broken_off: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. The destination was in a SnapMirror relationship, but a snapmirror break command made the Volume or Qtree writable. This state is reported as long as the base Snapshot copy is still present in the Volume. If the Snapshot copy is deleted, the state is listed as "uninitialized" if the destination is in the /etc/snapmirror.conf filen then the Snapshot copy is no longer listed. A successful snapmirror resync command restores the snapmirrored Status. &lt;li&gt;quiesced: Valid only in case of 'qtree_snapmirror' or 'volume_snapmirror' relationships. SnapMirror is in a consistent internal state and no SnapMirror activity is occurring. In this state, you can create Snapshot copies with confidence that all destinations are consistent. The snapmirror quiesce command brings the destination into this state. The snapmirror resume command restarts all SnapMirror activities. &lt;li&gt;Source: This state is reported when the snapvault Status or snapmirror Status command is run on the primary storage system. When the destination is on another system, its Status is unknown, so the Source Status is reported. In case of 'snapvault' relationships, it also appears if snapvault Status is run on secondary storage systems after the snapvault restore command was run on an associated primary storage system. &lt;li&gt;unknown: The destination Volume or the Volume that contains the destination Qtree is in an unknown state. It might be offline or restricted &lt;li&gt;restoring: Valid only in case of 'snapvault' relationships. &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="RelationshipType">
                <xsd:annotation>
                    <xsd:documentation>Type of a data protection relationship. Legal Values are "snapvault", "qtree_snapmirror" and "volume_snapmirror".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DpPathInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Path inside a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="MemberNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or Id of the Dataset component that is at the root of the file tree. This may be Qtree, ossv Directory or Volume Id that is Source of the physical data protection relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Path. The Maximum Path Length is 32767 characters. This Path is relative To "MemberNameOrId" Path in the storage system or OSSV Host. Path cannot be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy on the primary where the data being restored originated. This is ignored if PrimarySnapshotUniqueId is specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data being restored originated. Currently, this is the Snapshot copy's creation time. This is used To differentiate between multiple copies of the root object (specified by MemberNameOrId input) in the same backup. If not specified and different versions of the root object exist in two Snapshot copies in the backup, then the restore might be ambiguous.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RestoreConfiguration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Valid only when an OSSV Directory being restored is a Virtual Machine. If false the configuration of the Virtual Machine is not changed, only Disks are restored. If true, the configuration and data are restored. Default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DpRecoverMemberInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a member inside a Dataset.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DestinationHost" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Host To restore this Dataset member To. The destination Host must be compatible with the member Type of the member being restored. For example, if the member is a Volume, then this destination Host must be a storage system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Path To restore this Dataset member To. The Path will be interpreted relative To DestinationHost. &lt;BR&gt; If the destination Host is a storage system, the Path must not already exist. If the destination Host is an OSSV, the Path will be overwritten. In case of a Virtual Machine restore To the original location: &lt;li&gt;The Path must either be an empty string or not be specified. &lt;li&gt;The restore will happen through the destination Host. &lt;BR&gt; The format of this Value depends on the Host Type of DestinationHost. If DestinationHost is a storage system, then it should be of the form "/vol1/[qtree1][/dir1..]". If a full Volume restore is being specified, then the destination Path must be a Volume "/vol". If a full Qtree restore is specified, and if the destination is a storage system, destination Path can be either "/vol" or "/vol/qtree" and if it is "/vol", the server automatically appends the Qtree Name To the destination Path To turn it into "/vol/qtree" format. If DestinationHost is an OSSV Host, then it should be a pathname appropriate for the OSSV Host. A Windows Host will accept Paths such as "C:\My Documents" and a UNIX Host will accepts Paths such as "/home/user". &lt;P&gt; If the specified DatasetNameOrId is of an &lt;b&gt;application data set&lt;/b&gt;, all the above rules apply. In addition, the files will be restored under a uniquely named Directory under the destination Path. The Directory Name is created by adding together three separate pieces of information (listed below) separated by a "_" character: &lt;ul&gt; &lt;li&gt; Name of the primary Snapshot where data originated. All characters except [A-Z], [a-z], [0-9], '.', '-', '_', ')' and '(' are stripped From the Snapshot Name and the Name is trimmed To the first 42 characters before it is used. The 42 character limit ensures that the Total Length of the uniquely named Directory does not exceed 64 characters. &lt;li&gt; The DFM identifier of the primary Qtree where the data originated. &lt;li&gt; The DFM identifier of the Snapshot. This is currently the Timestamp when the Snapshot was created. &lt;/ul&gt; &lt;BR&gt; The Maximum destination Length is 32767 characters. In some cases, shorter destination lengths will fail due To limitations of underlying storage systems. Default Value is an empty string.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationPathSkipExtraDirectory" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If this input is specified and is true, no extra Directory will be added To the destination Path. See DestinationPath for more information on how an extra Directory is added To the destination Path for an application Dataset. If the Dataset is not an applicatoin Dataset, this input has no Effect. Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the Dataset component that is at the root of the file tree. This may be Qtree, ossv Directory or Volume Id that is Source of the physical data protection relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Path" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Path. The Maximum Path Length is 32767 characters. This Path is relative To "MemberNameOrId" Path in the storage system or OSSV Host. Path cannot be empty. "/" is considered as full member restore when the member is a Volume, Qtree or OSSV Directory.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy on the primary where the data being restored originated. This is ignored if PrimarySnapshotUniqueId is specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrimarySnapshotUniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Id of the Snapshot copy on the primary where the data being restored originated. Currently, this is the Snapshot copy's creation time. This is used To differentiate between multiple copies of the root object (specified by MemberNameOrId input) in the same backup. If not specified and different versions of the root object exist in two Snapshot copies in the backup, then the restore might be ambiguous.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RestoreConfiguration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Valid only when an OSSV Directory being restored is a Virtual Machine. If false the configuration of the Virtual Machine is not changed, only Disks are restored. If true, the configuration and data are restored. Default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="OverwriteResult">
                <xsd:annotation>
                    <xsd:documentation>Information about the member and the destination.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DestHost" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Destination Host where file will be restored..</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FilePath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>destination Path where the file was being restored. The Path includes the Name of the file being restored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OverwriteStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>For ONTAP Version below 7.3.0, we cannot check for overwrite. In that case, this element will return a predefined string indicating overwrite Status could not be checked. For other cases, the overwrite Status will be returned. Possible Values : "overwrite", "overwrite_check_unsupported"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="SpaceStatusResult">
                <xsd:annotation>
                    <xsd:documentation>Information about the destination Volume which does not have enough space for the restore</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AvailSpace" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>Free space available in the Volume in KB. &lt;BR&gt; Range: [0..2^64-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestHost" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the destination Host where the restore would take place.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestVol" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the destination Volume where the restore would take place.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReqSpace" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>Space required in the Volume for restore in KB. &lt;BR&gt; Range: [0..2^64-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DayInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a Day list</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Day">
                        <xsd:annotation>
                            <xsd:documentation>Day of the week. Range: [0..6]. (Sun = 0)</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="6"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ThrottleAssignee">
                <xsd:annotation>
                    <xsd:documentation>Description of a DFM object using the DP throttle.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AssigneeFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of a DFM object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AssigneeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identification number of a DFM object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ThrottleContent">
                <xsd:annotation>
                    <xsd:documentation>Attributes of a throttle schedule</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsModifiable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If &lt;b&gt;false&lt;/b&gt;, this throttle is one of the sample throttle that is created at installation time, therefore it may not be modified, renamed or destroyed. If &lt;b&gt;true&lt;/b&gt;, it is not one of the sample throttles, therefore it may be modified, renamed or destroyed. &lt;b&gt;IsModifiable&lt;/b&gt; always appears in the output. It is not possible To use it as input.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThrottleDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the throttle. It may contain From 0 To 255 characters. The &lt;b&gt;Description&lt;/b&gt; always appears in the output. If the Description is omitted, then the default Value is the empty string "".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThrottleId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the throttle schedule. Element is ignored for throttle-create. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ThrottleItemList" type="na:ArrayOfThrottleItemInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of individual throttle items To be added</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ThrottleName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the throttle schedule</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ThrottleItemInfo">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a throttle item</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DayList" type="na:ArrayOfDayInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of Days applied To the throttle item. If none is supplied, it will be applied To every Day.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EndHour">
                        <xsd:annotation>
                            <xsd:documentation>End hour of the throttle item. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="EndMinute">
                        <xsd:annotation>
                            <xsd:documentation>End minute of the throttle item. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ItemId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier for the throttle item. Ignored in input by all zapi calls. Will be present in output. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartHour">
                        <xsd:annotation>
                            <xsd:documentation>Start hour of the throttle item. Range: [0..23]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="23"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="StartMinute">
                        <xsd:annotation>
                            <xsd:documentation>Start minute of the throttle item. Range: [0..59]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="59"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Throughput">
                        <xsd:annotation>
                            <xsd:documentation>Throttle Throughput in KBytes. Range: [0..(2^63)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="EventActionInfo">
                <xsd:annotation>
                    <xsd:documentation>Result of Action taken on event. Timestamp returned on success, and Error code on failure.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ErrorCode">
                        <xsd:annotation>
                            <xsd:documentation>Error code corresponding To Errno returned From event acknowledge/delete. Absent on success. Range: [1..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="4294967295"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ErrorMessage" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Error message returned From event acknowledge/delete. Absent on success.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The input event identifier. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Timestamp" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when the event was acknowledged/deleted. Timestamps absent for IDs that can not be found, or have already been acknowledged/deleted. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="EventApplicationType">
                <xsd:annotation>
                    <xsd:documentation>Denotes the kind of application the event is for. &lt;P&gt; Possible Values: 'monitoring', 'data_protection' , 'performance' , 'performance_diagnosis'</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="EventIdType">
                <xsd:annotation>
                    <xsd:documentation>Event identifier. Range: [1..2^32-1]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="EventInfo">
                <xsd:annotation>
                    <xsd:documentation>Event information structure</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EventAbout" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the event Type</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventAcknowledged" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when event is acknowledged, or 0 if not acknowledged.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventAcknowledgedUser" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User who acknowledged the event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EventArguments" type="na:ArrayOfKeyValuePair">
                        <xsd:annotation>
                            <xsd:documentation>Argument list for this particular event. Present only if IncludeEventArguments was set To true in the EventListIterStart call. If the event has no arguments, this element will be empty. For example, some possible arguments are jobId, backupJobId, protectionJobId, or datasetId (the Values for these all integer ids). The arguments returned are dependent on the event Type and Status. The list of possible arguments is variable with each Version and large which is why it is not included here.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventCondition" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Condition of the event</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventDeleted" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when event is deleted, or 0 if not deleted.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventDeletedUser" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User who deleted the event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the event. Range: [1..2^31 - 1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="EventName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the event. The list of all event names can be obtained using EventclassList APIs. The element eventclass-info -&gt; event-names[] -&gt; EventNamePretty gives the Name of an event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EventOriginatingId">
                        <xsd:annotation>
                            <xsd:documentation>This is only returned if the EventType is object-deleted. It's the ID of the deleted object. And in this case, the EventSourceId is the management station ID. Range: [1..2^31 - 1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="EventSeverity" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Severity of the event</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventSourceId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Source of the event. Range: [1..2^31 - 1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="EventSourceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Source of the event. Example: "storage01.example.com".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EventSourceNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the Name of the Dataset node the event Source is contained in. This is only returned in the case where IncludeDatasetResourceStatusEvents is set To true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventSourceType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of object that generated the event. Possible Values: &lt;BR&gt; unknown &lt;BR&gt; resource_group &lt;BR&gt; Host &lt;BR&gt; Aggregate &lt;BR&gt; Volume &lt;BR&gt; Qtree &lt;BR&gt; Interface &lt;BR&gt; administrator &lt;BR&gt; network &lt;BR&gt; mgmt_station &lt;BR&gt; configuration &lt;BR&gt; quotauser &lt;BR&gt; initiator_group &lt;BR&gt; lun_path &lt;BR&gt; fc_switch_port &lt;BR&gt; fcp_target &lt;BR&gt; Directory &lt;BR&gt; hba &lt;BR&gt; fcp_initiator &lt;BR&gt; san_host_cluster &lt;BR&gt; srm_path &lt;BR&gt; mirror &lt;BR&gt; script &lt;BR&gt; script_schedule &lt;BR&gt; script_job &lt;BR&gt; role &lt;BR&gt; data_set &lt;BR&gt; storage_set &lt;BR&gt; resource_pool &lt;BR&gt; dp_policy &lt;BR&gt; dp_schedule &lt;BR&gt; dp_throttle &lt;BR&gt; ossv_directory &lt;BR&gt; prov_policy &lt;BR&gt; vfiler_template &lt;BR&gt; disk</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Time when the event was fired.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type or class To which the event belongs To. A list of event types can be obtained by using EventclassListIterStart APIs. The element eventclass-info -&gt; EventClassName in eventclass-info gives the Name of an event Type.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDeleted" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Deprecated in favor of EventDeleted which returns the deleted Timestamp</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="EventTimestampRange">
                <xsd:annotation>
                    <xsd:documentation>range of event timestamps</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EndTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>End Timestamp, in seconds elapsed since midnight on January 1, 1970.(UTC)</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StartTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Start Timestamp, in seconds elapsed since midnight on January 1, 1970.(UTC)</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="EventTypeFilter">
                <xsd:annotation>
                    <xsd:documentation>Array of event filters.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EventFilter" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the EventFilter.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="EventClassInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about an event class.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AboutMessage" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the event class.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventClassId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the custom event class or 0 in case of a canned event class.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventClassName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>event class Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventNames" type="na:ArrayOfEventNameInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of event names for this event class.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsAllowDuplicates" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Event Service will not drop duplicate Events of this event class if IsAllowDuplicates is true. Event is duplicate if it has same EventName as previous event with same EventClass and the same event-source. It is false by default.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsMultiCurrent" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Event Service keeps multiple current Events of this EventClass for each event-source. Valid only with allow-duplicates. It is false by default.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="EventClassObject">
                <xsd:annotation>
                    <xsd:documentation>Custom event class.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EventClassName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Custom event class Name or its database identifier.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="EventNameInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about an event Name.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="EventNamePretty" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the event Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="EventNameShort" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Short Name of the event Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Severity" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Severity of the event Name. Possible Values: Emergency, Critical, Error, Warning, Information, Normal.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="TargetInfo">
                <xsd:annotation>
                    <xsd:documentation>Information of about one Target.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Storage System on which the Target is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DNS Name of the Storage System on which the Target is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TargetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Target in DFM Server database.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TargetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Target (ex: 0c).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TargetPortName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>WWPN of the Target.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TargetStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Operation Status of the Target,Possible Values: "startup","uninitialized","initializing_fw", "link_not_connected","waiting_for_link_up", "online","link_disconnected","resetting", "offline","offlined_by_user_system", "unknown".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="GraphLineValueInfo">
                <xsd:annotation>
                    <xsd:documentation>The sample Values of a line in a graph.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="SampleName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the sample. Maximum Length: 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SampleValues" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A comma separated list of Timestamp:Value pairs. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. The Values may have optional decimal extensions, for example 1064439599:127, 1064439600:98.6, 1064439601:12. If the Value of the sample is not available for a particular time, then the Value returned will be empty e.g. (1188779400:).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="GroupInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a single Group.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="GroupPerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Status of the Group based on performance Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="GroupStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Status of the Group based on all Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HasPrivilege" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if user has the Privilege checked by GroupListIterStart API. If TRUE, user has the requested Privilege on this Group. If FALSE, user does not have the requested Privilege, but Group is included because user has the requested Privilege on one or more subgroups of this Group. Group privileges are set using the RBAC APIs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Id">
                        <xsd:annotation>
                            <xsd:documentation>Numeric identifier of the Group. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ParentGroupId">
                        <xsd:annotation>
                            <xsd:documentation>Numeric identifier of the parent Group, if any. This element is not present for top level Groups. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ShortName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Short Name of the Group. This is a short Name which does not include Name of the parent.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SubgroupCount">
                        <xsd:annotation>
                            <xsd:documentation>Number of sub-groups under this parent Group. &lt;BR&gt; Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Type of the Members of the Group. Multiple Values are separated by commas. Possible Values: Empty, Hosts, Volumes, Qtrees, Configurations, Lun Paths, SRM Paths, Aggregates, Datasets, and Resource Pools.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="GroupNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or ID of a Group. If a Group Name is specified, it must be fully qualified.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="GroupOptionInfo">
                <xsd:all>
                    <xsd:element minOccurs="0" name="ChargebackRate" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The monthly chargeback cost, represented as a decimal floating-point number. Default: 0</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupContact" type="na:EmailAddressList">
                        <xsd:annotation>
                            <xsd:documentation>Contact of the Resource Group. This is modifiable. Possible Value is e-mail of the owner.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupOwner" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Owner of the Resource Group. This is modifiable.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SrmMaxLargeFiles">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of large files To track during SRM walks on Paths in this Group. Default: 20 &lt;BR&gt; Range: [0..100000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SrmMaxNewMtimeFiles">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of files with new mtimes To track during SRM walks on Paths in this Group. Default: 20 &lt;BR&gt; Range: [0..100000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SrmMaxOldAtimeFiles">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of files with old atimes To track during SRM walks on Paths in this Group. Default: 20 &lt;BR&gt; Range: [0..100000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SrmMaxOldMtimeFiles">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of files with old mtimes To track during SRM walks on Paths in this Group. Default: 20 &lt;BR&gt; Range: [0..100000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ObjectNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or ID of an object.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="Group">
                <xsd:annotation>
                    <xsd:documentation>Group Name or identifier</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="GroupMemberAttribute">
                <xsd:annotation>
                    <xsd:documentation>Additional named Attributes of the DFM object Current Attributes are: 'OS Version', 'OS Revision', and 'Primary Address'</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the attribute.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Value of the attribute.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="GroupMemberInfo">
                <xsd:all>
                    <xsd:element minOccurs="0" name="GroupMemberAttributes" type="na:ArrayOfGroupMemberAttribute">
                        <xsd:annotation>
                            <xsd:documentation>Attributes of the DFM object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Id" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DFM Id of the DFM object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DFM Name of the DFM object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>The performance Status of the DFM object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Status" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>The Status of the DFM object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SubType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>For Members of Type Host, this is the kind of Host; possible Values: Filer, Vfiler, agent, ossv, cluster, vserver. For all other Members, this field is absent.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the DFM object which can be one of Host, Aggregate, Volume, Qtree, Configuration, Initiator Group, Lun Path, FCP Target, FCP Initiator, SRM Path, Resource Pool, or Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="AccessObjectDescription">
                <xsd:annotation>
                    <xsd:documentation>Description of an access object. An access object can be a role, usergroup, local user, or a domain user. Description of an access object can include any alphanumeric character, a space, or a punctuation character other than &lt;b&gt;:&lt;/b&gt;(colon). Maximum Length: 128 characters</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="AccessObjectId">
                <xsd:annotation>
                    <xsd:documentation>Identification number (ID) for an access object. An access object can be a role, usergroup, local user or a domain user. The ID for an access object is always assigned by the DFM system. This typedef is an alias for the built-in Type &lt;b&gt;integer&lt;/b&gt;. Access object IDs are unsigned integers in the range [1..2^31-1].</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:simpleType name="AccessObjectName">
                <xsd:annotation>
                    <xsd:documentation>Name of an access object. An access object can be a role, usergroup, local user, or a domain user. The rules defined here are not applicable for domain users and usergroups. An access object can contain between 1 and 32 characters and include any alphanumeric character, a space, or a punctuation character that is not one of: &lt;br&gt;" * + , / : ; &lt; = &gt; ? [ ] |</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="AccessObjectNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or Id of an access object. An access object can be a role, usergroup, local user, or a domain user. This must conform To the format of either AccessObjectName or AccessObjectId.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="Capability">
                <xsd:annotation>
                    <xsd:documentation>Name of a Capability on the Host. This must conform To one of the following formats: &lt;ul&gt; &lt;li&gt; "*" &lt;li&gt; "login-*" &lt;li&gt; "security-*" &lt;li&gt; "cli-*" &lt;li&gt; "api-*" &lt;/ul&gt; Here, instead of *, commands and sub-commands can be specified directly. Maximum Length: 64 characters</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="DomainuserName">
                <xsd:annotation>
                    <xsd:documentation>Name of the user in domain\username format. (Ex:NETAPP\rohan) Maximum Length: 288 characters (Domain Name can contain up To 255 characters, and Username can contain up To 32 characters)</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="DomainuserNameOrIdOrSid">
                <xsd:annotation>
                    <xsd:documentation>Name or Id or the Sid of domain user. This must conform To one of the following: &lt;ul&gt; &lt;li&gt; DomainuserName &lt;li&gt; Sid &lt;li&gt; access-cotrol-id &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="FullNdmpCredentials">
                <xsd:annotation>
                    <xsd:documentation>A full set of ndmp credentials with no empty fields which is a specific requirement for this zapi since NdmpUsername and NdmpPassword are both required in order To add an ossv Host.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="NdmpPassword" type="na:HostPassword">
                        <xsd:annotation>
                            <xsd:documentation>Password Name for logging into the Host. Encrypted using 2-way encryption.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpPort" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>Port To connect on.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="NdmpUsername" type="na:NdmpUsername">
                        <xsd:annotation>
                            <xsd:documentation>User Name for logging into the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostDefaults">
                <xsd:annotation>
                    <xsd:documentation>The default Values for the Attributes defined by the Host.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AdminPortAgent" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The agent's default administrative port for executing ONTAP APIs. Valid only for Host Agents.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminPortCacheHttp" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's default HTTP administrative port for executing ONTAP APIs. Valid only for NetCache appliances.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminPortCacheHttps" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's default HTTPS administrative port for executing ONTAP APIs. Valid only for NetCache appliances.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminPortHost" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's default administrative port for executing ONTAP APIs. Valid only for storage systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminPortHostHttp" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's default HTTP administrative port for executing ONTAP APIs. Valid only for storage systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminPortHostHttps" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's default HTTPS administrative port for executing ONTAP APIs. Valid only for storage systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminTransportAgent" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The default Value for the transport used for communicating To the Agent. Possible Values: are "http", "https"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminTransportCache" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The default Value for the transport used for communicating To the cache. Possible Values: "http", "https"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminTransportHost" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The default Value for the transport used for communicating To the Host. Possible Values: "http", "https"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="NdmpPort" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>Default Value for NDMP port. Valid only for storage systems and OSSV agents.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PerfAdvisorTransportHost" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The default Value for the transport setting for communicating To the Host for collecting performance data. Valid only for storage systems. Possible Values: "http_only", "https_ok"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SnapvaultMaxBackupThreads">
                        <xsd:annotation>
                            <xsd:documentation>Default Maximum number of threads the DFM can use To coordinate in parallel the backup transfers for different backup relationships To the same secondary Volume. This field is applicable only To storage systems that are SnapVault Secondary Hosts. &lt;P&gt; Range: [1..144]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="144"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Timeout">
                        <xsd:annotation>
                            <xsd:documentation>Default Value of Timeout we use in zapis that accept Timeout arguments. Time is in seconds. Range: [1..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="UseHostsEquiv" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>The setting for communicating To the Host using Hosts.equiv authentication. Valid only for storage systems and vFiler units.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostDomainuserInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the contents of a domain user on the Host. The Host can be a Storage System or a vFiler Unit. Output will always contain all the elements present in the Type definition.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Sid" type="na:Sid">
                        <xsd:annotation>
                            <xsd:documentation>Sid of the domain user on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Capabilities" type="na:ArrayOfCapability">
                        <xsd:annotation>
                            <xsd:documentation>List of Capabilities of the domain user inherited From the usergroup(s) in which user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostDomainuserId" type="na:AccessObjectId">
                        <xsd:annotation>
                            <xsd:documentation>Internal Id of domain user on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostDomainuserName" type="na:DomainuserName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the domain user on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Host on which the domain user is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host on which the domain user is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleIds" type="na:ArrayOfHostRoleId">
                        <xsd:annotation>
                            <xsd:documentation>List of ids of roles contained by usergroup(s) in which the domain user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleNames" type="na:ArrayOfHostRoleName">
                        <xsd:annotation>
                            <xsd:documentation>List of names of roles contained by usergroup(s) in which the domain user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsergroupIds" type="na:ArrayOfHostUsergroupId">
                        <xsd:annotation>
                            <xsd:documentation>List of ids of usergroups in which the domain user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsergroupNames" type="na:ArrayOfHostUsergroupName">
                        <xsd:annotation>
                            <xsd:documentation>List of usergroup names in which the domain user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostDpFilterInfo">
                <xsd:annotation>
                    <xsd:documentation>Data Protection specific information for this iterator. Default is false.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only list Aggregates that have been set To be ignored for purposes of data protection. If false, only list Aggregates that have not been set To be ignored for purposes of data protection. If not specified, list all Aggregates without taking into account whether they have been ignored or not.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only Hosts in a Dataset are listed Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsInResourcepool" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only Hosts in a Resource pool are listed Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapmirroredOnly" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only SnapMirror Hosts are listed. Host could be either a Source or a destination for SnapMirror. Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapvaultPrimaryOnly" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only SnapVault primary systems are listed. Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapvaultSecondaryOnly" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only SnapVault secondary systems are listed. Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsUnprotected" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, only list Hosts which are not protected, which means it is: &lt;ul&gt; &lt;li&gt; 1. not in any Resource pool. &lt;li&gt; and 2. not a member of a node in a Dataset with protection Policy assigned. &lt;/ul&gt; If false or not set, list all Hosts.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostDpInfo">
                <xsd:annotation>
                    <xsd:documentation>Data Protection specific information for this iterator.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Datasets" type="na:ArrayOfDatasetReference">
                        <xsd:annotation>
                            <xsd:documentation>List of Datasets the Host is a member of. If IsInDataset is false, this list will be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostDataset" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset the Host is a member of. This element will not be present if the Host is not a member of a Dataset. This field is deprecated in favor of Datasets, which lists all Datasets the Host belongs To. It is still populated with one of the Dataset ids.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostResourcepool" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool the Host is a member of. This element will not be present if the Host is not a member of a Resource pool.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAgentOssvEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if the ossv Service has been enabled. Valid only for Host Agents.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if an administrator has chosen To ignore this Host for purposes of data protection.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if this Host is a member of any Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsLinuxPrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as having a Linux primary License. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsNdmpEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To enable ndmp on this Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsNearstore" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as having a Nearstore License. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapmirrorEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To enable snapmirror on this Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapmirrorHost" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as a SnapMirror Host. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapvaultEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To enable snapvault on this Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapvaultPrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as a SnapVault primary system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapvaultSecondary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as a SnapVault secondary system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsUnixPrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as having a Unix primary License. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsWindowsOfmPrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as having a Windows Open File Manager (OFM) primary License. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsWindowsPrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates if Host is being managed as having a Windows primary License. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpAccessSpecifier" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the access expression ndmp uses To determine who has access. Valid only for storage systems. See na_protocolaccess(8) for access specifier syntax and usage. Examples of valid Values include "all", or "host=abc,xyz AND if=e0". See na_protocolaccess(8) for access specifier syntax and usage. Length: [0..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SnapmirrorAccessSpecifier" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the access expression snapmirror uses To determine who has access. Valid only for storage systems. Examples of valid Values include "all", or "host=abc,xyz AND if=e0". See na_protocolaccess(8) for access specifier syntax and usage. Length: [0..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SnapvaultAccessSpecifier" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the access expression snapvault uses To determine who has access. Valid only for storage systems. Examples of valid Values include "all", or "host=abc,xyz AND if=e0". See na_protocolaccess(8) for access specifier syntax and usage. Length: [0..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapvaultMaxBackupThreads">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of threads the DFM can use To coordinate in parallel the backup transfers for different backup relationships To the same secondary Volume. If this element is present and empty, the global default Value is used. This field is applicable only To SnapVault Secondary Hosts. Use HostGetDefaults To determine the global default Value. &lt;P&gt; Range: [1..144]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="144"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostDpModifyInfo">
                <xsd:annotation>
                    <xsd:documentation>Data protection specific Host information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if an administrator has chosen To ignore this Host for purposes of data protection. The default Value is false. If not present, the current setting is not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapvaultMaxBackupThreads">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of threads DFM can use To coordinate in parallel the backup transfers for different backup relationships To the same secondary Volume. This field is applicable only To SnapVault Secondary Hosts. If the element is present and empty or the Value is 0, the default Value set in the global Options will be used. If not present, the current setting is not modified. &lt;P&gt; Range: [0..144]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="144"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="HostId">
                <xsd:annotation>
                    <xsd:documentation>DFM Host identifier. &lt;P&gt; Range: [1..2^31-1]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="HostInfo">
                <xsd:annotation>
                    <xsd:documentation>Host's information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AdminPort" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's administrative port for executing Manage OnTap APIs. Valid only for Storage Systems, NetCache appliances, and Host Agents. If this element is present and empty, the global default Value is used. Use HostGetDefaults To determine the global default Value.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminTransport" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The transport used for communicating To the Host. Possible Values: "http", "https". If this element is present and empty, the global default Value is used. Use HostGetDefaults To determine the global default Value.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CifsDomainInfo" type="na:CifsDomainInfo">
                        <xsd:annotation>
                            <xsd:documentation>CIFS domain informaiton of storage systems or vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Host's primary IP Address.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostCommunicationStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Whether we are able To establish a connection To validate the Host credentials. Valid only for storage systems and Host Agents. Possible Values: "unknown", "up", or "down".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostCredentialsStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The current Status of the Storage System or Host Agent credentials. Possible Values: "not_applicable", "unknown", "bad", "good", "read_only" (Storage System will never have a Status of "read_only"). This Value reflects whether the credentials were validated or invalidated by the Storage System or Host Agent. &lt;P&gt; "unknown" means that the DFM has not been able To test the credentials (username/password) against the Storage System or Host Agent. &lt;/P&gt;&lt;P&gt; The Value of this element will not change if we are unable To communicate with the Host. The DFM can access the Host Agent if HostCredentialsStatus is "good" or "read_only" and HostCommunicationStatus is "up". &lt;/P&gt;&lt;P&gt; If the Host Agent credentials are guest credentials, and have been validated by the Host Agent, the Value will be "read_only". The Value "not_applicable" applies To Hosts (vFiler units only for now) where login credential Status is not meaningful To the DFM. &lt;/P&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User-specified Description of Host. Length: [0..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostDpInfo" type="na:HostDpInfo">
                        <xsd:annotation>
                            <xsd:documentation>Data Protection specific information for this Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostFqdn" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The fully qualified domain Name of the Host. Length: [1..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="na:HostId">
                        <xsd:annotation>
                            <xsd:documentation>This is the DFM Id of the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostModel" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Model Name or "unknown". Length: [1..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the DFM Name of the Host. Length: [1..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostObjStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Host based on all Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostOs" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the OS Version for the Host. On OSSV Agents this is the Windows OS (Windows 2000, etc.) On all other Hosts this is the software release Length: [1..16]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostPerfInfo" type="na:HostPerfInfo">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Host based on all Events NdmpCredentialsStatus will not be updated if NdmpCommunicationStatus is bad because the DFM is not able To connect To the ndmp agent on the storage system or OSSV agent To validate the credentials.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The current Status of the Host. This element displays the Status of the Host os, which is ONTAP in the case of storage systems, and is Windows, Linux etc. in the case of Host Agents or OSSV agents. Possible Values: "unknown", "up", or "down".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostType" type="na:HostType">
                        <xsd:annotation>
                            <xsd:documentation>Type of the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostUsername" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the administrator Username for a requested Host. Length: [1..64]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostVersion" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This is the software release for a requested Host. Length: [1..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Tells whether or not this Host is up. For OSSV clients, if valid login credentials are not set, the IsAvailable state will be false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Licenses" type="na:ArrayOfLicense">
                        <xsd:annotation>
                            <xsd:documentation>List of Licenses installed on the storage system. This will be returned only if the HostType is "Filer".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpAgentStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The current Status of NDMP. Possible Values: "unknown", "up", or "down". Valid only for storage systems and OSSV agents. This Status is more than the combined Result of NdmpCommunicationStatus and NdmpCredentialsStatus, since a Value of "up" indicates the DFM monitor was successful in fully establishing the connection To the point that useful messages can be sent (this requires steps beyond exchanging credentials). If the Value is "down" you need To look at NdmpCommunicationStatus or NdmpCredentialsStatus. If those Status Values do not indicate problems, the problem may be occurring after credentials have been exchanged.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpCommunicationStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Whether we are able To establish a connection To validate the NDMP credentials. Valid only for storage systems and OSSV agents. Possible Values: "unknown", "up", or "down".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpCommunicationTimestamp" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Date of the last attempt To establish a connection To validate the NDMP credentials. Valid only for storage systems and OSSV agents. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpCredentials" type="na:NdmpCredentials">
                        <xsd:annotation>
                            <xsd:documentation>NDMP credentials for the Host. Valid only for storage systems and OSSV agents. The ndmp Password will always be empty for security reasons.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpCredentialsStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The current Status of the NDMP credentials. Valid only for storage systems and OSSV agents. Possible Values: "not_applicable", "unknown", "good", or "bad". The Value "not_applicable" applies To Hosts (vFiler units only for now) where ndmp credential Status is not meaningful.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpTimestamp" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Date of the last successful connection (i.e. the last time NdmpAgentStatus was "up"). Valid only for storage systems and OSSV agents. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OtherHostId" type="na:HostId">
                        <xsd:annotation>
                            <xsd:documentation>A Host Agent and an OSSV Agent on the same machine will have different IDs. If this Host is an OSSV Agent and DFM knows about a Host Agent on the same machine, or if this Host is an Host Agent and DFM knows about a OSSV Agent on the same machine, this Value is the ID of the other Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PartnerStorageSystemId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the partner storage system. This element is present only for storage systems in an Active/Active configuration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PartnerStorageSystemName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the partner storage system. This element is present only for storage systems in an Active/Active configuration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PerfAdvisorTransport" type="na:PerfAdvisorTransport">
                        <xsd:annotation>
                            <xsd:documentation>The transport setting for communicating To the Host for collecting performance data. Valid only for storage systems. If this element is present and empty, the global default Value is used. Use HostGetDefaults To determine the global default Value.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ServiceStatuses" type="na:ArrayOfServiceStatus">
                        <xsd:annotation>
                            <xsd:documentation>List of services and their statuses. This element will be present only for a storage system or a vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="UseHostsEquiv" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>The setting for communicating To the Host using Hosts.equiv authentication. Valid only for storage systems and vFiler units. If this element is present and empty, the global default Value is used. Use HostGetDefaults To determine the global default Value.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerInfo" type="na:VfilerInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about a vFiler Unit. This element is present only when HostType is "Vfiler".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostModifyInfo">
                <xsd:annotation>
                    <xsd:documentation>Host information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AdminPort" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>The Host's administrative port for executing APIs. Valid only for Host Agents or NetCache appliances. If the Host Agent is operating under UNIX, the port range is restricted To [1025..2^16-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Primary IP Address for the Host. If not present, the current setting is not modified. &lt;P&gt; Length: [0..39]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User-specified Description of Host. If not present, the current setting is not modified. Length: [0..255]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostDpModifyInfo" type="na:HostDpModifyInfo">
                        <xsd:annotation>
                            <xsd:documentation>Data protection specific Host information. If not present, the current settings are not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>New Name for the Host. This Name cannot be set To the empty string. If not present, the current setting is not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostPassword" type="na:HostPassword">
                        <xsd:annotation>
                            <xsd:documentation>Password for logging into the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsername" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>User Name for logging into the Host. If not present, the current setting is not modified. &lt;P&gt; Length: [0..64]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpCredentials" type="na:NdmpCredentials">
                        <xsd:annotation>
                            <xsd:documentation>NDMP credentials for the Host. Valid only for storage systems and OSSV agents. If not present, the current settings are not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PerfAdvisorTransport" type="na:PerfAdvisorTransport">
                        <xsd:annotation>
                            <xsd:documentation>The transport setting for communicating To the Host for collecting performance data. Valid only for storage systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="UseHostsEquiv" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>The setting for communicating To the Host using Hosts.equiv authentication. Valid only for storage systems and vFiler units. &lt;p&gt; If the element is present and empty, the default Value set in the global Options will be used. If not present, the current setting is not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="HostNameOrId">
                <xsd:annotation>
                    <xsd:documentation>DFM Host. A Host can be a storage system, a vFiler Unit, a switch, a netcache or an agent. Value can be a DFM object Name (Maximum 255 characters), a fully qualified domain Name (FQDN)(Maximum 255 characters), the ip Address, or the DFM Id [1..2^31-1].</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="HostPassword">
                <xsd:annotation>
                    <xsd:documentation>Password for logging in. Encrypted using 2-way encryption. &lt;P&gt; Length: [0..64]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="HostPerfInfo">
                <xsd:annotation>
                    <xsd:documentation>Performance specific information for this iterator</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DataUnavailableReason" type="na:ArrayOfPerfStatusError">
                        <xsd:annotation>
                            <xsd:documentation>This element is included only if IsDataAvailable is set To false and indicates the Reason(s) for failure.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostPerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Host based on performance Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDataAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Returns if the performance data can be collected for this Host This will be present only for storage systems and vFiler units.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastClientStatsCollectionTime" type="na:Timestamp">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. This specifies the last time per-client statistics were collected for the Host. It will not be present if per-client statistics were never collected for the Host From Performance Advisor. This element is returned for Storage Systems only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PercentageSpaceConsumed" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the percentage of Total space consumed by this Host's performance data. This element will be returned only is IncludePerfSpaceDetails is set To true. It will be returned for Storage Systems only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceConsumed" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the amount of server storage currently consumed by the performance data in bytes. This element will be returned only is IncludePerfSpaceDetails is set To true. It will be returned for Storage Systems only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceProjected" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the Maximum amount of server storage required To store performance data in bytes. This element will be returned only is IncludePerfSpaceDetails is set To true. It will be returned for Storage Systems only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="HostRoleId">
                <xsd:annotation>
                    <xsd:documentation>Id of the role on the Host. &lt;p&gt; The ID for a Host role is always assigned by the DFM system. Range: [1..2^31-1].</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="HostRoleInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the contents of a role on the Host. The Host can be a storage system or a vFiler Unit. Output will always contain all the elements present in the Type definition.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Capabilities" type="na:ArrayOfCapability">
                        <xsd:annotation>
                            <xsd:documentation>List of Capabilities the role is allowed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="na:AccessObjectDescription">
                        <xsd:annotation>
                            <xsd:documentation>Description of the role.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Host on which the role is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host on which the role is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleId" type="na:AccessObjectId">
                        <xsd:annotation>
                            <xsd:documentation>Internal Id of the role on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleName" type="na:AccessObjectName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the role on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="HostRoleName">
                <xsd:annotation>
                    <xsd:documentation>Name of the role on the Host. &lt;p&gt; A Host role Name contains between 1 and 32 characters and can include any alphanumeric character, a space, or a punctuation character that is not one of: &lt;br&gt;" * + , / : ; &lt; = &gt; ? [ ] |</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="HostType">
                <xsd:annotation>
                    <xsd:documentation>Type of Host. Possible Values are: Filer, Vfiler, cluster, vserver, agent, ossv, and switch.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="HostUserInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the contents of a local user on the Host. The Host Type can be a Storage System or a vFiler Unit. Minimum Password age, Maximum Password age, and Status are applicable for Hosts running ONTAP versions 7.1 and above. Apart From these fields, output will always contain all the elements present in the Type definition.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Capabilities" type="na:ArrayOfCapability">
                        <xsd:annotation>
                            <xsd:documentation>List of Capabilities of the local user inherited From the usergroup(s) in which user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="na:AccessObjectDescription">
                        <xsd:annotation>
                            <xsd:documentation>Description of the local user.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FullName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the local user. It should not contain colon(:). Maximum Length:256 characters</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Host on which the local user is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host on which the local user is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleIds" type="na:ArrayOfHostRoleId">
                        <xsd:annotation>
                            <xsd:documentation>List of ids of roles contained by usergroup(s) in which the local user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleNames" type="na:ArrayOfHostRoleName">
                        <xsd:annotation>
                            <xsd:documentation>List of names of roles contained by usergroup(s) in which the local user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUserId" type="na:AccessObjectId">
                        <xsd:annotation>
                            <xsd:documentation>Internal Id of local user on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUserName" type="na:AccessObjectName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the local user on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsergroupIds" type="na:ArrayOfHostUsergroupId">
                        <xsd:annotation>
                            <xsd:documentation>List of ids of usergroups in which the local user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsergroupNames" type="na:ArrayOfHostUsergroupName">
                        <xsd:annotation>
                            <xsd:documentation>List of usergroup names on which the user is member of.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumPasswordAge" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Maximum age of the Password(in Days) before it has To be changed. Range: [0..2^32-1] Default Value: (2^32-1) Days</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MinimumPasswordAge" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Minimum age of the Password(in Days) before it can be changed. Range: [0..2^32-1] Default Value: 0</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Password" type="na:HostUserPassword">
                        <xsd:annotation>
                            <xsd:documentation>Password of the local user.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Status" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Status of the local user on the Host. This element cannot be used as an input. Possible Values: &lt;ul&gt; &lt;li&gt; "enabled" &lt;li&gt; "disabled" &lt;li&gt; "expired" &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="HostUserPassword">
                <xsd:annotation>
                    <xsd:documentation>Password of the local user on the Host. Encrypted using standard 2-way encryption. This must conform To the rules found in Options "security.passwd.rules". By default, the Password can contain 8 To 256 characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="HostUsergroupId">
                <xsd:annotation>
                    <xsd:documentation>Id of the usergroup on the Host &lt;p&gt; The ID for a Host usergroup is always assigned by the DFM system. Range: [1..2^31-1].</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="HostUsergroupInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the contents of a usergroup on the Host. The Host can be a storage system or a vFiler. Output will always contain all the elements present in the Type definition.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Capabilities" type="na:ArrayOfCapability">
                        <xsd:annotation>
                            <xsd:documentation>List of Capabilities the usergroup has inherited From the member roles.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the usergroup on the Host. Maximum Length: 128 characters</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Host on which the usergroup is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host on which the usergroup is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleIds" type="na:ArrayOfHostRoleId">
                        <xsd:annotation>
                            <xsd:documentation>List of ids of roles the usergroup contains.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostRoleNames" type="na:ArrayOfHostRoleName">
                        <xsd:annotation>
                            <xsd:documentation>List of role names the usergroup contains.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsergroupId" type="na:AccessObjectId">
                        <xsd:annotation>
                            <xsd:documentation>Internal Id of the usergroup on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostUsergroupName" type="na:UsergroupName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the usergroup on the Host.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="HostUsergroupName">
                <xsd:annotation>
                    <xsd:documentation>Name of the usergroup on the Host. &lt;p&gt; A Host usergroup Name contains between 1 and 32 characters and can include any alphanumeric character, a space, or a punctuation character that is not one of: &lt;br&gt;" * + , / : ; &lt; = &gt; ? [ ] |</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="HostUsergroupNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or Id of usergroup. This must conform To the format of either UsergroupName or AccessObjectId.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="IpPortNumber">
                <xsd:annotation>
                    <xsd:documentation>IP port number. &lt;P&gt; Range: [0..2^16-1]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:simpleType name="License">
                <xsd:annotation>
                    <xsd:documentation>Name of the licensed Data ONTAP Service. &lt;BR&gt;Possible Values: "nfs", "cifs", "iscsi", "fcp", "multistore", "a_sis", "snapmirror_sync".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="NdmpCredentials">
                <xsd:annotation>
                    <xsd:documentation>NDMP credentials for a Host or a network. Valid only for storage systems and OSSV agents.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="NdmpPassword" type="na:HostPassword">
                        <xsd:annotation>
                            <xsd:documentation>NDMP Password.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpPort" type="na:IpPortNumber">
                        <xsd:annotation>
                            <xsd:documentation>NDMP port. Valid only for storage systems and OSSV agents. If not present, the current setting is not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NdmpUsername" type="na:NdmpUsername">
                        <xsd:annotation>
                            <xsd:documentation>NDMP user Name. Valid only for storage systems and OSSV agents. If not present, the current setting is not modified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="NdmpUsername">
                <xsd:annotation>
                    <xsd:documentation>Name of NDMP user. &lt;P&gt; Length: [1..32]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="PerfAdvisorTransport">
                <xsd:annotation>
                    <xsd:documentation>The transport setting for communicating To the Host for collecting performance data. Data collection is disabled when this Option is set To Disabled. &lt;P&gt; Possible Values: "http_only", "https_ok", "disabled"</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ServiceStatus">
                <xsd:annotation>
                    <xsd:documentation>Status indicating whether a Service is up or down.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Service" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the Service is up or not. Possible Values: "up", "down".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="Sid">
                <xsd:annotation>
                    <xsd:documentation>Sid (Security Identifier) describing a user. Length: [5..128] characters Format: S-1-5-21-int-int-int-rid RID is a unique random integer generated by storage system/vFiler Unit.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="UsergroupName">
                <xsd:annotation>
                    <xsd:documentation>Name of a usergroup on storage system or vFiler Unit. Usergroup Name can contain between 1 and 256 characters and include any alphanumeric character, a space, or a punctuation character that is not one of: &lt;br&gt;" * + , / : ; &lt; = &gt; ? [ ] |</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="UsergroupNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Name or Id of usergroup on storage system or vFiler Unit. This must conform To the format of either UsergroupName or AccessObjectId.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="VfilerInfo">
                <xsd:annotation>
                    <xsd:documentation>information of a vFiler Unit. Avaiblable only if HostType is "Vfiler".</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="HostingFilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the hosting Filer of the vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostingFilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>DNS Name of the hosting Filer of the vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerAllowedProtocols" type="na:ArrayOfProtocol">
                        <xsd:annotation>
                            <xsd:documentation>List of allowed protocols on the vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerIpspace" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>IPSpace of the vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VfilerMigrationInfo" type="na:VfilerMigrationInfo">
                        <xsd:annotation>
                            <xsd:documentation>Migration information for the vFiler Unit. This will be returned only if the vFiler is in migrating state and if IncludeMigrationInfo is true in HostListInfoIterStart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VfilerNetworkResources" type="na:ArrayOfVfilerNetworkResource">
                        <xsd:annotation>
                            <xsd:documentation>Network Interface information of a vFiler Unit.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="VfilerIpspace">
                <xsd:annotation>
                    <xsd:documentation>Ipspace of vFiler Unit.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="VfilerMigrationInfo">
                <xsd:annotation>
                    <xsd:documentation>Migration information for a vFiler Unit.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DestinationFilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the destination storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationFilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the destination storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationVfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the destination vFiler Unit</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DestinationVfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the destination vFiler Unit</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MigrationStatus" type="na:MigrationStatus">
                        <xsd:annotation>
                            <xsd:documentation>Migration Status of the vFiler Unit</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceFilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the Source storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceFilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Source storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceVfilerId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database ID of the Source vFiler Unit</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SourceVfilerName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Source vFiler Unit</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VfilerNetworkResource">
                <xsd:annotation>
                    <xsd:documentation>Information about one vFiler Unit IP Address</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="InterfaceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Interface identifier To which the IP Address is bound. Present only if the IP Address is bound To an Interface</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InterfaceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Interface Name To which the IP Address is bound. Present only if the IP Address is bound To an Interface</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IpAddress" type="na:IpAddress">
                        <xsd:annotation>
                            <xsd:documentation>IP Address assigned To the vFiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MtuSize" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Mtu Size for the above bounded Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PrefixLength" type="xsd:integer"/>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="IfcInfo">
                <xsd:annotation>
                    <xsd:documentation>Information of about one Interface.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Filer on which the Interface is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DNS Name of the Filer on which the Interface is present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IfcId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Interface in DFM Server database. &lt;BR&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IfcName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Interface (ex: e0a).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IpAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>IP Address configured for the Interface. Empty in case the Interface in unconfigured.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IpAddressType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of IP Address configured for the Interface. Possible Values are: &lt;ul&gt; &lt;li&gt; ipv4 &lt;li&gt; ipv6 &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Ipspace" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the IPSpace To which the Interface belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsVlanCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies if the Interface is capable of supporting VLAN tagging. An Interface will not support VLAN tagging if: &lt;ul&gt; &lt;li&gt; It is not VLAN capable (at present only some INTEL NICs are supported for VLAN tagging.) &lt;li&gt; It is a physical Interface on which a VIF is configured. &lt;li&gt; It is an Interface that is already accepting traffic. &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MtuSize" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Interface mtu Size.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Netmask" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Netmask configured for the Interface. Empty in case the Interface is unconfigured or configured with IPv6 Address.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PartnerInterfaceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Partner Interface identifier. This element is present only when the storage system on which the Interface is present is in an Active/Active configuration and there is a partner Interface configured for this Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PartnerInterfaceName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Partner Interface Name. This element is present only when the storage system on which the Interface is present is in an Active/Active configuration and there is a partner Interface configured for this Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrefixLength">
                        <xsd:annotation>
                            <xsd:documentation>Prefix Length for the IP Address configured for the Interface. Empty in case the Interface is unconfigured. In case of IPv4 Address, it is number of Netmask bits. Range: [1..127]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="127"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Status" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Operation Status of the Interface, valid Values are "up", "down", "testing", "unknown".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of Interface. &lt;BR&gt;Possible Values are "ethernet", "fddi", "loopback", "atm", "vif", "vlan", "unknown".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="LunInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Lun.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Host on which the Lun resides. Always present in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of Host on which the Lun resides. Always present in the output. The Name is any simple Name such as myhost.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Lun.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunPath" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Path Name of the Lun including the Volume or Qtree where the Lun exists. The Name will be similar To myvol/mylun or myvol/myqtree/mylun.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunSize">
                        <xsd:annotation>
                            <xsd:documentation>Lun Size in bytes. Range : [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectPerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Lun based on performance Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Lun based on all Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Qtree on which the Lun resides. Present in the output only if the Lun resides on a Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QtreeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of Qtree on which the Lun resides. Present in the output only if the Lun resides on a Qtree. The Name is any simple Name such as myqtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Volume on which the Lun resides. Always present in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of Volume on which the Lun resides. The Name is any simple Name such as myvol. VolumeName is not returned if the Lun belongs To a Qtree on a Vfiler and the authenticated admin does not have the required Capability. For details of the required Capability, see Description of RbacOperation input element in LunListInfoIterStart api.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="MigrationDryRunResult">
                <xsd:annotation>
                    <xsd:documentation>Dry run Results of migration of each individual Volume</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DryRunResults" type="na:ArrayOfDryRunResult">
                        <xsd:annotation>
                            <xsd:documentation>Results of a dry run. Each Result describes one Action the system would take and the predicted effects of that Action.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Volume To MigrateStart</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume To MigrateStart</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="MigrationJobInfo">
                <xsd:annotation>
                    <xsd:documentation>Job information of Volume migration job.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="JobId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of job started for the Volume migration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Volume To MigrateStart</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Full Name of the Volume To MigrateStart</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="MigrationRequestInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of a Volume migration Request.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CleanupStaleStorage" type="na:CleanupStaleStorage">
                        <xsd:annotation>
                            <xsd:documentation>Indicates when should the Volumes in the Source Aggregate should be destroyed after successful migration. Default Value is "cleanup_after_migration".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DestinationAggregateNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the destination Aggregate To which all the Volumes has To be migrated To. If the destination Aggregate is not provided, the system will select a suitable Aggregate From the Resource pools associated with the Dataset node To which the Volumes belong To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RetentionType" type="na:DpBackupRetentionType">
                        <xsd:annotation>
                            <xsd:documentation>Retention Type To which the backup Version created should be archived for the Backups created as part of running an on-demand update after successful migration. This element is ignored if RunOnDemandUpdate is false. Default Value is "daily".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RunDedupeScan" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether a full deduplication scan has To be run on the new Volume after migration. This Option is applicable only for Volumes that are enabled for deduplication and is useful To regenerate the fingerprint database used in deduplication and will be ignored for other Volumes. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RunOnDemandUpdate" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether an on-demand update has To be triggered after successful migration on the Dataset To which the Volumes that were migrated belong To. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Volumes" type="na:ArrayOfObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or ids of one or more Volumes To be migrated. Currently, all the Volumes should belong To the same Aggregate. The Volumes, if they belong To a Dataset should all belong To the same node of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="RouteMigrationMode">
                <xsd:annotation>
                    <xsd:documentation>Type of migrating routes. &lt;p&gt; Possible Values are: 'static', 'persistent', 'none'. &lt;UL&gt; &lt;LI&gt; static: Static routes present in the IPSpace of the migrating vFiler Unit will be migrated. &lt;LI&gt; persistent: Persistent routes present in /etc/rc file related To the migrating vFiler Unit will be migrated. &lt;LI&gt; none: None of the routes will be migrated. Choosing this Option may lead To non-disruptive migration, if the routes in the migrating vFiler Unit are not present on the destination storage system. This Option should be chosen only when all the routes are already present on the destination storage system. By default 'static' routes will be migrated. &lt;/UL&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="VolumeAggregatePair">
                <xsd:annotation>
                    <xsd:documentation>A Volume and Aggregate pair.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Aggregate" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or Id of the Aggregate.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Volume" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or Id of the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="NetifIpInterfaceInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one network Interface.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AdministrativeStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The desired state of the Interface. Possible Values are "up", "down", and "testing".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BytesIn">
                        <xsd:annotation>
                            <xsd:documentation>The Total number of octets received on the Interface, including framing characters. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="BytesOut">
                        <xsd:annotation>
                            <xsd:documentation>The Total number of octets transmitted out of the Interface, including framing characters. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DiscardsIn">
                        <xsd:annotation>
                            <xsd:documentation>The number of inbound packets which were chosen To be discarded even though no Errors had been detected To prevent their being deliverable To a higher-layer Protocol. One possible Reason for discarding such a packet could be To free up buffer space. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DiscardsOut">
                        <xsd:annotation>
                            <xsd:documentation>The number of outbound packets which were chosen To be discarded even though no Errors had been detected To prevent their being transmitted. One possible Reason for discarding such a packet could be To free up buffer space. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ErrorsIn">
                        <xsd:annotation>
                            <xsd:documentation>The number of inbound packets that contained Errors preventing them From being deliverable To a higher-layer Protocol. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ErrorsOut">
                        <xsd:annotation>
                            <xsd:documentation>The number of outbound packets that could not be transmitted because of Errors. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="IpAddresses" type="na:ArrayOfString">
                        <xsd:annotation>
                            <xsd:documentation>List of IP addresses mapped To this Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OperationalStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The current operational state of the Interface. Possible Values are "up", "down", and "testing".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PacketsIn">
                        <xsd:annotation>
                            <xsd:documentation>The number of packets delivered To a higher-layer Protocol, including unicast, multicast, and broadcast packets. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="PacketsOut">
                        <xsd:annotation>
                            <xsd:documentation>The Total number of packets that higher-level protocols requested be transmitted, including those that were discarded or not sent. &lt;BR&gt;Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="PhysicalAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Interface's MAC Address. &lt;BR&gt;Example: 00:01:00:00:08:fd</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Speed" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The Interface's current bandwidth in bits per second. &lt;BR&gt;Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="CifsOpStats">
                <xsd:annotation>
                    <xsd:documentation>Contains the CIFS operations performed by the client on the storage system.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="OtherOperations">
                        <xsd:annotation>
                            <xsd:documentation>Specifies operations that do not fall into either read or write Categories. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ReadOperations">
                        <xsd:annotation>
                            <xsd:documentation>The number of read operations performed by the client on the storage system. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="WriteOperations">
                        <xsd:annotation>
                            <xsd:documentation>The number of write operations performed by the client on the storage system. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ClientStatError">
                <xsd:annotation>
                    <xsd:documentation>Describes an Error encountered while collecting per-client statistics on the storage system or Vfiler.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CifsError" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Error encountered while collecting CIFS per-client statistics</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsError" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Error encountered while collecting NFS per-client statistics</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the vFiler Unit or storage system for which this Error was encountered.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ClientStats">
                <xsd:annotation>
                    <xsd:documentation>Contains the per-protocol operations performed by a client on a storage system.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CifsOpStats" type="na:CifsOpStats">
                        <xsd:annotation>
                            <xsd:documentation>The number of CIFS operations performed by the client.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ClientNameOrIp" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name or IP Address of the client.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NfsOpStats" type="na:NfsOpStats">
                        <xsd:annotation>
                            <xsd:documentation>The number of NFS operations performed by the client.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="CounterThresholdInfo">
                <xsd:annotation>
                    <xsd:documentation>Specifies all the Attributes of a threshold on a single counter.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="PerfObjectCounter" type="na:PerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>Specifies a combination of an object and a counter, e.g. system:cpu_busy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether an event is To be generated when the Value of the counter is above ('upper') or below ('lower') the ThresholdValue. Possible Values are 'upper' and 'lower'. Default is 'upper'</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ThresholdUnit" type="na:CounterUnit">
                        <xsd:annotation>
                            <xsd:documentation>Unit of the counter. The Metric used for a counter may vary depending on the ONTAP Version.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ThresholdValue" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>The threshold Value To trigger an event. Range: [0..2^64-1].</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="CounterUnit">
                <xsd:annotation>
                    <xsd:documentation>A Unit in which a counter is measured. Possible Values are per_sec, b_per_sec (bytes/s), kb_per_sec (kb/s), mb_per_sec (mb/s), percent, millisec (milliseconds), microsec (microseconds), sec (seconds) and none.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="Day">
                <xsd:annotation>
                    <xsd:documentation>Day of week. Possible Values : 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday' or 'sunday'</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="DestinationHostInfo">
                <xsd:all>
                    <xsd:element minOccurs="0" name="ErrorReason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>If the copy Operation failed, this element will have the Reason for the failure. This element will not be present when the copy Operation was sucessful.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the destination storage system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the destination storage system.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DynamicData">
                <xsd:annotation>
                    <xsd:documentation>Contains data for top-N Objects</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Hostname" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Host. Will not be set when the Objects are selected within a Host</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InstanceName" type="na:WrapperOfPerfInstance">
                        <xsd:annotation>
                            <xsd:documentation>Name of the perf Instance. Will not be set for single Instance Objects like system, nfsv3</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the object. Will not be set for unmanaged Objects</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Value for the object Max Length is 32</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostClientStats">
                <xsd:annotation>
                    <xsd:documentation>Contains the per-client operations on a Host.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CollectionPeriod">
                        <xsd:annotation>
                            <xsd:documentation>The Duration, in seconds, for which the collection of per-client statistics was enabled. Range: [ 15 .. 60 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="15"/>
                                <xsd:maxInclusive value="60"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>The Id, in the DFM database, of the storage system for which these client statistics have been collected.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the storage system for which the per-client statistics were collected.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StartTime" type="na:Timestamp">
                        <xsd:annotation>
                            <xsd:documentation>The time at which the collection of per-client statistics was enabled, in seconds From Epoch time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StatId" type="na:StatId">
                        <xsd:annotation>
                            <xsd:documentation>The Id, in the DFM datbase, of this collection of statistics.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Stats" type="na:ArrayOfClientStats">
                        <xsd:annotation>
                            <xsd:documentation>Contains the operations performed by the top 20 clients operating on the Host. If 20 clients are not available, the operations for the Maximum available clients will be present.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="InstanceCounterInfo">
                <xsd:annotation>
                    <xsd:documentation>A specification for returning data for the given Instances and Counters.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CounterInfo" type="na:ArrayOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>List of performance Counters whose Values will be retrieved.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InstanceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>For unmanaged Objects, this will be the Name of the Instance. When this input is specified, the ObjectNameOrId should have the Name or Id of the storage system. Maximum Length is 255</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>If specified, all related Instances of the ObjectType mentioned in the PerfObjectCounter under this object are returned. For example, if ObjNameOrId is a Host and ObjectType in the PerfObjectCounter is Qtree, this would mean all Qtree under the Host. If the ObjNameOrId is Aggregate, all Qtrees under the Aggregate.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="InvalidCounterInstance">
                <xsd:annotation>
                    <xsd:documentation>A performance counter, an object Instance pair.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CounterInfo" type="na:WrapperOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>Specification of the performance counter.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ErrCode" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The string To specify the Reason why this counter Instance pair is invalid. Possible Values are: "invalid_instance": The Instance provided is invalid. "invalid_object_type": The object Type provided is invalid. "no_instances_available": No Instances found for the provided counter. "invalid_counter": The counter specified is not valid. "counter_unavailable": The counter specified is unavailable for this storage system. "incompatible_counter_instance": The counter and Instance are incompatible (For example: data requested for a network Interface counter but an Aggregate is provided as Instance).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ErrReason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Reason why this Instance pair is invalid.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage system To which the Instance belongs To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InstanceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Instance.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="Metric">
                <xsd:annotation>
                    <xsd:documentation>Contains the computation performed and the Value</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Id" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique identifier To be set by the user To map the requested Metrics To its Value when multiple Type of Metrics are requested for the same counter. This field is not processed and returned as it is in the output. Length not more than 16 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MetricResult" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The computed Value. The format multiple comma separated Timestamp:Value. This is an output-only field.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Period">
                        <xsd:annotation>
                            <xsd:documentation>Computation window in seconds. Valid only when Slide field is specified as "step", "rolling" or "cumulative". One Metric Value is calculated for each window of Size Period. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Slide" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Defines the method To Slide the compute window specified by Period field. Possible Values: &lt;li&gt; "&lt;b&gt;simple&lt;/b&gt;": No Slide. Compute a single Metric for the entire time range. &lt;li&gt; "&lt;b&gt;rolling&lt;/b&gt;": Slide the window by one sample at a time. Period field has To be specified. &lt;li&gt; "&lt;b&gt;step&lt;/b&gt;": Slide the window Value equal To Period. Period field has To be specified. &lt;li&gt; "&lt;b&gt;cumulative&lt;/b&gt;": The window keeps growing by the Value equal To Period&lt;br&gt; Default Value: "&lt;b&gt;simple&lt;/b&gt;"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The computation Type Possible Values: "&lt;b&gt;mean&lt;/b&gt;": Mean of the data for the specified time Period. "&lt;b&gt;min&lt;/b&gt;": Minimum Value "&lt;b&gt;max&lt;/b&gt;": Maximum Value "&lt;b&gt;value_at_percentile&lt;/b&gt;": nth percentile of the samples, where n is specified in the Value field.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Valid only when the Type field is set To "value_at_percentile" Requested percentile Value. This field accepts only positive real numbers as inputs. Range : (0..100]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="Month">
                <xsd:annotation>
                    <xsd:documentation>Month of year. Possible Values : 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november' or 'december'</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="NfsOpStats">
                <xsd:annotation>
                    <xsd:documentation>Contains the NFS operations performed by the client on the storage system.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="OtherOperations">
                        <xsd:annotation>
                            <xsd:documentation>Specifies operations that do not fall into either read or write Categories. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ReadOperations">
                        <xsd:annotation>
                            <xsd:documentation>The number of read operations performed by the client on the storage system. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="WriteOperations">
                        <xsd:annotation>
                            <xsd:documentation>The number of write operations performed by the client on the storage system. Range: [ 0 .. 2^31 - 1 ]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ObjectInfo">
                <xsd:annotation>
                    <xsd:documentation>Associated object's information</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ObjectFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>The full Name of the object that is associated with the View</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>The object that is associated with the View</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>ObjectName is the Name of the DFM object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the DFM object. The possible Values are &lt;ul&gt; &lt;li&gt; "resource_group" &lt;li&gt; "data_set" &lt;li&gt; "resource_pool" &lt;li&gt; "Filer" &lt;li&gt; "Vfiler" &lt;li&gt; "Volume" &lt;li&gt; "Qtree" &lt;li&gt; "Lun" &lt;li&gt; "Aggregate" &lt;li&gt; "Interface" &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="PerfAssocObjType">
                <xsd:annotation>
                    <xsd:documentation>Name of the object Type. The possible Values are &lt;ul&gt; &lt;li&gt; "resource_group" &lt;li&gt; "data_set" &lt;li&gt; "resource_pool" &lt;li&gt; "Filer" &lt;li&gt; "Vfiler" &lt;li&gt; "Volume" &lt;li&gt; "Qtree" &lt;li&gt; "Lun" &lt;li&gt; "Aggregate" &lt;li&gt; "disk" &lt;li&gt; "Interface" &lt;li&gt; "processor" &lt;li&gt; "Target" &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="PerfChart">
                <xsd:annotation>
                    <xsd:documentation>Information about a chart. A chart is a display (graph) with one or more data sources (Lines).</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ChartName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the chart. This is intended To be a user-visible label like "CPU Graph". It should be unique To the performance View.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DynamicDataSources" type="na:WrapperOfPerfDynamicDataSources">
                        <xsd:annotation>
                            <xsd:documentation>Lines representing dynamic Members. Data for each data Source is drawn as one line in the chart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Lines" type="na:ArrayOfPerfLine">
                        <xsd:annotation>
                            <xsd:documentation>Line definitions.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumY" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>An optional Maximum Value for the y axis. The units are arbitrary and determined by the client. This may be used To help guide the chart construction in the client.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the chart. Arbitrary string meaningful To the client only.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfCounter">
                <xsd:annotation>
                    <xsd:documentation>Describes a performance counter (a measurable quantity on a performance object). This might be, for example, the number of writes per second on a specific Volume.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="BaseCounter" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the counter used as the denominator To calculate Values of Counters involving percentages. For additional details, please refer To the ONTAP API PerfObjectCounterListInfo</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Desc" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the counter</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDisplay" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If TRUE, this counter can be displayed To the user. If FALSE, this counter is a base counter used as the denominator To calculate Values of Counters involving percentages. The base Counters should not be displayed To the user. Default Value is TRUE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Labels" type="na:ArrayOfPerfLabel">
                        <xsd:annotation>
                            <xsd:documentation>A list of Labels for this counter. For additional details, please refer To the ONTAP API PerfObjectCounterListInfo</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the counter</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrivilegeLevel" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The counter Privilege level, can be "basic", "advanced" or "diag". Any counter with a Privilege level of "diag" is not guaranteed To work, To exist in future releases, or To remain unchanged.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Properties" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Properties of the counter. For additional details, please refer To the ONTAP API PerfObjectCounterListInfo</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the counter. For additional details, please refer To the ONTAP API PerfObjectCounterListInfo</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Unit" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unit of the counter. For additional details, please refer To the ONTAP API PerfObjectCounterListInfo</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfCounterData">
                <xsd:annotation>
                    <xsd:documentation>Value of the performance counter.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CounterData" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A single Array of retrieved Values counter data. The format is a series of comma-separated Timestamp:Value pairs. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. The Values may have optional decimal extensions.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CounterName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the counter.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LabelNames" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A list of comma-separated label names To completely qualify the counter. This element will be empty for Counters without Labels.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Metrics" type="na:ArrayOfMetric">
                        <xsd:annotation>
                            <xsd:documentation>Container of computed Metric Values. Returned only in the PerfGetCounterData ZAPI when Metrics Value is requested.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>ObjectType is the Name of the object classification as defined by ONTAP counter manager. Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Unit" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unit of CounterData. This element will not be present if the Unit is not known. Some possible Values are per_sec, percent, b_per_sec, kb_per_sec, msecs, usecs. Maximum Length: 32 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfCounterGroup">
                <xsd:annotation>
                    <xsd:documentation>A counter Group. A counter Group is a collection of measurable data sources coupled with an associated sampling rate and sample History.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CounterGroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the counter Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CounterInfo" type="na:ArrayOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>Counters retrieved.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DataSources" type="na:ArrayOfPerfDataSource">
                        <xsd:annotation>
                            <xsd:documentation>Identifiers for the data sources To be retrieved in later queries. The DataSources can not contain 'Group' data Source. i.e. InstanceName must be specified for each PerfDataSource. The DataSources should not contain a data Source that specifies LabelNames field. This is because counter Group always collects data for the whole counter i.e. for all Labels.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DataSourcesToBeDisabled" type="na:ArrayOfPerfDataSource">
                        <xsd:annotation>
                            <xsd:documentation>The data sources To be disabled. Presently this parameter is valid for the default cgs. If 'DataSources' field contains a valid data sources To be enabled on this counter Group, this field should not be specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EndTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the Timestamp of the last available data sample. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDefault" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the counter Group is a "default" counter Group. Defaults To false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDisableAll" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether To disable all the Counters in the counter Group. Default is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsStopped" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates whether data collection has been stopped for the counter Group using PerfCounterGroupStop API. When this field is false, it indicates server's intention To collect data for the counter Group. But many other factors can affect whether data is actually collected or not.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NumberRecords" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the number of Records currently collected for the counter Group and storage system. This information is sent in the output only if the Host information is not consolidated</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PerfFileName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. This indicates the Name of the file that contains the performance information for the counter Group and storage system. This information is sent in the output only if the Host information is not consolidated</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RealTime" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Designates whether the counter Group is RealTime, in other words, if no user is getting data From the Group, then the counter Group will no longer get data. By default FALSE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SampleBuffer" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Length of sample buffer To retain, in seconds. If unspecified on input, the Value will be chosen by the server.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SampleRate" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Length of interval between samples, in seconds. Defaults To one minute.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceConsumed" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the amount of server storage currently consumed by the counter Group data, in bytes.Range: [0..2^64-1].</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceProjected" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the Maximum amount of server storage required by the counter Group data, in bytes. Range: [0..2^64-1].</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StartTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Present in output only. Indicates the Timestamp of the first available data sample. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfCounterInstance">
                <xsd:annotation>
                    <xsd:documentation>Defines a perf counter for a specific Instance.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CounterInfo" type="na:WrapperOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>The counter for which data is To be retrieved</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InstanceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>For unmanaged object, this will be the Name of the Instance. In this case, ObjectNameOrId will be the Id for the storage system Maximum Length is 255</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>The object for which data is To be retrieved or the Id of the parent storage system, if InstanceName is specified</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfDataGroup">
                <xsd:annotation>
                    <xsd:documentation>Definition of a set of data sources and a consolidation method.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DataGroupMethod" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A function To apply across the data sources. Valid Values are average (average of all sources), Total (sum of all sources). The default is Total (which for one data Source is just the Value of the single data Source).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DataSources" type="na:ArrayOfPerfDataSource">
                        <xsd:annotation>
                            <xsd:documentation>Identifiers for the data sources To be retrieved in later queries. The DataSources should be either one 'Group' data Source, or many (one or more) of 'Instance' data sources. If DataSources contains a data Source that has an array counter, specify LabelNames field of PerfDataSource To select a single element of the array.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfDataSource">
                <xsd:annotation>
                    <xsd:documentation>An unique identifier for a Source of data. When optional InstanceName field is not specified, PerfDataSource represents all relevant Instances in a storage system or in a Group.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name (or unique ID) of the Source storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CounterName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the counter measured. Counters are specifc measurable quantities on an Instance of a performance object, for example the number of write operations on a Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name (or unique ID) of the Source Group. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs. This field is ignored if ApplianceNameOrId is specified. This field defaults To global Group if ApplianceNameOrId is not specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InstanceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the specific object referenced (vol2, disk2, ...). If this field is specified, ApplianceNameOrId must also be specified. If this field is not specified, it is considered as a wildcard that implies combining data for all Instances of a storage system or a Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LabelNames" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An optional list of comma-separated label names. These represent an index into the array of Values when a counter has more than one Value (as implicitly indicated by the number of Labels). The Values should be the Name of the label (for example 'getattr' for the 'nfs_v3_ops' counter). In some cases, the array of Labels is multi-dimensional, in which case there should be one label Name From each row in the array of Labels. Each entry should be comma-separated. If unspecified, the default Value is blank. In that case, its interpretation depends on the context.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>The object Id for the specific object referenced</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the referenced object. Object names are broad classes of system components and protocols, like NFS, VOLUME, DISK, ...</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>The object Id for the specific object referenced. For dynamic data sources, this will specify the container From which Objects will be selected</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the DFM object. The possible Values are &lt;ul&gt; &lt;li&gt; "Filer" &lt;li&gt; "Vfiler" &lt;li&gt; "Volume" &lt;li&gt; "Qtree" &lt;li&gt; "Lun" &lt;li&gt; "Aggregate" &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfDependentCounterInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes a performance counter and its dependent Counters list, for example system:load_inbound_mbps is dependent on system:net_data_recv, fcp:fcp_write_data, iscsi:iscsi_write_data Counters.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CounterName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the counter.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectCounters" type="na:ArrayOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>List of dependents for this counter.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfDiagCategory">
                <xsd:annotation>
                    <xsd:documentation>Diagnosis Category.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CategoryName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the category</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CategoryStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Violation Status of the category The possible Status for a Diagnosis Category are "information" (If none of its health checks are violated), "warning" (If it contains only performance tips) and "Error" (If atleast one of its health checks are violated). Details of 'Performance tips' shall not be included in the category output if it is not violated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HealthChecks" type="na:ArrayOfPerfHealthCheck">
                        <xsd:annotation>
                            <xsd:documentation>List of Performance Health Checks and performance improvement tips.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfDynamicDataSources">
                <xsd:annotation>
                    <xsd:documentation>A specification for selecting top-n Instances for a single counter. Data for each Instance is drawn on the chart as one line. e.g. top 5 busy storage systems in a Group.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Color" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Color of the line. The Values and their interpretation are determined by the client. Recommended usage includes common names like "black" or "blue", as well RGB hex specification like "AAFF00".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DataSource" type="na:WrapperOfPerfDataSource">
                        <xsd:annotation>
                            <xsd:documentation>Describes the Properties of Instances that should be considered for top-n Query. The DataSource must be 'Group' data Source i.e. InstanceName field must be empty. If DataSource has an array counter, specify LabelNames field To select a single element of the array.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumInstances" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Maximum number of Instances To pick. Default is 5.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SelectAllInstances" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, this will pick all the Instances being considered. If MaximumInstances element is present and SelectAllInstances is true, then SelectAllInstances will be considered over MaximumInstances. By default this is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SortOrder" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The sort order when comparing data From different Instances. After sorting data in this order, top MaximumInstances are picked. Valid Values are "ascending" and "descending". Default is "descending".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TimeInterval" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>When considering the historical data samples, how far back in time (in seconds) we should go. Default is 300.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfHealthCheck">
                <xsd:annotation>
                    <xsd:documentation>A check which if violated could affect the performance of the given object.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HealthCheckName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the health check</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HealthCheckStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Violation Status of the health check. Possible Values are "Error", "warning" (in case of performance tip), "information".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Observation" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Observations found for the health check.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Recommendation" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Recommendation To avoid the issue. This will be "N/A" if the health-check Status is "information".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfInstance">
                <xsd:annotation>
                    <xsd:documentation>Describes an Instance. An Instance is a manifestation of a performance object. For example, the performance object might be "VOLUME" whereas the Instance might be "vol0".</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="InstanceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Instance.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfInstanceCounterData">
                <xsd:annotation>
                    <xsd:documentation>Array of counter Values of an Instance.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Counters" type="na:ArrayOfPerfCounterData">
                        <xsd:annotation>
                            <xsd:documentation>List of counter Values for this Instance.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="InstanceName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Instance To get counter Values for.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the object</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfLabel">
                <xsd:annotation>
                    <xsd:documentation>When a counter has more than one Value (an array), the Labels describe the indvidual array entries, and define an implicit indexing scheme into the array. The array may be multi-dimensional, in which case each occurrence of a PerfLabel represents a dimension in the array of Labels.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="LabelNames" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A comma-separated list of Labels, representing a row in the array of Labels.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfLine">
                <xsd:annotation>
                    <xsd:documentation>A line of data on the chart. Often a line will have a single data Source (e.g. CPU percent busy), but we allow for the Capability for many sources To be combined (e.g. average CPU busy over 10 storage systems).</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Color" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Color of the line. The Values and their interpretation are determined by the client. Recommended usage includes common names like "black" or "blue", as well RGB hex specification like "AAFF00".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DataGroup" type="na:WrapperOfPerfDataGroup">
                        <xsd:annotation>
                            <xsd:documentation>The data Source(s) and consolidation method for the line. If DataSources contains a data Source that has an array counter, specify LabelNames field of PerfDataSource To select a single element of the array.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LineName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the line. This is intended To be a user-visible label.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Type" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of display for the line. The Values and their interpretation are determined by the client.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfMissingHostObjectCounter">
                <xsd:annotation>
                    <xsd:documentation>Counters not available with a particular Host.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HostNameOrId" type="na:HostNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>DFM Host Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MissingObjectCounters" type="na:ArrayOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>List of unavailable Counters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfObject">
                <xsd:annotation>
                    <xsd:documentation>A performance object. A performance object is a (somewhat abstract) representation of a class of measurable items. These are roughly akin To system subcomponents or protocols, for example "VOLUME", "DISK" or "NFS". These are broad classes and do not represent specific Instances.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AssocObjType" type="na:PerfAssocObjType">
                        <xsd:annotation>
                            <xsd:documentation>Name of the DFM object To which the performance object is associated. Performance Objects that have single Instances such as "system", "cifs", "nfsv3", etc are associated with DFM object "Filer". Other performance Objects are associated with respective DFM object types.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the performance object.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfObjectCounter">
                <xsd:annotation>
                    <xsd:documentation>Performance Counters can be a combination of an object and a counter.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CounterDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the counter on which the threshold has been set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CounterName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the counter measured. Counters are specifc measurable quantities on an Instance of a performance object like avg_latency, nfs_ops. &lt;P&gt; Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsCalculatedStats" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>This field says whether the counter is a calculated stat counter or not.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LabelNames" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An optional list of comma-separated label names. These represent an index into the array of Values when a counter has more than one Value (as implicitly indicated by the number of Labels). The Values should be the Name of the label (for example 'getattr' for the 'nfs_v3_ops' counter). In some cases, the array of Labels is multi-dimensional, in which case there should be one label Name From each row in the array of Labels. Each entry should be comma-separated. If unspecified, the default Value is blank. In that case, its interpretation depends on the context. Maximum Length of 255 characters</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Metrics" type="na:ArrayOfMetric">
                        <xsd:annotation>
                            <xsd:documentation>Container of Metric requested. Only PerfGetCounterData uses this field, for all other ZAPIs this field is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>ObjectType is the Name of the object classification as defined by ONTAP counter manager. &lt;P&gt; Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PerfLabels" type="na:ArrayOfPerfLabel">
                        <xsd:annotation>
                            <xsd:documentation>A list of Labels for this counter. For additional details, please refer To the ONTAP API PerfObjectCounterListInfo</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TimeConsolidationMethod" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>This element will be used by PerfGetCounterData ZAPI only. A function To apply across the data for this counter To achieve the desired time resolution, if the requested SampleRate is different From the actual SampleRate of the data. Possible Values : 'average' 'min' 'max' 'last' Default is 'last'</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfObjectCounterInfo">
                <xsd:annotation>
                    <xsd:documentation>Performance Counters can be a combination of an object and a counter.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>ObjectName or ObjectId for which counter information is being collected.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PerfObjectCounter" type="na:PerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>Attributes of the counter being collected.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfPurgedHostObjectCounter">
                <xsd:annotation>
                    <xsd:documentation>Lists the effected Counters deatils for a particular Host.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="HostNameOrId" type="na:HostNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>DFM Host Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PurgedObjectCountersDetails" type="na:ArrayOfPerfPurgedObjectCountersDetails">
                        <xsd:annotation>
                            <xsd:documentation>Lists the effected Counters details.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfPurgedObjectCountersDetails">
                <xsd:annotation>
                    <xsd:documentation>Lists the effected Counters for each object along with Retention Period details.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CurrentRetentionPeriod" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Existing Retention Period in seconds.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="NewRetentionPeriod" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>New Retention Period in seconds after applying copy configuration Operation.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PurgedObjectCounters" type="na:ArrayOfPerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>List of effected Counters for which historical data will be purged.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfReport">
                <xsd:annotation>
                    <xsd:documentation>The Description of a performance report.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ReportName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the report.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfServerStatus">
                <xsd:annotation>
                    <xsd:documentation>Describes the Status of perf server.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DataCollectionStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Status of data collection. Possible Values are "enabled","disabled" and "disabling"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectUpdateStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Status of object updates. Possible Values are "enabled" and "disabled"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ServerStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Status of Performance Advisor. Possible Values are "enabled" and "disabled". Status will be "enabled" only when both DataCollectionStatus and ObjectUpdateStatus are enabled.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfStatusError">
                <xsd:annotation>
                    <xsd:documentation>Possible resons for data unavailability.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Error" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The following are the possible reasons: 1) "perf-advisor-not-enabled" This indicates that the performance advisor is not enabled on DFM. 2) "host-bad-credentials" This indicates that the authetication credentials for the Host are incorrect. 3) "host-no-credentials" This indicated that the Host login is empty. 4) "host-not-reachable" This indicates that the Host is down and hence not reachable. 5) "host-transport-incorrect" This indicates that the Host transport is in compatible with the performance advisor transport. 6) "filer-os-version-less-than-6.5" This indicates that the storage system is running OS with a release Version less than 6.5. 7) "filer-data-unavailable" This indicates that DFM has not discovered Instances of performance Objects on the storage system yet.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfThreshold">
                <xsd:annotation>
                    <xsd:documentation>The Description of a performance threshold.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="PerfThresholdName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the threshold event.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PerfView">
                <xsd:annotation>
                    <xsd:documentation>A performance View.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ApplianceNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name (or unique ID) of the storage system. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in the appliance-info structure From the appliance-list-iter-next API. The API will accept a Vfiler Name or Id From DFM 3.3 onwards.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AreEventsShown" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether an event block should be shown as part of the View. Defaults To false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AssocObjType" type="na:ArrayOfPerfAssocObjType">
                        <xsd:annotation>
                            <xsd:documentation>Indicates all the ObjectType that the View provides information for. Could be more than one for custom Views</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Charts" type="na:ArrayOfPerfChart">
                        <xsd:annotation>
                            <xsd:documentation>The Charts (Graphs) appearing in this View.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CounterGroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the referenced counter Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Group that this View is associated with. If a unique ID is supplied, it should originate From an API such as the 'Id' field returned in GroupListIterNext APIs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDefault" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the View is a "default" performance View. Defaults To false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsStopped" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether data collection is stopped for the View. Defaults To false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SampleBuffer" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Length of sample buffer To retain, in seconds. If unspecified on input, the Value will be chosen by the server.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SampleRate" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Length of interval between samples, in seconds. Defaults To one minute.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ViewName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the View.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ViewType" type="na:ViewType">
                        <xsd:annotation>
                            <xsd:documentation>Indicates the Type of View. If unspecified during View creation, it defaults To "custom_view".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResourcePropertyCondition">
                <xsd:annotation>
                    <xsd:documentation>Specifies conditions on Resource Properties. In case of Values for the same property, the conditions are assumed To be either-or conditions. For example, if the conditions "Disk RPM=7200" and "Disk RPM=10000" are specified, the threshold applies To all Disks with Speed 7200 RPM or 10000 RPM. In case of conditions on different Properties, the conditions are assumed To be "and" conditions. For example, if the conditions Name = "Disk RPM", Value = "10000" and name="Filer Model", value="FAS270" are specified, the threshold applies To all Disks with Speed 10000 RPM on FAS270 storage systems. During template modification, if no Resource Properties are specified, existing Resource Properties, if any, will be cleared.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the Resource property.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Value" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Value that this Resource property should have.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="StatId">
                <xsd:annotation>
                    <xsd:documentation>The Id, in the DFM database, of a collection of per-client statistics. Range: [ 1 .. 2^31 - 1 ]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:simpleType name="ThresholdId">
                <xsd:annotation>
                    <xsd:documentation>A unique numeric identifier used To specify a threshold. This parameter is mandatory when modifying a threshold. This typedef is an alias for the builtin ZAPI Type &lt;B&gt;integer&lt;/B&gt;. Range: [1..2^31-1]</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="ThresholdInfo">
                <xsd:annotation>
                    <xsd:documentation>Defines all the Attributes of a threshold.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="IsEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies if the Threshold is enabled. Default Value is TRUE when setting or modifying a threshold.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ObjectFullName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Fully qualified Name of the object. It is used as an output parameter while listing Thresholds. This parameter is unused for all other APIs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>The Name or Id of the object on which the threshold is To be created. Note that the API allows you To set only a single threshold at a time. So, container Objects like Resource Group, Dataset, Resource pool cannot be specified here. It is a mandatory parameter when setting a threshold. For the modify APIs, it is ignored if ThresholdId is also specified. While listing Thresholds, this parameter will always contain the ObjectId. &lt;P&gt; The allowed object types for this argument are &lt;ul&gt; &lt;li&gt; 'Host' &lt;li&gt; 'Aggregate' &lt;li&gt; 'Volume' &lt;li&gt; 'Qtree' &lt;li&gt; 'Lun' &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PerfObjectCounter" type="na:PerfObjectCounter">
                        <xsd:annotation>
                            <xsd:documentation>Specifies a combination of an object and a counter. When setting a threshold the first time, it is a mandatory parameter. For the modify APIs, it is ignored if ThresholdId is also specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdId" type="na:ThresholdId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the threshold. Element is ignored while creating a threshold but is mandatory when modifying them.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdInterval">
                        <xsd:annotation>
                            <xsd:documentation>The amount of time in seconds for which an event generation is suppressed before deciding that a counter has crossed a specified threshold and an event needs To be generated. The same interval will also be used To generate a normal event. If a Value of zero is specified, any temporary spikes in counter Values above the threshold will generate an event, if the counter Values are sampled at that point of time. This parameter is mandatory when setting a threshold. &lt;P&gt; Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Type of threshold, can be upper or lower. In case of an Upper threshold Type, the counter Value must exceed the threshold Value for at least the specified amount of time for an event To be generated. In case of a Lower threshold Type, the counter Value must fall below the threshold Value for at least the specified amount of time for an event To be generated. Note that as the threshold types are mutually exclusive, so only one threshold Type may be specified. Default Value is 'upper' when setting or modifying a threshold. &lt;P&gt; Possible Values:'upper', 'lower'</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdUnit" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unit of the counter. This parameter is mandatory when setting or modifying a threshold. The Possible Values are: &lt;P&gt; Possible Values: per_sec, b_per_sec (bytes/s), kb_per_sec (Kbytes/s), mb_per_sec (Mbytes/s), percent, millisec, microsec, sec, or none. &lt;P&gt; Note that the Metric used for a counter may vary depending upon the Data ONTAP Version.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdValue">
                        <xsd:annotation>
                            <xsd:documentation>The threshold Value of a counter is used To generate an event if the observed counter Value breaches this Value. This parameter is mandatory when setting a threshold. &lt;P&gt; Range: [1..2^64-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="18446744073709551615"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ThresholdInfo2">
                <xsd:annotation>
                    <xsd:documentation>Defines a performance counter based threshold.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="CounterThresholds" type="na:ArrayOfCounterThresholdInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of Thresholds on Counters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If true, the threshold is enabled and Events will be generated if it is breached. Default Value is true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsIndirect" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether the threshold applies on the object directly or through inheritance. For example, if the threshold is applied on a storage system, but applies on Qtree in it because of the constituent Counters, IsIndirect will be set To true. This Value is relevant only when the threshold details are returned; and is ignored when creating or modifying a threshold. It is, therefore, ignored in input.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ObjectsInfo" type="na:ArrayOfObjectInfo">
                        <xsd:annotation>
                            <xsd:documentation>Contains the Id, the full Name and Type of the object on which the threshold is applied directly.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcePropertyConditions" type="na:ArrayOfResourcePropertyCondition">
                        <xsd:annotation>
                            <xsd:documentation>Specifies conditions on Properties of the Objects To which this threshold applies.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TemplateId">
                        <xsd:annotation>
                            <xsd:documentation>This returns the Id of the template To which this threshold belongs. Range: [1..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="4294967295"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TemplateName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the template To which this threshold belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ThresholdEventName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the event that is raised when the threshold is breached. The default Name is derived From the counter.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThresholdId" type="na:ThresholdId">
                        <xsd:annotation>
                            <xsd:documentation>The ID, in the DFM database, of the threshold. This element should not be specified when creating a threshold, but is always returned when querying.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ThresholdInterval">
                        <xsd:annotation>
                            <xsd:documentation>The amount of time in seconds for which an event generation is suppressed before deciding that a counter has crossed a specified threshold and an event needs To be generated. The same interval will also be used To generate a normal event. If a Value of zero is specified, any temporary spikes in counter Values above the threshold will generate an event, if the counter Values are sampled at that point of time. This parameter is mandatory when setting a threshold. &lt;P&gt; Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ThresholdTemplate">
                <xsd:annotation>
                    <xsd:documentation>The Description of a threshold template.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="TemplateName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ThresholdTemplateInfo">
                <xsd:annotation>
                    <xsd:documentation>Contains info on performance threshold templates</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AppliedObjects" type="na:ArrayOfObjectInfo"/>
                    <xsd:element minOccurs="0" name="IsEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>This specifies if the template is enabled or not.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MemberThresholds" type="na:ArrayOfThresholdInfo2">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Thresholds that are To be part of this template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TemplateDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TemplateId">
                        <xsd:annotation>
                            <xsd:documentation>This returns the Id of the template that is created Range: [1..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="4294967295"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TemplateName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="TimeFilter">
                <xsd:annotation>
                    <xsd:documentation>Filter data based on selected time range.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Days" type="na:ArrayOfDay">
                        <xsd:annotation>
                            <xsd:documentation>Days of week. Default: no Day filter</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Months" type="na:ArrayOfMonth">
                        <xsd:annotation>
                            <xsd:documentation>Months of year. Default: no Month filter</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TimeRanges" type="na:ArrayOfTimeRange">
                        <xsd:annotation>
                            <xsd:documentation>Range in minutes of Day. Default: no TimeRange filter</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="TimeRange">
                <xsd:annotation>
                    <xsd:documentation>Holds the 'From' and 'To' range as minutes in a Day. Ex: 9.25AM To 4.45PM will become from=565 and to=1005</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="From">
                        <xsd:annotation>
                            <xsd:documentation>Start time in minute of Day. Ex: 9.25AM corresponds To (9*60)+25 =&gt; 565 Range: [0..1439]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1439"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="To">
                        <xsd:annotation>
                            <xsd:documentation>End time in minute of Day. Ex: 4.45PM corresponds To (16*60)+45 =&gt; 1005 Range: [0..1439]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1439"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ViewType">
                <xsd:annotation>
                    <xsd:documentation>Type of the View. Possible Values are: &lt;ul&gt; &lt;li&gt; &lt;b&gt;custom_view&lt;/b&gt; - User defined View containing Counters of specific Instances. Creates a custom counter Group To hold the performance data. &lt;li&gt; &lt;b&gt;canned_view&lt;/b&gt; - Default Views. &lt;li&gt; &lt;b&gt;summary_view&lt;/b&gt; - Default Views. &lt;li&gt; &lt;b&gt;custom_view_instances&lt;/b&gt; - User defined View containing Counters of specific Instances. Doesn't create custom counter Group during View creation but uses data From default counter Group. &lt;li&gt; &lt;b&gt;custom_view_object_type&lt;/b&gt; - User defined View that is attached To a specific associated object Type. Exactly one AssocObjType element needs To be specified while creating this View. Counters for specific Instances cannot be present in the View. Only Counters related To the associated object Type can be added To it. Doesn't create custom counter Group during View creation but uses data From default counter Group. &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="CustomProvisioningScriptSettings">
                <xsd:annotation>
                    <xsd:documentation>Post provisioning script settings, applicable only for "nas" or "san" Type of provisioning policies.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ScriptPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Full Path of a script on the management station To perform certain custom steps. The script will be run as the final step in the the provisioning process.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetMemberUsedSpaceThresholds">
                <xsd:annotation>
                    <xsd:documentation>Full and nearly full Thresholds for generating Events on used space of Dataset Members.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>Specified as percentage Value, if used space of any Dataset member crosses this Value, a critical event is generated. Range: [1..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NearlyFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>Specified as percentage Value, if the used space of any Dataset member crosses this Value, a warning event is generated. Range: [1..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="NasContainerSettings">
                <xsd:annotation>
                    <xsd:documentation>Details of capacity settings like space guarantees, quotas, out of space actions when provisioning storage for NAS access.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DefaultGroupQuota">
                        <xsd:annotation>
                            <xsd:documentation>Default Group quota setting on the Dataset Members. The Value is expressed in kilobytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DefaultUserQuota">
                        <xsd:annotation>
                            <xsd:documentation>Default user quota setting on the Dataset Members. The Value is expressed in kilobytes. Range: [1..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotReserve" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If True, 20% of requested space is reserved for Snapshot copies of data.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceOnDemand" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If True, Volume is provisioned with autogrow and autodelete settings enabled. Volume Options : try_first=volume_grow. autodelete Options : commitment=disrupt.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThinProvision" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>If True, the requested space is not pre-allocated (or reserved) From Aggregates. The space From Aggregates is actually consumed when users write data To CIFS shares or NFS exports of Dataset Members.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ProvisioningPolicyInfo">
                <xsd:annotation>
                    <xsd:documentation>Contains all information about a single provisioning Policy.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="CustomProvisioningScriptSettings" type="na:CustomProvisioningScriptSettings">
                        <xsd:annotation>
                            <xsd:documentation>Script settings used To perform post provisioning steps on the provisioned containers.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetMemberUsedSpaceThresholds" type="na:DatasetMemberUsedSpaceThresholds">
                        <xsd:annotation>
                            <xsd:documentation>Nearly full and full Thresholds for generating alerts on used space of Dataset Members.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether dedupe has To be enabled on all the Volumes of the Dataset with which the provisioning Policy is associated. Default Value is false.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeSchedule" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the schedule for deduplication that has To be set on the Volumes of the Dataset with which the provisioning Policy is associated. Valid Values are "none", "auto" and the format hour_list&amp;#064;day_list. &lt;br&gt; The 'hour_list' specifies which hours of the Day the dedupe Operation should run on each scheduled Day. Hour ranges such as 8-17 are allowed. Step Values can be used in conjunction with ranges. For example, 0-23/2 means "every two hours". &lt;br&gt; The 'day_list' specifies which Days of the week the dedupe Operation should run. It is a comma-separated list of the first three letters of the Day: sun, mon, tue, wed, thu, fri, sat. The names are not case sensitive. Day ranges such as mon-fri can also be given. &lt;br&gt; Default Value is "none".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NasContainerSettings" type="na:NasContainerSettings">
                        <xsd:annotation>
                            <xsd:documentation>Space and capacity settings applicable when Datasets are accessed over NAS protocols like space guarantees, quotas, Snapshot reserve out of space actions. Ignored when Policy Type is not "nas".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the Policy. It may contain From 0 To 255 characters. If the Length is greater than 255 characters, the ZAPI fails with Error code EINVALIDINPUT. The default Value is the empty string "".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Object ID of the Policy, ignored while creating Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProvisioningPolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Policy. Each provisioning Policy has a Name that is unique among provisioning and data protection policies. Should be provided while creating a new Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyType" type="na:ProvisioningPolicyType">
                        <xsd:annotation>
                            <xsd:documentation>Type of provisioning Policy, valid types are "nas", "san" and "secondary".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourceTag" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A label associated with a Resource pool or its elements (filer/aggregates). A label serves as a filter when selecting resources, during provisioning,i.e only those resources that have a macthing Tag are considered for provisioning. &lt;BR&gt; For example: An adminitrator can label Resource pools as "low-cost" and create a provisioning Policy with &lt;B&gt;ResourceTag&lt;/B&gt; set To "low-cost" To place Datasets on cheap storage. It may contain From 0 To 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SanContainerSettings" type="na:SanContainerSettings">
                        <xsd:annotation>
                            <xsd:documentation>Space and capacity settings applicable when Datasets are accessed over SAN protocols Ignored when Policy Type is not "san".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageReliability" type="na:StorageReliability">
                        <xsd:annotation>
                            <xsd:documentation>Specifies desired level of storage reliability required for the Dataset. Provisioning Manager will try find a Resource which is configured To provide desired reliability and provision FlexVols on it, In case such a Resource is not available the provisioning Request will fail.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ProvisioningPolicyType">
                <xsd:annotation>
                    <xsd:documentation>Type of provisioning Policy. Possible Values are "san", "nas" and "secondary".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="SanContainerSettings">
                <xsd:annotation>
                    <xsd:documentation>Space settings when provisioning storage for san access, specify how space will be allocated To various components in san environment.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="GuaranteeWrites" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Applicable when over committing storage space. i.e &lt;B&gt;ThinProvision&lt;/B&gt; is set To "true". &lt;BR&gt;&lt;BR&gt; If set To "true", Provisioning Manager creates Volume/LUN configuration such that space for writes To LUNs is always guaranteed but Snapshot copies may or may not be possible depending on space availability, the choice of configuration can be specified in &lt;B&gt;ThinProvisioningConfiguration&lt;/B&gt; input element. &lt;BR&gt;&lt;BR&gt; If set To "false", Provisioning Manager creates Volumes/LUNs with no space guarantees at all. As a Result the writes To Volumes/LUNs provisioned using such policies can fail at given time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageContainerType" type="na:StorageContainerType">
                        <xsd:annotation>
                            <xsd:documentation>Container Type To provision. Possible Values: "Volume","Lun". &lt;BR&gt; Provisioning Manager can provision LUNs and map them To server To provide access To the LUNs or provision FlexVols and delegate the task of provisioning LUNs To server administrators using server side tools liks SnapDrive. Default Value is "Lun".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThinProvision" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Enable over-commitment of storage space.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ThinProvisioningConfiguration" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the configuration To use when &lt;B&gt;ThinProvision&lt;/B&gt; and &lt;B&gt;GuaranteeWrites&lt;/B&gt; are set To "true". Each configuration has advantages and space saving objectives. &lt;BR&gt;&lt;BR&gt; Possible Values are &lt;B&gt;Snapshots&lt;/B&gt;, &lt;B&gt;data_and_snapshots&lt;/B&gt;. &lt;BR&gt;&lt;BR&gt; &lt;B&gt;Snapshots&lt;/B&gt;: This configurations allows thin provisioning of Snapshot space, i.e space is allocated for Snapshot copies as needed but space for data and overwrites (after the first Snapshot copy) is preallocated. When the Aggregate runs out of space further Snapshot copies may fail, but existing Snapshot copies are preserved. &lt;BR&gt;&lt;BR&gt; &lt;B&gt;data_and_snapshots&lt;/B&gt;: This configurations allows thin provisioning of space for data overwrites and Snapshot space, The space requested initially is allocated upfront but space for data overwrites(after first Snapshot copy) and Snapshot copies is allocated as needed. In situations when Aggregate on which Volume is placed runs out of space, Snapshot copies in oldest first order will be automatically deleted To allocate space for user writes. &lt;BR&gt;&lt;BR&gt; the Value is set To "none" when either &lt;B&gt;ThinProvision&lt;/B&gt; or &lt;B&gt;gurantee-writes&lt;/B&gt; is "false". Changing it To another Value will Result in Error with return code set To EINVALIDINPUT.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="StorageContainerType">
                <xsd:annotation>
                    <xsd:documentation>Storage container Type To provision as Dataset Members when provisioning storage for SAN access. Possible Values are "Lun" and "Volume".&lt;BR&gt; If the Value is "Lun", Provisioning Manager will provision LUNs into the Dataset and map To the Hosts specified by creating igroups. &lt;BR&gt; If the Value is "Volume", Provisioning Manager will create FlexVols, the LUNs will then be created using external tools like SnapDrive.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="StorageReliability">
                <xsd:annotation>
                    <xsd:documentation>NetApp Storage Systems offer a wide range of storage availability features which provide protection against various failure like disk drive failures, shelf failures, controller failures or site failures. The required level of reliability of the Dataset can be specified in the provisioning Policy.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ControllerFailure" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Resiliency against single controller failure, i.e the Dataset can be accessed even after a controller fails. Maps To active/active pair. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DiskFailure" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Resiliency against disk failures, possible Values are "single" (Maps To RAID-4 Aggregates), "double" (Maps To RAID-DP Aggregates) or "any"(either RAID-4 or RAID-DP). Default Value is "double".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SubSystemFailure" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Resiliency against storage sub system failures (or back end failures) like disk shelf, disk shelf adapters, failure of FCAL loops. Maps To "SyncMirror" Aggregates. Default Value is "false".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="QtreeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Qtree.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetId">
                        <xsd:annotation>
                            <xsd:documentation>ID of Dataset where this Qtree is in the primary storage set. Range: [1..2^31-1] This field is deprecated in favor of Datasets, which lists all Datasets the Qtree belongs To. It is still populated with one of the Dataset ids.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="Datasets" type="na:ArrayOfDatasetReference">
                        <xsd:annotation>
                            <xsd:documentation>List of Dataset IDs where this Qtree is in the primary storage set. If IsInDataset is false, this list will be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="FilerId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of storage system on which the Qtree resides. Always present in the output. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="FilerName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of storage system on which the Qtree resides. Always present in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this object and all of it's parents are up or online. Only output if the call To iter-start included the "IncludeIsAvailable" flag.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDirectVfilerChild" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the Qtree is a direct or indirect child of a Vfiler. If not present, then Qtree is not under a Vfiler.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether an admin has decided To ignore this Qtree for purposes of data protection.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the Qtree is a member of any Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSnapvaultSecondaryQtree" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the Qtree is a secondary Volume for storing SnapVault Backups.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Qtree. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="QtreeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Simple Name of the Qtree. Always present in the output. The Qtree Name is a simple Name without the storage system or Volume part. For example, myqtree2.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeSize" type="na:WrapperOfQtreeSizeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Sizes of various parameters of the Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Volume in which the Qtree resides. Always present in the output. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Volume in which the Qtree resides. Always present in the output.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="QtreeSizeInfo">
                <xsd:annotation>
                    <xsd:documentation>Sizes of various parameters of a Qtree. File counts are simple counts.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FilesLimit" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Limit of number of files in Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FilesUsed" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Number of files in Qtree.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HardLimit">
                        <xsd:annotation>
                            <xsd:documentation>Hard Size limit of Qtree in bytes. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QtreePerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Qtree based on performance Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QtreeStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Qtree based on all Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SoftLimit">
                        <xsd:annotation>
                            <xsd:documentation>Soft Size limit of Qtree in bytes. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SpaceUsed">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes used by Qtree. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="AdminInfo">
                <xsd:annotation>
                    <xsd:documentation>Details of a administrator.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AdminId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>The Id of the admin or usergroup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the admin or usergroup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EmailAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Email Address of the administrator if it has been set in the server</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PagerAddress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Pager Address of the administrator if it has been set in the server</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="AggregateNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Details of an Aggregate Name or Id. When used as input only one of AggregateName or AggregateId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AggregateId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The object Id of an Aggregate. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AggregateName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An Aggregate Name. If this is specified, also need To specify FilerIdentifier.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="AggregateResource">
                <xsd:annotation>
                    <xsd:documentation>Details of an Aggregate Resource. AggregateResourceNameOrId must be specified. If AggregateName is specified, then need To also specify FilerIdentifier.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AggregateResourceNameOrId" type="na:WrapperOfAggregateNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>An Aggregate Name or Id. If an Aggregate Name is specified, then the FilerIdentifier must also be specified</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FilerIdentifier" type="na:WrapperOfFilerResource">
                        <xsd:annotation>
                            <xsd:documentation>The storage system where the Aggregate lives in.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a DFM Dataset Resource. DFM Dataset Name or object Id of a DFM Dataset. When used as input only one of DatasetName or DatasetId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Object Id of a DFM Dataset. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DFM Dataset Name</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="FilerResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a storage system Resource. When used as input only one of FilerName or FilerId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FilerId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The object Id or serial number of a storage system. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="FilerName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The FQDN of a storage system</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="GroupResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a DFM Group Resource. DFM Group Name or object Id of a DFM Group. When used as input only one of GroupName or GroupId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="GroupId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Object Id of a DFM Group. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DFM Group Name</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="HostResource">
                <xsd:annotation>
                    <xsd:documentation>Identifies a Host Resource. When used as input only one of HostName orhost-id is specified. When used as output, both of them will be returned</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="HostId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>An object Id of a Host. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A FQDN of a Host</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="LunNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Details of a LUN Name or Id. When used as input only one of LunName or LunId is specified. When used as as output both will be returned. If a LunName is specified, then either VolumeIdentifier or HostIdentifier must also be specified.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="LunId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The object Id of a Lun. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LunName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The serial number or Path Name of a LUN. Path Name of LUN is written as volume-name/lun-name or volume-name/qtree-name/lun-name. One of either VolumeIdentifier or HostIdentifier must also be specified. However, if a HostIdentifier specified, the LunName must be only a serial number.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="LunResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a LUN. LunIdentifierNameOrId must be specified. If LunName is specified, then either VolumeIdentifier or HostIdentifier must also be specified. See the Description for LunName for more information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="HostIdentifier" type="na:WrapperOfHostResource">
                        <xsd:annotation>
                            <xsd:documentation>LUN within a Host. LunNameOrId must be the LUN's serial number or object Id (not Path).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="LunIdentifierNameOrId" type="na:WrapperOfLunNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>A LUN's Name or Id. If the LUN's Name is specified, then either VolumeIdentifier or HostIdentifier must also be specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeIdentifier" type="na:WrapperOfVolumeResource">
                        <xsd:annotation>
                            <xsd:documentation>LUN within a Volume</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="PolicyResource">
                <xsd:annotation>
                    <xsd:documentation>Identifies a Policy Resource. When used as input one or more of PolicyName or PolicyId is specified. When used as output, both of them will be returned. Policy can refer To either a protection Policy or a provisioning Policy.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="PolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Object identifier of the protection or proviisoning Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the protection or provisioning Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="QtreeNameOrId">
                <xsd:annotation>
                    <xsd:documentation>A Qtree Name or Id. When used as input only one of QtreeName or QtreeId is specified. When used as output, both of them will be returned. If QtreeName is specified, then either HostIdentifier or VolumeIdentifier must also be specified but not both.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="QtreeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>The object Id of a Volume. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="QtreeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>The Name of a Qtree. Also need either HostIdentifier or VolumeIdentifier.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="QtreeResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a Qtree. QtreeIdentifierNameOrId must be specified. If QtreeName is specified, then either VolumeIdentifier or HostIdentifier must also be specified. See the Description for QtreeName for more information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="HostIdentifier" type="na:WrapperOfHostResource">
                        <xsd:annotation>
                            <xsd:documentation>Host in which the Qtree resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="QtreeIdentifierNameOrId" type="na:WrapperOfQtreeNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>A Qtree's Name or Id. If the Qtree's Name is specified, then either VolumeIdentifier or HostIdentifier must also be specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeIdentifier" type="na:WrapperOfVolumeResource">
                        <xsd:annotation>
                            <xsd:documentation>Volume in which the Qtree resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RbacAdminNameOrId">
                <xsd:annotation>
                    <xsd:documentation>an admin Name or object Id</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AdminId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The adminId of the administrator</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AdminName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of an administrator</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RbacAdminOrUsergroup">
                <xsd:annotation>
                    <xsd:documentation>An admin or usergroup. When used as an input element, specify only one of AdminOrUsergroupName or AdminOrUsergroupId (not both). When used as an output element, both of them are returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AdminOrUsergroupId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The Id of the admin or usergroup which is an object Id From the Objects table within the DFM database. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AdminOrUsergroupName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An admin or usergroup Name. The format of the admin Name consists of a sequence of one or more characters up To a Maximum of 255 characters. The usergroup refers To an existing usergroup in Microsoft's Active Directory. The format of the usergroup Name is DOMAIN\USER. For example, "ABC\eng"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RbacOperation">
                <xsd:annotation>
                    <xsd:documentation>An Operation</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="OperationName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of a Operation. The Maximum Length allowed is 255 characters. It is of the form: &lt;application&gt;.&lt;category&gt;.&lt;typeOfAccess&gt; For example: "DFM.SRM.Read"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OperationNameDetails" type="na:WrapperOfRbacOperationNameDetails">
                        <xsd:annotation>
                            <xsd:documentation>Other details of an Operation</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RbacOperationNameDetails">
                <xsd:annotation>
                    <xsd:documentation>more details of an Operation</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="OperationDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A longer (multiple line) Description suitable for completely explaining the Operation and the places where it has an Effect. The Maximum Length allowed is 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OperationSynopsis" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A short Description (only a few words) suitable for use in a user Interface when showing/ selecting this Operation. The Maximum Length. Allowed is 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ResourceType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of Resource that the Operation applies To. Possible Values: "managementstation", "Filer", "Aggregate", "Volume", "Lun", "Vfiler", "Host", "Group", "rbac_role", "Dataset", "resource_pool". Note that Group refers To a DFM Resource Group.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RbacResourceOperation">
                <xsd:annotation>
                    <xsd:documentation>Operation assigned To a given Resource</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Operation" type="na:WrapperOfRbacOperation">
                        <xsd:annotation>
                            <xsd:documentation>Complete details of a Operation</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Resource" type="na:WrapperOfResourceIdentifier">
                        <xsd:annotation>
                            <xsd:documentation>The Resource for which the Operation applies</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RbacRoleResource">
                <xsd:annotation>
                    <xsd:documentation>Identifies an RBAC role Resource. When used as input only one of RbacRoleName or RbacRoleId is specified. When used as output, both of them will be returned</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="RbacRoleId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The object Id of an RBAC role. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RbacRoleName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>An RBAC role Name. Must be less than or equal To 64 characters in Length.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResourceIdentifier">
                <xsd:annotation>
                    <xsd:documentation>Identifies a Resource. Only one Resource field must be set. i.e. one of ResourceId, RbacRole, Host, Group, storage system, Vfiler, Aggregate, Volume, ResourcePool, Dataset, Qtree, protection Policy, provisioning Policy, Lun or vFiler template. When an object Id is specified, it refers To the object Id field in the Objects table From the DFM database.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Aggregate" type="na:WrapperOfAggregateResource">
                        <xsd:annotation>
                            <xsd:documentation>An Aggregate</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Dataset" type="na:WrapperOfDatasetResource">
                        <xsd:annotation>
                            <xsd:documentation>A DFM Dataset</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Filer" type="na:WrapperOfFilerResource">
                        <xsd:annotation>
                            <xsd:documentation>A storage system (Filer)</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Group" type="na:WrapperOfGroupResource">
                        <xsd:annotation>
                            <xsd:documentation>A DFM Group</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Host" type="na:WrapperOfHostResource">
                        <xsd:annotation>
                            <xsd:documentation>A Host</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Lun" type="na:WrapperOfLunResource">
                        <xsd:annotation>
                            <xsd:documentation>A Lun</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Policy" type="na:WrapperOfPolicyResource">
                        <xsd:annotation>
                            <xsd:documentation>A Policy can refer To either a protection Policy or provisioning Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Qtree" type="na:WrapperOfQtreeResource">
                        <xsd:annotation>
                            <xsd:documentation>A Qtree</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RbacRole" type="na:WrapperOfRbacRoleResource">
                        <xsd:annotation>
                            <xsd:documentation>An RBAC role</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourceId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>An object Id of a Resource. A ResourceId of 0 represents the global Resource which is the global scope. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcePool" type="na:WrapperOfResourcePoolResource">
                        <xsd:annotation>
                            <xsd:documentation>A DFM Resource pool</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageService" type="na:WrapperOfStorageServiceResource">
                        <xsd:annotation>
                            <xsd:documentation>A Storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Vfiler" type="na:WrapperOfVfilerResource">
                        <xsd:annotation>
                            <xsd:documentation>A Vfiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplate" type="na:WrapperOfVfilerTemplateResource">
                        <xsd:annotation>
                            <xsd:documentation>A vFiler template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Volume" type="na:WrapperOfVolumeResource">
                        <xsd:annotation>
                            <xsd:documentation>A Volume</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResourcePoolResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a DFM ResourcePool Resource. DFM ResourcePool Name or object Id of a DFM ResourcePool. When used as input only one of ResourcePoolName or ResourcePoolId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ResourcePoolId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>Object Id of a DFM Resource pool. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcePoolName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>DFM Resource pool Name</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="RoleAttributesIdentifier">
                <xsd:annotation>
                    <xsd:documentation>The Attributes of a role: role Name and Id, inherited roles, Capabilities and operations.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Capabilities" type="na:ArrayOfRbacResourceOperation">
                        <xsd:annotation>
                            <xsd:documentation>Capabilities assigned To the given role and inherited roles.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the role</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="InheritedRoles" type="na:ArrayOfRbacRoleResource">
                        <xsd:annotation>
                            <xsd:documentation>List of inherited roles</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RoleNameAndId" type="na:WrapperOfRbacRoleResource">
                        <xsd:annotation>
                            <xsd:documentation>Role Name and its Id</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="StorageServiceResource">
                <xsd:annotation>
                    <xsd:documentation>Identifies a storage Service Resource. When used as input, only one of StorageServiceName or StorageServiceId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="StorageServiceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>A Storage Service identifier.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageServiceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>A Storage Service Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VfilerResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a Vfiler Resource. When used as input only one of VfilerNameOrUuid or VfilerId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="VfilerId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The object Id of a Vfiler. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerNameOrUuid" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The FQDN or UUID of a Vfiler</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VfilerTemplateResource">
                <xsd:annotation>
                    <xsd:documentation>Identifies a Vfiler template Resource. When used as input only one of VfilerTemplateName or VfilerTemplateId is specified. When used as output, both of them will be returned.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="VfilerTemplateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>A vFiler template identifier.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplateName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>A vFiler template Name.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeNameOrId">
                <xsd:annotation>
                    <xsd:documentation>A Volume Name or Id. When used as input only one of VolumeName or VolumeId is specified. When used as output, both of them will be returned. If VolumeName is specified, then either HostIdentifier, VfilerIdentifier or AggregateIdentifier must also be specified but not both.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="VolumeId" type="xsd:unsignedInt">
                        <xsd:annotation>
                            <xsd:documentation>The object Id of a Volume. Range: [0..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of a Volume. Also need either HostIdentifier, VfilerIdentifier or AggregateIdentifier.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeResource">
                <xsd:annotation>
                    <xsd:documentation>Details of a Volume.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AggregateIdentifier" type="na:WrapperOfAggregateResource">
                        <xsd:annotation>
                            <xsd:documentation>Volume within an Aggregate</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HostIdentifier" type="na:WrapperOfHostResource">
                        <xsd:annotation>
                            <xsd:documentation>Host on which the Volume resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerIdentifier" type="na:WrapperOfVfilerResource">
                        <xsd:annotation>
                            <xsd:documentation>Volume within a Vfiler e.g. Vfiler where the Volume resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeIdentifierNameOrId" type="na:WrapperOfVolumeNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>The Volume Name or Id. If a Volume Name is specified, then either AggregateIdentifier, VfilerIdentifier or HostIdentifier must also be specified.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="GraphInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the meta data of a graph</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DeprecatedBy" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the graph that replaces this graph. Will be absent for non-deprecated Graphs. Only returned via the GraphListInfoIterNext api.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the graph. Maximum Length of 1024 characters. Only returned via the ReportGraphListInfoIterNext api.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GraphLines" type="na:ArrayOfGraphLineInfo">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the list of Lines in the graph. Only returned via the GraphListInfoIterNext api.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="GraphName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Name of the graph. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="GraphPrettyName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Long Name of the graph. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDefault" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether the graph is the default graph for the report. Only returned via the ReportGraphListInfoIterNext api.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDeprecated" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>true if the graph is deprecated. Only returned via the GraphListInfoIterNext api.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="GraphLineInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the meta data of a line in a graph.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="SampleFormat" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The format in which the sample Value is returned. Possible Values: &lt;ul&gt; &lt;li&gt; 'integer' &lt;li&gt; 'float' &lt;/ul&gt; Range of the sample Value if integer: [0..(2^63) - 1] Range of the sample Value if float: [0..(2^63) - 1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SampleName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the sample. Maximum Length: 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SamplePrettyName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the sample which can be used for displaying. Maximum Length: 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SampleSuffix" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Unit of the sample. If the Unit is not known then 'none' is returned. Possible Values: &lt;ul&gt; &lt;li&gt; 'bytes' &lt;li&gt; 'percentage' &lt;li&gt; 'minutes' &lt;li&gt; 'none' &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ReportApplication">
                <xsd:annotation>
                    <xsd:documentation>Specifies the application To which a report belongs. This typedef is an alias for the built-in ZAPI Type &lt;b&gt;string&lt;/b&gt;. Possible Values: &lt;ul&gt; &lt;li&gt; 'control_center' &lt;li&gt; 'backup' &lt;li&gt; 'disaster_recovery' &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ReportInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the Name of the report.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DeprecatedBy" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the report that replaces this report. Will be absent for non-deprecated Reports.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the report. Max Length: 1024 chars</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DisplayTab" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The tab where a report is displayed in DFM UI. Possible Values: &lt;ul&gt; &lt;li&gt; 'Aggregates' &lt;li&gt; 'appliances' &lt;li&gt; 'data_sets' &lt;li&gt; 'Events' &lt;li&gt; 'filesrm' &lt;li&gt; 'filesystems' &lt;li&gt; 'Luns' &lt;li&gt; 'resource_pools' &lt;li&gt; 'sans' &lt;li&gt; 'scripts' &lt;li&gt; 'vfilers' &lt;li&gt; 'others' &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDeprecated" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>true if the report is deprecated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="OutputFormatList" type="na:ArrayOfReportOutputFormat">
                        <xsd:annotation>
                            <xsd:documentation>The list of output formats supported by report.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RbacOperation" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The Name of the RBAC Operation required To View the report. Use RbacOperationInfoList To get the list of currently valid operations. Max Length: 255 chars</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportApplication" type="na:ReportApplication">
                        <xsd:annotation>
                            <xsd:documentation>Application To which the report belongs.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ReportId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the report in case of Custom Reports. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ReportName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique Name of the report. Max Length: 64 chars</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportPrettyName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Long Name of the report. Max Length: 64 chars</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the report. Possible Values: &lt;ul&gt; &lt;li&gt; 'built_in' &lt;li&gt; 'custom' &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ReportOutputFormat">
                <xsd:annotation>
                    <xsd:documentation>The Type of output format. This typedef the built-in ZAPI Type &lt;b&gt;string&lt;/b&gt;. Possible Values: &lt;ul&gt; &lt;li&gt; 'csv' &lt;li&gt; 'html' &lt;li&gt; 'paragraph' &lt;li&gt; 'perl' &lt;li&gt; 'text' &lt;li&gt; 'xls' &lt;li&gt; 'xml' &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ReportOutputInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the contents of an output.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="FailureReason" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Reason as To why the output failed. Present only in case of failure. Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GraphName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the graph.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportApplication" type="na:ReportApplication">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the application To which a report belongs. Default is 'control_center'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ReportId">
                        <xsd:annotation>
                            <xsd:documentation>specifies the Id of the report in case of custom Reports. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ReportName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the report.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportOutputId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the output Id. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ReportScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Id of the report schedule. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the report schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RunBy" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the user who generated the report output. Maximum Length of 255 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="RunStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Status of the report output. Possible Values: &lt;ul&gt; &lt;li&gt; 'pending' &lt;li&gt; 'running' &lt;li&gt; 'succeeded' &lt;li&gt; 'failed' &lt;li&gt; 'aborted' &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="RunTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Timestamp when the output was saved. Not present if the report output is in pending, running or aborted state. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TargetObjectId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the object on which the output was generated. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="TargetObjectName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the object on which the output was generated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ReportScheduleContentInfo">
                <xsd:annotation>
                    <xsd:documentation>Describes the contents of a report schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="ArchivalFormat" type="na:ReportOutputFormat">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the format in which the report is saved.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EmailAddressList" type="na:EmailAddressList">
                        <xsd:annotation>
                            <xsd:documentation>Email addresses of recipients for a mail To be sent with an attachment when the report is generated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GraphName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the graph. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IncludeDeletedObjects" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Include deleted Objects in the report generated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether the state of the report schedule is enabled.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsSuccessful" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether the last run Result was successful. This element is not present if the report schedule has not run even once.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastRunTime" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Timestamp when the report was last run. This element is not present if the report schedule has not run even once. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportApplication" type="na:ReportApplication">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the application To which a report belongs. Default is 'control_center'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ReportId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Id of the custom report. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ReportName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the report.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportScheduleId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the schedule Id. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ReportScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the report schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="SaveAllFields" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Saves all fields, Only in perl and xml format.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ScheduleId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Id of the schedule. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="ScheduleName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TargetObjectId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Id of the object on which the report schedule is scheduled To run. Range: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="TargetObjectName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the object on which the report schedule is scheduled To run.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ReportScheduleInfo">
                <xsd:annotation>
                    <xsd:documentation>Detailed contents of a report schedule.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ArchivalFormat" type="na:ReportOutputFormat">
                        <xsd:annotation>
                            <xsd:documentation>Format of the report To be saved. Default Value is html.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="EmailAddressList" type="na:EmailAddressList">
                        <xsd:annotation>
                            <xsd:documentation>Email addresses of recipients for a mail To be sent with an attachment when the report is generated.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="GraphName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the graph. The graph Name is validated as follows: - It should belong To the report Name specified. - It should be applicable To the Target object. - The License should support the graph. Maximum Length of 64 characters.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IncludeDeletedObjects" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Include deleted Objects in the report generated. Default Value is FALSE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ReportApplication" type="na:ReportApplication">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the application To which a report belongs. Default is 'control_center'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ReportNameOrId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the report. For custom Reports it can either be Name or Id. Required for ReportScheduleAdd API. Range for Id: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ReportScheduleName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Name of the report schedule To be created. This element is mandatory for 'ReportScheduleAdd'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SaveAllFields" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Saves all fields, Ignored if ArchivalFormat is not perl or xml. Default Value is FALSE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ScheduleNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or Id of a schedule. Required for ReportScheduleAdd API. Range for Id: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TargetObjectNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the Target object on which the report has To be scheduled. The object Type depends on the Name of the report specified. For ex: controller-details report can run on a Target object which is of Type Host. Range for Id: [1..(2^31)-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="DatasetSpaceInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a datset consuming space From the Aggregate.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpNodeId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the node in the Dataset that is consuming space From the Aggregate. If there is no protection Policy associated with the Dataset, NodeId will be 1. Range: [1..2^32-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="4294967295"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="DpNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node in the Dataset that is consuming space From the Aggregate. If there is no protection Policy associated with the Dataset, this would return the Name of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsCapableOfMigration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the Dataset is capable of migration. This is returned true only if the Dataset can be migrated in a transparent way using vFiler migration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDpNodeEffectivePrimary" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies whether the node in the Dataset that is consuming space From the Aggregate is the effective primary node or not.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="UsedSpace" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>Space used by the Dataset on the Aggregate in bytes. Range: [0..2^64-1].</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ResourceTag">
                <xsd:annotation>
                    <xsd:documentation>Label for the Resource. Can be of Maximum 255 characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="ResourcepoolDefaults">
                <xsd:annotation>
                    <xsd:documentation>The default Values of the Attributes defined by this ZAPI.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ResourcepoolFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate a "Resource pool full" event for this Resource pool. Setting threshold percentages higher than 100% allows an administrator To set it in such a way so that it never trigger these Events. Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolNearlyFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate a "Resource pool nearly full" event for this Resource pool. Setting threshold percentages higher than 100% allows an administrator To set it in such a way so that it never trigger these Events. Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResourcepoolInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Resource pool.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AggregateNearlyOvercommittedThreshold" type="xsd:unsignedShort">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate an "Resourcepool nearly overcommitted" event for all the Resource pools. If the Value specified is empty, then the setting is cleared and the Value specified in global Options for aggrNearlyOvercommittedThreshold will be used. Range: [0..65535]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AggregateOvercommittedThreshold" type="xsd:unsignedShort">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate an "Resourcepool overcommitted" event for all the Resource pools. If the Value specified is empty, then the setting is cleared and the Value specified in global Options for aggrOvercommittedThreshold will be used. Range: [0..65535]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourceTag" type="na:ResourceTag">
                        <xsd:annotation>
                            <xsd:documentation>A label that can be associated with a Resource pool.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolContact" type="na:EmailAddressList">
                        <xsd:annotation>
                            <xsd:documentation>Contact information for the Resource pool, such as the owner's e-mail Address. This is modifiable.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the Resource pool, up To 255 characters long. This is modifiable.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolFreeVfilers" type="xsd:unsignedLong">
                        <xsd:annotation>
                            <xsd:documentation>The number of vFiler units that can be created in this Resource pool based on the current limit and number of vFiler units present in the storage systems that are Members of the Resource pool. Ignored for ResourcepoolCreate and ResourcepoolModify. Range: [0..2^64-1].</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate a "Resource pool full" event for this Resource pool. If the Value specified is empty, then the Resource pool setting is cleared and the Value specified in ResourcepoolGetDefaults is used. Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Resource pool. Its a valid DFM object Id. A valid DFM object Id would be in the range of [1..2^31-1]. Ignored for ResourcepoolCreate and ResourcepoolModify.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolIsProvisionable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>This is returned in ResourcepoolListInfoIterNext if LicenseFilter, ResourceTag or reliability information is passed in the input, this is set To true or false depending on whether the Resource pool meets all the three filters, Default Value is set To TRUE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolKbytesAvailable">
                        <xsd:annotation>
                            <xsd:documentation>Amount of Kbytes of storage available in this Resource pool. This Value only present if IncludeFreeSpace was true. Ignored for ResourcepoolCreate and ResourcepoolModify. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolKbytesTotal">
                        <xsd:annotation>
                            <xsd:documentation>Total amount of Kbytes of storage in this Resource pool. This Value only present if IncludeFreeSpace was true. Ignored for ResourcepoolCreate and ResourcepoolModify. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolKbytesUsed">
                        <xsd:annotation>
                            <xsd:documentation>Amount of Kbytes of storage used in this Resource pool. This Value only present if IncludeFreeSpace was true. Ignored for ResourcepoolCreate and ResourcepoolModify. Range: [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolMemberCount">
                        <xsd:annotation>
                            <xsd:documentation>The Count of direct Members added To the Resource pool. This includes number of storage systems and Aggregates added To the Resource pool. Ignored for ResourcepoolCreate and ResourcepoolModify. Range: [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Resource pool. This is modifiable. This must be specified in ResourcepoolCreate. Its a valid DFM object Name. A valid DFM object Name would contain at least one non-numeric character.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolNearlyFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate a "Resource pool nearly full" event for this Resource pool. If the Value specified is empty, then the Resource pool setting is cleared and the Value specified in ResourcepoolGetDefaults is used. Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolOwner" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the owner of the Resource pool, up To 255 characters long. This is modifiable.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolPerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current performance Status of the Resource pool. Ignored for ResourcepoolCreate and ResourcepoolModify.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolSpaceStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Space Status of the Resource pool. Possible Values are: &lt;ul&gt; &lt;li&gt; ok : Sum of used space of all Aggregates in the Resource pool against the sum of Total Size of all Aggregates has not reached or crossed ResourcepoolNearlyFullThreshold and none of the member Aggregates have reached or crossed their full Thresholds. &lt;li&gt; member_nearly_full : Atleast one of the member Aggregates of the Resource pool has reached or crossed its nearly full threshold. &lt;li&gt; nearly_full : Sum of used space of all Aggregates in the Resource pool against the sum of Total Size of all Aggregates has reached or crossed ResourcepoolNearlyFullThreshold. &lt;li&gt; member_full : Atleast one of the member Aggregates of the Resource pool has reached or crossed its full threshold. &lt;li&gt; full : Sum of used space of all Aggregates in the Resource pool against the sum of Total Size of all Aggregates has reached or crossed ResourcepoolFullThreshold. &lt;/ul&gt; ResourcepoolSpaceStatus is returned only if IncludeFreeSpace is true in ResourcepoolListInfoIterStart .</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Resource pool. Ignored for ResourcepoolCreate and ResourcepoolModify.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourcepoolTimezone" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Time zone in which this pool's storage is located. This is modifiable. An empty Value means To use the system default (usually GMT). Currently valid time zones can be listed by TimezoneListInfoIterStart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="ResourcepoolMemberInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about one member of a Resource pool.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetsSpaceInfo" type="na:ArrayOfDatasetSpaceInfo">
                        <xsd:annotation>
                            <xsd:documentation>Space used by each Dataset in the Aggregate. Returned only when MemberType is 'Aggregate' and if IncludeDatasetSpaceInfo is set To true in ResourcepoolMemberListInfoIterStart.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberCommittedSpace" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Committed space of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the member. Its a valid DFM object Id. A valid DFM object Id would be in the range of [1..2^31-1].</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Display Name of the member. Its a valid DFM object Name. A valid DFM object Name would contain at least one non-numeric character.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberSize" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Total Size of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MemberSpaceStatus" type="na:ObjectSpaceStatus">
                        <xsd:annotation>
                            <xsd:documentation>Space Status of the Resource pool member. This indicates the fullness of the Aggregate in terms of whether the percentage of used space with respect To Total Size of the Aggregate has reached or crossed the fullness Thresholds. This Value is returned only when MemberType is 'Aggregate'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the member. Possible Values are 'normal', 'information', 'unknown', 'warning', 'Error', 'critical', 'emergency'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of the member. Possible Values are 'Filer' or 'Aggregate'.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="MemberUsedSpace" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Used space of the member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningChecksPassed" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Set To true, if all the member passes all the provisioning related checks for given provisioning Policy and provisioning Request. Applicable only when RunProvisioningChecks is set To true at the start of iteration.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ResourceTag" type="na:ResourceTag">
                        <xsd:annotation>
                            <xsd:documentation>A label for a Resource pool member.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="BackupInfo">
                <xsd:annotation>
                    <xsd:documentation>Information of a Dataset backup.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="BackupId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the backup Instance. The management station assigns a unique Id To each backup Instance. Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="BackupVersion" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Timestamp when the backup was taken. Backups of same Dataset at different locations have same Version if their contents are identical. The management station keeps track of which Backups have identical contents and assigns same Version To them. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Dataset To which this backup Instance is associated with.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset To which this backup Instance is associated with.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpBackupExpiryTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Time when this backup Instance will expire, at which point Protection Manager will delete this backup. The Timestamp Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. This will not be returned when the Retention Type for the backup is unlimited.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpNodeId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Id of the Dataset node which holds the backup Instance.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpNodeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset node which holds the backup Instance.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsApplicationBackup" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True, if the backup in an application consistent backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="Snapshot">
                <xsd:annotation>
                    <xsd:documentation>Information of one Snapshot copy. Either UniqueId or Name of the Snapshot copy should be specified.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="SnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy. If UniqueId is specified, then this element is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="UniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique identifier of the Snapshot copy. Currently, this is the Snapshot copy's creation time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="SnapshotDependency">
                <xsd:annotation>
                    <xsd:documentation>Application dependent on this Snapshot copy. Possible Values: "snapmirror", "snapvault", "dump", "volume_clone", "lun_clone", "snaplock", "acs".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="SnapshotInfo">
                <xsd:annotation>
                    <xsd:documentation>Information on one particular Snapshot copy.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="Backups" type="na:ArrayOfBackupInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of Dataset Backups which contain this Snapshot. The list is empty if the Snapshot is not part of any Dataset backup. The element is present only if &lt;b&gt;SnapshotListInfoIterStart&lt;/b&gt; was called with &lt;b&gt;IncludeBackupInfo&lt;/b&gt; as true.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CreationTimestamp" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>The Volume access time when the Snapshot copy was created in seconds since January 1, 1970. This Value will not change even if the Snapshot copy is accessed.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="CumulativePercentageOfTotalBlocks">
                        <xsd:annotation>
                            <xsd:documentation>Percentage of blocks owned by this Snapshot copy and all of the more recent Snapshots copies, relative To the Total number of blocks in the Volume. Range: [0..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Dependencies" type="na:ArrayOfSnapshotDependency">
                        <xsd:annotation>
                            <xsd:documentation>Application(s) dependent on this Snapshot copy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsBusy" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Snapshot copy is being used by an application. If "IsBusy" is true, then the Snapshot copy cannot be deleted.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsPartOfBackupVersion" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Snapshot copy is part of a backup Version of a Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="PercentageOfTotalBlocks">
                        <xsd:annotation>
                            <xsd:documentation>Percentage of blocks owned by this Snapshot copy, relative To the Total number of blocks in the Volume. Range: [0..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SnapshotId">
                        <xsd:annotation>
                            <xsd:documentation>Database identifier of this Snapshot copy. &lt;br&gt; Range: [1..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SnapshotName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot copy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="UniqueId" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Unique identifier of the Snapshot copy. Currently, this is the Snapshot copy's creation time.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Idenitifier of the Volume To which this Snapshot copy belongs To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Volume To which this Snapshot copy belongs To.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ResourcepoolNameOrId">
                <xsd:annotation>
                    <xsd:documentation>Resource Pool. Value can be a DFM object Name (Maximum 255 characters) or the DFM Id [1..2^31-1].</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="StorageServiceDatasetInfo">
                <xsd:all>
                    <xsd:element name="DatasetId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DatasetName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageServiceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage Service. This will not be returned if the Dataset is not associated with the storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="StorageServiceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage Service. This will not be returned if the Dataset is not associated with the storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="StorageServiceInfo">
                <xsd:all>
                    <xsd:element minOccurs="0" name="Datasets" type="na:ArrayOfDatasetReference">
                        <xsd:annotation>
                            <xsd:documentation>List of Datasets attached To the storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the protection Policy</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProtectionPolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the protection Policy.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StorageServiceContact" type="na:EmailAddressList">
                        <xsd:annotation>
                            <xsd:documentation>Contact for the storage Service, such as the owner's e-mail Address.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StorageServiceDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the new storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StorageServiceId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StorageServiceName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StorageServiceNodes" type="na:ArrayOfStorageServiceNodeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about storage Service nodes.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="StorageServiceOwner" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the owner of the storage Service.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="StorageServiceNodeAttributes">
                <xsd:all>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node in the data protection Policy. &lt;b&gt;DpNodeName&lt;/b&gt; must Match exactly the Name of one of the nodes in the data protection Policy that is currently assigned To the storage Service. This element can be absent if no protection Policy was assigned To the storage Service, in which case, the details are assumed for the primary node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OldDpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the old data protection Policy node To be mapped To the new data protection Policy node. When the data protection Policy of storage Service is modified and this element is provided, the node DpNodeName of the new Policy will acquire the Attributes of this node. Also for all the Datasets attached To the storage Service, storage sets mapped To OldDpNodeName of the old protection Policy will be re-mapped To node DpNodeName of the new protection Policy. If not provided when data protection Policy is being modified, for all the Datasets attached To the storage Service, new storage sets would be created for node DpNodeName. This element is only used by StorageServiceModify and StorageServiceDatasetModify API for 'attach' Operation Type. This input is ignored in StorageServiceCreate API</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the provisioning Policy To be associated with the node. This element is used only by StorageServiceCreate and StorageServiceModify API. This element will be ignored, if specified for StorageServiceDatasetModify API. In StorageServiceModify API, if the Value specified for the element is empty, then the provisioning Policy associated with the node will be cleared.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Resourcepools" type="na:ArrayOfResourcepoolNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the Resource pools To be associated with the node. This element is used only by StorageServiceCreate and StorageServiceModify API. This element will be ignored, if specified for StorageServiceDatasetModify API.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplateNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the vFiler template To be used To create a vFiler Unit for Dataset node. This element is valid only for primary node of the storage Service. This element is used only by StorageServiceCreate and StorageServiceModify API. This element will be ignored, if specified for StorageServiceDatasetModify API. In StorageServiceModify API, if the Value specified for the element is empty, then the vFiler template associated with the node will be cleared.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="StorageServiceNodeInfo">
                <xsd:all>
                    <xsd:element name="DpNodeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>ID of the node in the data protection Policy that maps To the storage Service node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="DpNodeName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node in the data protection Policy that maps To the storage Service node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the provisioning Policy associated with the node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ProvisioningPolicyName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the provisioning Policy associated with the node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Resourcepools" type="na:ArrayOfResourcepoolInfo">
                        <xsd:annotation>
                            <xsd:documentation>List of the Resource pools associated with the node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the vFiler template associated with the node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplateName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the vFiler template associated with the node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="StorageSetInfo">
                <xsd:all>
                    <xsd:element minOccurs="0" name="DatasetAccessDetails" type="na:DatasetAccessDetails">
                        <xsd:annotation>
                            <xsd:documentation>Details of the vFiler Unit To be created through which the Dataset Members provisioned for this node will be exported. This element can be specified only for the primary node. Both ServerNameOrId and DatasetAccessDetails cannot be specified for a node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetExportInfo" type="na:DatasetExportInfo">
                        <xsd:annotation>
                            <xsd:documentation>Specifies the NAS or SAN export settings for Members provisioned in this node of the Dataset</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DpNodeName" type="na:DpPolicyNodeName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the node in the data protection Policy. &lt;b&gt;DpNodeName&lt;/b&gt; must Match exactly the Name of one of the nodes in the data protection Policy that is currently assigned To the storage Service. This element can be absent if no protection Policy was assigned To the storage Service, in which case, the details are assumed for the root storage set.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="ServerNameOrId" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the vFiler Unit To be attached To the node. If a vFiler Unit is attached, then all Members provisioned into this node will be exported over this vFiler Unit. Both ServerNameOrId and DatasetAccessDetails cannot be specified for a node.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="TimezoneName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Timezone To assign To the node. If specified, the Value must be a TimezoneName returned by TimezoneListInfoIterNext. If no Timezone is assigned, then the default system Timezone will be used.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="TimezoneDefaults">
                <xsd:annotation>
                    <xsd:documentation>The default time zone settings.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="DefaultTimezone" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the time zone To use for Objects that do not specify a time zone. This may be empty, meaning that Objects use the server's time zone by default. Set this Value with the "dfm Option set timezone={new-value}" command.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ServerTimezoneDescription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of the time zone in which this DFM server is located. If the "DefaultTimezone" is empty, Objects without an explicit time zone setting will use the server's time zone. Example Values: &lt;ul&gt; &lt;li&gt; "Pacific Standard Time (GMT -8:00)" &lt;li&gt; "US/Eastern (GMT -4:00)" &lt;li&gt; "SGT (GMT +6:00)" &lt;li&gt; "UTC (GMT +0:00)" &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="TimezoneInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a time zone.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="TimezoneName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of time zone.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="UserReportInfo">
                <xsd:annotation>
                    <xsd:documentation>Report Count of users.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Count" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Number of Reports of a user.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="UserName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the user.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="IpAddress">
                <xsd:annotation>
                    <xsd:documentation>IP Address in string format. The Length of this string cannot be more than 40 characters.</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="IpBindingInfo">
                <xsd:annotation>
                    <xsd:documentation>vFiler IP Address To Interface binding information.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="Interface" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the Interface To bind the vFiler IP Address To. This can be either a physical Interface, VIF or a VLAN. Example: "e0a", "myvif", "service_vlan"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IpAddress" type="na:IpAddress">
                        <xsd:annotation>
                            <xsd:documentation>IP Address of the vFiler which is bound To the Interface. If this IP Address is not already added To the vFiler, then the IP Address is first added To the vFiler before binding the IP Address with the given Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MtuSize">
                        <xsd:annotation>
                            <xsd:documentation>MTU Size of the new VLAN Interface. This element should be present only if a new VLAN Interface is being created during vFiler setup. Also the Version of Data ONTAP on the storage system on which the vFiler is being setup, should be 7.3.3 or later. Range: [296..9196]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="296"/>
                                <xsd:maxInclusive value="9196"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Netmask" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Netmask for the IP Address in dotted decimal notation. For IPv4 Address, either Netmask or PrefixLength can be supplied. For IPv6 Address, Netmask is ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PartnerInterface" type="na:ObjNameOrId">
                        <xsd:annotation>
                            <xsd:documentation>Name or identifier of the Interface on the partner node. This element is valid when the storage system on which this vFiler Unit is present is in a Active/Active configuration. If a new VLAN is getting created on the local node, then a new corresponding VLAN will also be created on the partner node on this Interface.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="PrefixLength">
                        <xsd:annotation>
                            <xsd:documentation>Prefix Length for the IP Address. This is required if IPv6 Address is supplied. For IPv4 Address, either Netmask or PrefixLength can be supplied. Range: [1..127]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="127"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VlanIdentifier">
                        <xsd:annotation>
                            <xsd:documentation>Identifier for creating a new VLAN Interface. If this element is present, the Interface element should refer To a physical VLAN tagged Interface. Range: [1..4094]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="4094"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="Protocol">
                <xsd:annotation>
                    <xsd:documentation>Name of the Protocol. Possible Values: "nfs", "cifs", "iscsi".</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:complexType name="VfilerTemplateInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a vFiler Template.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="AdministrativeHostIpAddress" type="na:IpAddress">
                        <xsd:annotation>
                            <xsd:documentation>IP Address of the vFiler's administrative Host. By default, this field is empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CifsAuthType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>CIFS authentication mode To be used for the CIFS setup of a vFiler. This determines the method by which clients will be authenticated when connecting To the CIFS Service on the vFiler. Possible Values: "active_directory", "workgroup". Default Value: "workgroup"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CifsDomain" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Active Directory domain To which the vFiler will join To. This can be the NetBIOS or fully qualified domain Name. Examples: cifsdomain, cifs.domain.com This field is applicable only when CifsAuthType is set To "active-directory" and is ignored otherwise.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="CifsSecurityStyle" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The security style determines whether or not the CIFS Service on vFiler will support multiprotocol access. Possible Values: "ntfs", "multiprotocol". Default Value is: "multiprotocol"</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Description of vFiler template. By default, this field is empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DnsDomain" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the DNS domain for a vFiler that is setup using this vFiler template. By default, this field is empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DnsServers" type="na:ArrayOfIpAddress">
                        <xsd:annotation>
                            <xsd:documentation>List of DNS servers for a vFiler that is setup using this vFiler template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NisDomain" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the NIS domain for a vFiler that is setup using this vFiler template. By default, this field is empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NisServers" type="na:ArrayOfIpAddress">
                        <xsd:annotation>
                            <xsd:documentation>List of NIS servers for a vFiler that is setup using this vFiler template.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplateId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the vFiler template. This is ignored in VfilerTemplateCreate.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VfilerTemplateName" type="na:ObjName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the vFiler template. This must be specified in VfilerTemplateCreate.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:simpleType name="ObjectSpaceStatus">
                <xsd:annotation>
                    <xsd:documentation>Space Status of the object. This indicates the fullness of the object in terms of whether the percentage of used space with respect To Total Size of the object has reached the fullness Thresholds. Possible Values: &lt;ul&gt; &lt;li&gt; ok - when the percentage of used space of the object is within the nearly full and full threshold of the object. &lt;li&gt; nearly_full - when the percentage of used space of the object is within the full threshold of the object but has reached or crossed the nearly full threshold. &lt;li&gt; full - when the percentage of used space of the object has reached or crossed the full threshold of the object. &lt;/ul&gt;</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
            <xsd:simpleType name="Timestamp">
                <xsd:annotation>
                    <xsd:documentation>Seconds since 1/1/1970 in UTC. Range: [0..2^31-1].</xsd:documentation>
                </xsd:annotation>
                <xsd:restriction base="xsd:integer"/>
            </xsd:simpleType>
            <xsd:complexType name="VolumeDedupeInfo">
                <xsd:annotation>
                    <xsd:documentation>Volume deduplication information. Optional fields will not be returned if deduplication has never run on the Volume.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="DedupeProgress" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The progress of the current deduplication Operation on the Volume with information as To which stage of de-duplication is currently in progress and how much data is processed for that stage. For eg: "25 MB Scanned, 20MB Searched, 40MB (20%) Done , 30MB Verified".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeSpaceSavings">
                        <xsd:annotation>
                            <xsd:documentation>Space savings as a Result of deduplication on the Volume in bytes. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeSpaceSavingsPercentage">
                        <xsd:annotation>
                            <xsd:documentation>Percentage of space savings generated by the shared space. Range: [0..100]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="100"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DedupeStatus" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Deduplication Operation Status of the Volume. Possible Values: "idle", "active", "pending", or "undoing".</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsDedupeEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Specifies if deduplication is enabled on the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastDedupeBeginTimestamp" type="na:Timestamp">
                        <xsd:annotation>
                            <xsd:documentation>Start Timestamp of the last deduplication Operation. The Value is in seconds since January 1, 1970. Range : [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastDedupeEndTimestamp" type="na:Timestamp">
                        <xsd:annotation>
                            <xsd:documentation>End Timestamp of the last deduplication Operation on the Volume. The Value is in seconds since January 1, 1970. Range : [0..2^31-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastDedupeError" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>A human readable Error message of the last deduplication Operation on the Volume. Returned only when there is a valid Error.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="LastDedupeScannedSize">
                        <xsd:annotation>
                            <xsd:documentation>The Size scanned in bytes of the last deduplication Operation on the Volume. Range : [0..2^63-1].</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeInfo">
                <xsd:annotation>
                    <xsd:documentation>Information about a Volume.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element name="AggregateId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Aggregate on which the Volume resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="AggregateName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Aggregate on which the Volume resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="BlockType" type="na:FileSystemBlockType">
                        <xsd:annotation>
                            <xsd:documentation>File system block Type of the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetId">
                        <xsd:annotation>
                            <xsd:documentation>ID of Dataset where this Qtree is in the primary storage set. Range: [1..2^31-1] This field is deprecated in favor of Datasets, which lists all Datasets the Volume belongs To. It is still populated with one of the Dataset ids.</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="1"/>
                                <xsd:maxInclusive value="2147483647"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="DatasetNodes" type="na:ArrayOfDatasetNodeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Information about the Dataset nodes which contain this Volume as member. If IsInDataset is false, this list will be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="Datasets" type="na:ArrayOfDatasetReference">
                        <xsd:annotation>
                            <xsd:documentation>List of Dataset IDs containing this Volume. If IsInDataset is false, this list will be empty.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of Host on which the Volume resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="HostName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of Host on which the Volume resides.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsAvailable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this object and all of it's parents are up or online. Only output if the call To iter-start included the "IncludeIsAvailable" flag.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsCapableOfMigration" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether the Volume can be migrated. Returned only when IncludeMigrationInfo is true in VolumeListInfoIterStart call. &lt;p&gt; A Volume is considered as capable of migration in a transparent way (using MigrateVolume API) when the following conditions holds good for the Volume. &lt;ul&gt; &lt;li&gt; The Volume or any of its Qtrees has no NFS exports &lt;li&gt; The Volume or any of its Qtrees has no CIFS shares &lt;li&gt; The Volume or any of its Qtrees has no LUNs mapped To storage clients. &lt;li&gt; The Volume has no child clone Volumes. &lt;li&gt; There are no incoming and outgoing protection relationships that are not managed by Protection Manager. &lt;li&gt; The Volume is not the root storage of a storage system or vFiler Unit. &lt;li&gt; The Volume is not of 'Traditional' Type. &lt;li&gt; The Volume is managed by "node" management Interface. &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="IsDpIgnored" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if this Dataset is intentionally ignored.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsInDataset" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicate whether this Volume is a member of any Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsReadonlyVolume" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is readonly.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapmirrorPrimaryCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is capable of being a primary for a SnapMirror relationship. This means the storage system is licensed for SnapMirror.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapmirrorPrimaryVolume" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is a primary Volume for a SnapMirror relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapmirrorSecondaryCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is capable of being a secondary for a SnapMirror relationship. This means the storage system is licensed for SnapMirror and the Volume is not already a SnapMirror or SnapVault secondary.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapmirrorSecondaryVolume" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is a destination of Qtree or Volume SnapMirror relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapvaultPrimaryCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is capable of being the Source of a SnapVault transfer. This means the storage system is licensed To be a SnapVault primary.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapvaultPrimaryVolume" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume contains at least one Qtree which is the Source of a SnapVault backup.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapvaultSecondaryCapable" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is capable of being the destination of SnapVault transfers. This means the storage system is licensed as a SnapVault secondary and the Volume is not a SnapMirror destination.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsSnapvaultSecondaryVolume" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is a secondary Volume for storing SnapVault Backups.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="IsVsmSecondaryVolume" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>True if the Volume is a destination of Volume SnapMirror relationship.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="NextScheduledBackupTime" type="na:DpTimestamp">
                        <xsd:annotation>
                            <xsd:documentation>Time when next scheduled backup job will be run on this Volume. Value is the time in seconds since 00:00:00 Jan 1, 1970, UTC. This is computed and returned only when IncludeNextScheduledBackupTime is true in VolumeListInfoIterStart api. This Value is returned only for Volumes in Datasets that have a protection Policy with relevant schedules on the connections and nodes. When the Volume is in the primary node of the Dataset and if the protection Policy assigned To the Dataset has a local Snapshot schedule associated, this returns the next Timestamp when the local Snapshot job will run for the Dataset. When the Volume is in a non-primary node of the Dataset and the incoming or outgoing connection of the protection Policy has a backup/mirror schedule, this will return the least Timestamp when the next backup/mirror job will run for the Dataset for those connection(s).</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotVolumeId" type="na:ObjId">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Snapshot space for the Volume i.e "Volume.Snapshot" This represents the Snapshot reserve in the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotVolumeName" type="na:ObjFullName">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Snapshot space for the Volume i.e "Volume.Snapshot". This represents the Snapshot reserve in the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapvaultLagWarningThreshold" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Threshold in seconds. DFM generates a warning event when age of the replica for a SnapVault backup relationship exceeds the specified threshold.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapvaultSecondaryScheduleName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of backup schedule associated with secondary Volume. Not present if there is no schedule.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SpaceGuarantee" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>The space reservation style associated with the flexible Volume. Possible Values: &lt;ul&gt; &lt;li&gt; Volume - Indicates that the entire Size of the Volume is preallocated. &lt;li&gt; file - Indicates that the space will be preallocated for all the space-reserved files and LUNs within the Volume. Storage is not preallocated for files and LUNs that are not space-reserved. Writes To these can fail if the underlying Aggregate has no space available To store the written data. &lt;li&gt; none - Indicates that no space will be preallocated. &lt;li&gt; file(disabled) - If a Volume with file guarantee has been brought online when the Aggregate has insufficient free space To preallocate To the Volume. &lt;li&gt; Volume(disabled) - If a Volume with Volume guarantee has been brought online when the Aggregate has insufficient free space To preallocate To the Volume. This field will not be present for traditional Volumes. This field does not appear if VolumeState of the flexible Volume is restricted or offline.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeDedupeInfo" type="na:VolumeDedupeInfo">
                        <xsd:annotation>
                            <xsd:documentation>Volume deduplication information. This is returned only if the Volume is a SIS Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate a "Volume full" event for this Volume and To compute the VolumeSpaceStatus. The order in which the Thresholds are returned is: &lt;ul&gt; &lt;li&gt; If a Volume is governed by a provisioning Policy, then the Thresholds in the provisioning Policy are returned. &lt;li&gt; If the Thresholds are set at Volume level, then those Thresholds are returned. &lt;li&gt; If the Volume is neither governed by a provisioning Policy nor if Thresholds are set at Volume level, then the Value returned will be empty. &lt;/ul&gt; If the Value is empty, then the global setting for Volume full threshold is considered and this can be obtained From DfmGetOption API with OptionName as "volFullThreshold". Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="VolumeId" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Identifier of the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Name of the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeNearlyFullThreshold">
                        <xsd:annotation>
                            <xsd:documentation>The Value (as an integer percentage) of the fullness threshold used To generate a "Volume nearly full" event for this Volume and To compute the VolumeSpaceStatus. The order in which the Thresholds are returned is: &lt;ul&gt; &lt;li&gt; If a Volume is governed by a provisioning Policy, then the Thresholds in the provisioning Policy are returned. &lt;li&gt; If the Thresholds are set at Volume level, then those Thresholds are returned. &lt;li&gt; If the Volume is neither governed by a provisioning Policy nor if the Thresholds are set at Volume level, then the Value returned will be empty. &lt;/ul&gt; If the Value is empty, then the global setting for Volume nearly full threshold is considered and this can be obtained From DfmGetOption API with OptionName as "volNearlyFullThreshold". Range: [0..1000]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="1000"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumePerfStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Volume based on performance Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeQtree" type="na:VolumeQtree">
                        <xsd:annotation>
                            <xsd:documentation>Volume Qtree(s) information. If Volume does not have any Qtree, this structure is not returned.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeSize" type="na:VolumeSize">
                        <xsd:annotation>
                            <xsd:documentation>Volume Size information.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeSpaceStatus" type="na:ObjectSpaceStatus">
                        <xsd:annotation>
                            <xsd:documentation>Space Status of the Volume. This indicates the fullness of the Volume in terms of whether the percentage of used space with respect To Total Size of the Volume has reached or crossed the fullness Thresholds given in VolumeNearlyFullThreshold and VolumeFullThreshold.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeState" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>State of Volume. Possible Values are: &lt;ul&gt; &lt;li&gt; initializing &lt;li&gt; failed &lt;li&gt; offline &lt;li&gt; online &lt;li&gt; partial &lt;li&gt; restricted &lt;li&gt; unknown &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="VolumeStatus" type="na:ObjStatus">
                        <xsd:annotation>
                            <xsd:documentation>Current Status of the Volume based on all Events</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="VolumeType" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Type of Volume. Possible Values are: &lt;ul&gt; &lt;li&gt; traditional &lt;li&gt; flexible &lt;li&gt; striped &lt;/ul&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeQtree">
                <xsd:annotation>
                    <xsd:documentation>Information on Qtrees in the Volume</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="JunctionPath" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>Junction Path of the Volume. Will be present only for Volumes on cluster systems.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="JunctionPathActive" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Junction Path Status of the Volume. Will be present only for Volumes on cluster systems. TRUE if junction Path active else FALSE.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProtectedDataSize" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Summation of Total Size of protected Qtrees.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="ProtectedQtreeCount" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Total number of Qtrees that are in Datasets.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="TotalQtreeCount" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Total number of Qtrees in the Volume.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="UnprotectedDataSize" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Summation of Total Size of unprotected Qtrees.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="UnprotectedQtreeCount" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Total number of Qtrees that are not in any Dataset.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="VolumeSize">
                <xsd:annotation>
                    <xsd:documentation>Collected Size information about a Volume. Optional items will not be returned if DFM does not know the Value.</xsd:documentation>
                </xsd:annotation>
                <xsd:all>
                    <xsd:element minOccurs="0" name="ActualVolumeSize" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Actual Size in bytes of the Volume. For Volumes which are destinations of a Volume SnapMirror relationship, the actual Size of the Volume may differ From the logical Size (reported by the df command). The logical Size for such Volumes is equal To Size of the Source Volume. For all other Volume &lt;b&gt;ActualVolumeSize&lt;/b&gt; will be same as &lt;b&gt;Total&lt;/b&gt; Size.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AfsAvail">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes available in active file system. This will be (AfsTotal - AfsUsed) or the available space in the Aggregate, whichever is lower. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AfsData">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes used To hold user data in active file system. This should Match what you'd get if you added up the file sizes. This includes data and hole reserves, if any. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AfsTotal">
                        <xsd:annotation>
                            <xsd:documentation>Total number of bytes in active file system (Total Volume less Snapshot reserve). Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="AfsUsed">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes used To hold active file system data. This is what "df" Reports as used for the Volume. It includes data, hole reserves, overwrite reserves and Snapshot overflow. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="AfsUsedPerDay">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes used per Day in the active file system of the Volume. This can be either positive or negative depending on the growth of used space in the Volume. Range: [-2^44-1..2^44-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="-17592186044417"/>
                                <xsd:maxInclusive value="17592186044415"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="HoleReserve">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes available in LUNs. Range: [0..2^44-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="17592186044415"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="IsAutosizeEnabled" type="xsd:boolean">
                        <xsd:annotation>
                            <xsd:documentation>Indicates whether this Volume has autosize Feature enabled or not.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="MaximumSize">
                        <xsd:annotation>
                            <xsd:documentation>Maximum Size in bytes that this Volume will be grown up To automatically by ONTAP. This is returned only if IsAutosizeEnabled is true. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OverwriteReserveAvail">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes available reserved space for data overwrites. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OverwriteReserveTotal">
                        <xsd:annotation>
                            <xsd:documentation>Total number of bytes reserved for data overwrites. This is the space reserved for overwriting LUNs and other space-reserved files when the Volume has Snapshots and AfsAvail is zero. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="OverwriteReserveUsed">
                        <xsd:annotation>
                            <xsd:documentation>Number of bytes used in overwrite reserve space. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotReserveAvail">
                        <xsd:annotation>
                            <xsd:documentation>Number of available bytes in Snapshot reserve for this Volume. If SnapshotReserveUsed is greater than SnapshotReserveTotal, this Value will be zero. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotReserveTotal">
                        <xsd:annotation>
                            <xsd:documentation>Total number of bytes of Snapshot reserve. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="SnapshotReserveUsed">
                        <xsd:annotation>
                            <xsd:documentation>Total number of bytes used To hold Snapshot data. This can be greater than the Snapshot reserve Size but will not include any space used out of the overwrite reserve. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                    <xsd:element name="SpaceAllocatedFromAggr" type="xsd:integer">
                        <xsd:annotation>
                            <xsd:documentation>Bytes allocated To the Volume From the Aggregate. In case of Volumes with SpaceGuarantee as "Volume", it would be the Total Size of the Volume, where as in case of Volumes with "file" or "none" guarantee Volumes, it would be the used space From the Aggregate. Range [0..2^44-1]</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element minOccurs="0" name="Total">
                        <xsd:annotation>
                            <xsd:documentation>Total number of bytes in Volume. This includes the Snapshot reserve. Range: [0..2^63-1]</xsd:documentation>
                        </xsd:annotation>
                        <xsd:simpleType>
                            <xsd:restriction base="xsd:integer">
                                <xsd:minInclusive value="0"/>
                                <xsd:maxInclusive value="9223372036854775807"/>
                            </xsd:restriction>
                        </xsd:simpleType>
                    </xsd:element>
                </xsd:all>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfAggregateNameOrId">
                <xsd:sequence>
                    <xsd:element name="AggregateNameOrId" type="na:AggregateNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfAggregateResource">
                <xsd:sequence>
                    <xsd:element name="AggregateResource" type="na:AggregateResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfDailyInfo">
                <xsd:sequence>
                    <xsd:element name="DailyInfo" type="na:DailyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfDatasetResource">
                <xsd:sequence>
                    <xsd:element name="DatasetResource" type="na:DatasetResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfEventTimestampRange">
                <xsd:sequence>
                    <xsd:element name="EventTimestampRange" type="na:EventTimestampRange"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfFilerResource">
                <xsd:sequence>
                    <xsd:element name="FilerResource" type="na:FilerResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfFullNdmpCredentials">
                <xsd:sequence>
                    <xsd:element name="FullNdmpCredentials" type="na:FullNdmpCredentials"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfGroupResource">
                <xsd:sequence>
                    <xsd:element name="GroupResource" type="na:GroupResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfHostResource">
                <xsd:sequence>
                    <xsd:element name="HostResource" type="na:HostResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfHostRoleInfo">
                <xsd:sequence>
                    <xsd:element name="HostRoleInfo" type="na:HostRoleInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfHostUserInfo">
                <xsd:sequence>
                    <xsd:element name="HostUserInfo" type="na:HostUserInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfHostUsergroupInfo">
                <xsd:sequence>
                    <xsd:element name="HostUsergroupInfo" type="na:HostUsergroupInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfHourlyInfo">
                <xsd:sequence>
                    <xsd:element name="HourlyInfo" type="na:HourlyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfLunNameOrId">
                <xsd:sequence>
                    <xsd:element name="LunNameOrId" type="na:LunNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfLunResource">
                <xsd:sequence>
                    <xsd:element name="LunResource" type="na:LunResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfMonthlyInfo">
                <xsd:sequence>
                    <xsd:element name="MonthlyInfo" type="na:MonthlyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfCounterGroup">
                <xsd:sequence>
                    <xsd:element name="PerfCounterGroup" type="na:PerfCounterGroup"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfCounterInstance">
                <xsd:sequence>
                    <xsd:element name="PerfCounterInstance" type="na:PerfCounterInstance"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfDataGroup">
                <xsd:sequence>
                    <xsd:element name="PerfDataGroup" type="na:PerfDataGroup"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfDataSource">
                <xsd:sequence>
                    <xsd:element name="PerfDataSource" type="na:PerfDataSource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfDynamicDataSources">
                <xsd:sequence>
                    <xsd:element name="PerfDynamicDataSources" type="na:PerfDynamicDataSources"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfInstance">
                <xsd:sequence>
                    <xsd:element name="PerfInstance" type="na:PerfInstance"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfObjectCounter">
                <xsd:sequence>
                    <xsd:element name="PerfObjectCounter" type="na:PerfObjectCounter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPerfView">
                <xsd:sequence>
                    <xsd:element name="PerfView" type="na:PerfView"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfPolicyResource">
                <xsd:sequence>
                    <xsd:element name="PolicyResource" type="na:PolicyResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfProvisionMemberRequestInfo">
                <xsd:sequence>
                    <xsd:element name="ProvisionMemberRequestInfo" type="na:ProvisionMemberRequestInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfQtreeNameOrId">
                <xsd:sequence>
                    <xsd:element name="QtreeNameOrId" type="na:QtreeNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfQtreeResource">
                <xsd:sequence>
                    <xsd:element name="QtreeResource" type="na:QtreeResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfQtreeSizeInfo">
                <xsd:sequence>
                    <xsd:element name="QtreeSizeInfo" type="na:QtreeSizeInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfRbacAdminNameOrId">
                <xsd:sequence>
                    <xsd:element name="RbacAdminNameOrId" type="na:RbacAdminNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfRbacOperation">
                <xsd:sequence>
                    <xsd:element name="RbacOperation" type="na:RbacOperation"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfRbacOperationNameDetails">
                <xsd:sequence>
                    <xsd:element name="RbacOperationNameDetails" type="na:RbacOperationNameDetails"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfRbacRoleResource">
                <xsd:sequence>
                    <xsd:element name="RbacRoleResource" type="na:RbacRoleResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfResourceIdentifier">
                <xsd:sequence>
                    <xsd:element name="ResourceIdentifier" type="na:ResourceIdentifier"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfResourcePoolResource">
                <xsd:sequence>
                    <xsd:element name="ResourcePoolResource" type="na:ResourcePoolResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfResourcepoolInfo">
                <xsd:sequence>
                    <xsd:element name="ResourcepoolInfo" type="na:ResourcepoolInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfStorageServiceResource">
                <xsd:sequence>
                    <xsd:element name="StorageServiceResource" type="na:StorageServiceResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfThresholdInfo">
                <xsd:sequence>
                    <xsd:element name="ThresholdInfo" type="na:ThresholdInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfThrottleItemInfo">
                <xsd:sequence>
                    <xsd:element name="ThrottleItemInfo" type="na:ThrottleItemInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfVfilerResource">
                <xsd:sequence>
                    <xsd:element name="VfilerResource" type="na:VfilerResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfVfilerTemplateInfo">
                <xsd:sequence>
                    <xsd:element name="VfilerTemplateInfo" type="na:VfilerTemplateInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfVfilerTemplateResource">
                <xsd:sequence>
                    <xsd:element name="VfilerTemplateResource" type="na:VfilerTemplateResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfVolumeNameOrId">
                <xsd:sequence>
                    <xsd:element name="VolumeNameOrId" type="na:VolumeNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfVolumeResource">
                <xsd:sequence>
                    <xsd:element name="VolumeResource" type="na:VolumeResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="WrapperOfWeeklyInfo">
                <xsd:sequence>
                    <xsd:element name="WeeklyInfo" type="na:WeeklyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfAdminInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="AdminInfo" type="na:AdminInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfAdminName">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="AdminName" type="na:AdminName"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfAggregateInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="AggregateInfo" type="na:AggregateInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfAggregateSpaceInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="AggregateSpaceInfo" type="na:AggregateSpaceInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfAlarmInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="AlarmInfo" type="na:AlarmInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfApiStat">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ApiStat" type="na:ApiStat"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfBackupId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="BackupId" type="na:BackupId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfBackupInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="BackupInfo" type="na:BackupInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfBackupLocationInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="BackupLocationInfo" type="na:BackupLocationInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCapability">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Capability" type="na:Capability"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfChildCount">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ChildCount" type="na:ChildCount"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCifsAcl">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CifsAcl" type="na:CifsAcl"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCifsDomainInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CifsDomainInfo" type="na:CifsDomainInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCifsShareInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CifsShareInfo" type="na:CifsShareInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCifsShareName">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CifsShareName" type="na:CifsShareName"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCifsSharePermission">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CifsSharePermission" type="na:CifsSharePermission"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfClientOptionInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ClientOptionInfo" type="na:ClientOptionInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfClientStatError">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ClientStatError" type="na:ClientStatError"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfClientStats">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ClientStats" type="na:ClientStats"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCommentFieldInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CommentFieldInfo" type="na:CommentFieldInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCommentFieldObjectType">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CommentFieldObjectType" type="na:CommentFieldObjectType"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCommentFieldValue">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CommentFieldValue" type="na:CommentFieldValue"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfConformanceAlert">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ConformanceAlert" type="na:ConformanceAlert"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfConformanceRunResult">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ConformanceRunResult" type="na:ConformanceRunResult"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfCounterThresholdInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="CounterThresholdInfo" type="na:CounterThresholdInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDailyInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DailyInfo" type="na:DailyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetCifsSharePermission">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetCifsSharePermission" type="na:DatasetCifsSharePermission"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetDynamicReferenceInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetDynamicReferenceInfo" type="na:DatasetDynamicReferenceInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetDynamicReferenceParameter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetDynamicReferenceParameter" type="na:DatasetDynamicReferenceParameter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetInfo" type="na:DatasetInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetMapEntry">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetMapEntry" type="na:DatasetMapEntry"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetMemberInfo" type="na:DatasetMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetMemberParameter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetMemberParameter" type="na:DatasetMemberParameter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetNodeInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetNodeInfo" type="na:DatasetNodeInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetReference">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetReference" type="na:DatasetReference"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetResourcepoolInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetResourcepoolInfo" type="na:DatasetResourcepoolInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDatasetSpaceInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DatasetSpaceInfo" type="na:DatasetSpaceInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDay">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Day" type="na:Day"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDayInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DayInfo" type="na:DayInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDestinationHostInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DestinationHostInfo" type="na:DestinationHostInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDfmDiagCounterGroup">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DfmDiagCounterGroup" type="na:DfmDiagCounterGroup"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDfmMetadata">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DfmMetadata" type="na:DfmMetadata"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDfmMetadataField">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DfmMetadataField" type="na:DfmMetadataField"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDirectoryInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DirectoryInfo" type="na:DirectoryInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDiskInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DiskInfo" type="na:DiskInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpBackupContentInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpBackupContentInfo" type="na:DpBackupContentInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpBackupIdInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpBackupIdInfo" type="na:DpBackupIdInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpBackupInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpBackupInfo" type="na:DpBackupInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpBackupPathInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpBackupPathInfo" type="na:DpBackupPathInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpBackupTransferInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpBackupTransferInfo" type="na:DpBackupTransferInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpBackupVersionInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpBackupVersionInfo" type="na:DpBackupVersionInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpDatasetLagInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpDatasetLagInfo" type="na:DpDatasetLagInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpJobData">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpJobData" type="na:DpJobData"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpJobInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpJobInfo" type="na:DpJobInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpJobProgressEventInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpJobProgressEventInfo" type="na:DpJobProgressEventInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpOssvDirectoryInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpOssvDirectoryInfo" type="na:DpOssvDirectoryInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpOssvDirectoryName">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpOssvDirectoryName" type="na:DpOssvDirectoryName"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpOssvDirectoryRootInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpOssvDirectoryRootInfo" type="na:DpOssvDirectoryRootInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpPathInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpPathInfo" type="na:DpPathInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpPolicyConnectionInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpPolicyConnectionInfo" type="na:DpPolicyConnectionInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpPolicyInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpPolicyInfo" type="na:DpPolicyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpPolicyNodeInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpPolicyNodeInfo" type="na:DpPolicyNodeInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpRecoverMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpRecoverMemberInfo" type="na:DpRecoverMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpRelationshipInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpRelationshipInfo" type="na:DpRelationshipInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpRelationshipLagInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpRelationshipLagInfo" type="na:DpRelationshipLagInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDpScheduledJob">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DpScheduledJob" type="na:DpScheduledJob"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDrStateStatusCount">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DrStateStatusCount" type="na:DrStateStatusCount"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDrStatusProblem">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DrStatusProblem" type="na:DrStatusProblem"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDryRunResult">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DryRunResult" type="na:DryRunResult"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfDynamicData">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="DynamicData" type="na:DynamicData"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEmailAddress">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EmailAddress" type="na:EmailAddress"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEnvironmentVariableInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EnvironmentVariableInfo" type="na:EnvironmentVariableInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventActionInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventActionInfo" type="na:EventActionInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventApplicationType">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventApplicationType" type="na:EventApplicationType"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventClassInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventClassInfo" type="na:EventClassInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventClassObject">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventClassObject" type="na:EventClassObject"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventIdType">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventIdType" type="na:EventIdType"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventInfo" type="na:EventInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventNameInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventNameInfo" type="na:EventNameInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfEventTypeFilter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="EventTypeFilter" type="na:EventTypeFilter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfFeature">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Feature" type="na:Feature"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGraphInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="GraphInfo" type="na:GraphInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGraphLineInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="GraphLineInfo" type="na:GraphLineInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGraphLineValueInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="GraphLineValueInfo" type="na:GraphLineValueInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGroup">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Group" type="na:Group"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGroupInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="GroupInfo" type="na:GroupInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGroupMemberAttribute">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="GroupMemberAttribute" type="na:GroupMemberAttribute"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfGroupMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="GroupMemberInfo" type="na:GroupMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostClientStats">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostClientStats" type="na:HostClientStats"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostDomainuserInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostDomainuserInfo" type="na:HostDomainuserInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostInfo" type="na:HostInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostRoleId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostRoleId" type="na:HostRoleId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostRoleInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostRoleInfo" type="na:HostRoleInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostRoleName">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostRoleName" type="na:HostRoleName"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostType">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostType" type="na:HostType"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostUserInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostUserInfo" type="na:HostUserInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostUsergroupId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostUsergroupId" type="na:HostUsergroupId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostUsergroupInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostUsergroupInfo" type="na:HostUsergroupInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostUsergroupName">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostUsergroupName" type="na:HostUsergroupName"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHostUsergroupNameOrId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HostUsergroupNameOrId" type="na:HostUsergroupNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfHourlyInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="HourlyInfo" type="na:HourlyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfIfcInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="IfcInfo" type="na:IfcInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfInvalidCounterInstance">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="InvalidCounterInstance" type="na:InvalidCounterInstance"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfIpAddress">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="IpAddress" type="na:IpAddress"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfIpBindingInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="IpBindingInfo" type="na:IpBindingInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfJobInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="JobInfo" type="na:JobInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfJobType">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="JobType" type="na:JobType"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfKeyValuePair">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="KeyValuePair" type="na:KeyValuePair"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfLicense">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="License" type="na:License"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfLunIgroupInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="LunIgroupInfo" type="na:LunIgroupInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfLunInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="LunInfo" type="na:LunInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfLunMappingInitiator">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="LunMappingInitiator" type="na:LunMappingInitiator"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMetric">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Metric" type="na:Metric"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMigrationDryRunResult">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="MigrationDryRunResult" type="na:MigrationDryRunResult"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMigrationJobInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="MigrationJobInfo" type="na:MigrationJobInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMissingMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="MissingMemberInfo" type="na:MissingMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMonitorName">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="MonitorName" type="na:MonitorName"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMonth">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Month" type="na:Month"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMonthlyInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="MonthlyInfo" type="na:MonthlyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfMonthlySubscheduleInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="MonthlySubscheduleInfo" type="na:MonthlySubscheduleInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfNetifIpInterfaceInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="NetifIpInterfaceInfo" type="na:NetifIpInterfaceInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfNfsExportHost">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="NfsExportHost" type="na:NfsExportHost"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfNfsSecurityFlavor">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="NfsSecurityFlavor" type="na:NfsSecurityFlavor"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfObjNameOrId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ObjNameOrId" type="na:ObjNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfObjStatus">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ObjStatus" type="na:ObjStatus"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfObjStatusInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ObjStatusInfo" type="na:ObjStatusInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfObjectInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ObjectInfo" type="na:ObjectInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfObjectNameOrId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ObjectNameOrId" type="na:ObjectNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfOperationalStatus">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="OperationalStatus" type="na:OperationalStatus"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfOssvApplicationInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="OssvApplicationInfo" type="na:OssvApplicationInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfOssvApplicationRestoreDestinationInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="OssvApplicationRestoreDestinationInfo" type="na:OssvApplicationRestoreDestinationInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfOverwriteResult">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="OverwriteResult" type="na:OverwriteResult"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfParentDataset">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ParentDataset" type="na:ParentDataset"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfParentGroup">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ParentGroup" type="na:ParentGroup"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfParentObject">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ParentObject" type="na:ParentObject"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfParentResourcepool">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ParentResourcepool" type="na:ParentResourcepool"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfAssocObjType">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfAssocObjType" type="na:PerfAssocObjType"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfChart">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfChart" type="na:PerfChart"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfCounter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfCounter" type="na:PerfCounter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfCounterData">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfCounterData" type="na:PerfCounterData"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfCounterGroup">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfCounterGroup" type="na:PerfCounterGroup"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfDataSource">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfDataSource" type="na:PerfDataSource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfDependentCounterInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfDependentCounterInfo" type="na:PerfDependentCounterInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfDiagCategory">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfDiagCategory" type="na:PerfDiagCategory"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfHealthCheck">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfHealthCheck" type="na:PerfHealthCheck"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfInstance">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfInstance" type="na:PerfInstance"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfInstanceCounterData">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfInstanceCounterData" type="na:PerfInstanceCounterData"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfLabel">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfLabel" type="na:PerfLabel"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfLine">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfLine" type="na:PerfLine"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfMissingHostObjectCounter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfMissingHostObjectCounter" type="na:PerfMissingHostObjectCounter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfObject">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfObject" type="na:PerfObject"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfObjectCounter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfObjectCounter" type="na:PerfObjectCounter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfObjectCounterInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfObjectCounterInfo" type="na:PerfObjectCounterInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfPurgedHostObjectCounter">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfPurgedHostObjectCounter" type="na:PerfPurgedHostObjectCounter"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfPurgedObjectCountersDetails">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfPurgedObjectCountersDetails" type="na:PerfPurgedObjectCountersDetails"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfReport">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfReport" type="na:PerfReport"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfStatusError">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfStatusError" type="na:PerfStatusError"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfThreshold">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfThreshold" type="na:PerfThreshold"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPerfView">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="PerfView" type="na:PerfView"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfPlugin">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Plugin" type="na:Plugin"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfProtectionStatusJobDetail">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ProtectionStatusJobDetail" type="na:ProtectionStatusJobDetail"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfProtectionStatusProblem">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ProtectionStatusProblem" type="na:ProtectionStatusProblem"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfProtocol">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Protocol" type="na:Protocol"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfProvisionMemberComment">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ProvisionMemberComment" type="na:ProvisionMemberComment"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfProvisioningPolicyInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ProvisioningPolicyInfo" type="na:ProvisioningPolicyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfQtreeInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="QtreeInfo" type="na:QtreeInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfRbacAdminOrUsergroup">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="RbacAdminOrUsergroup" type="na:RbacAdminOrUsergroup"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfRbacOperation">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="RbacOperation" type="na:RbacOperation"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfRbacResourceOperation">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="RbacResourceOperation" type="na:RbacResourceOperation"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfRbacRoleResource">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="RbacRoleResource" type="na:RbacRoleResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfRelationshipState">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="RelationshipState" type="na:RelationshipState"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfReplaceResult">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ReplaceResult" type="na:ReplaceResult"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfReportInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ReportInfo" type="na:ReportInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfReportOutputFormat">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ReportOutputFormat" type="na:ReportOutputFormat"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfReportOutputInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ReportOutputInfo" type="na:ReportOutputInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfReportScheduleContentInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ReportScheduleContentInfo" type="na:ReportScheduleContentInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfResourcePropertyCondition">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ResourcePropertyCondition" type="na:ResourcePropertyCondition"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfResourcePropertyValues">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ResourcePropertyValues" type="na:ResourcePropertyValues"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfResourcepoolInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ResourcepoolInfo" type="na:ResourcepoolInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfResourcepoolMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ResourcepoolMemberInfo" type="na:ResourcepoolMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfResourcepoolNameOrId">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ResourcepoolNameOrId" type="na:ResourcepoolNameOrId"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfResultDetail">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ResultDetail" type="na:ResultDetail"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfRoleAttributesIdentifier">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="RoleAttributesIdentifier" type="na:RoleAttributesIdentifier"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfScheduleAssignee">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ScheduleAssignee" type="na:ScheduleAssignee"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfScheduleContentInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ScheduleContentInfo" type="na:ScheduleContentInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfScheduleIdInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ScheduleIdInfo" type="na:ScheduleIdInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfServiceStatus">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ServiceStatus" type="na:ServiceStatus"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSnapshot">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="Snapshot" type="na:Snapshot"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSnapshotDependency">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="SnapshotDependency" type="na:SnapshotDependency"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSnapshotInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="SnapshotInfo" type="na:SnapshotInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSnapshotMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="SnapshotMemberInfo" type="na:SnapshotMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSpaceCondition">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="SpaceCondition" type="na:SpaceCondition"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSpaceManagementResultInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="SpaceManagementResultInfo" type="na:SpaceManagementResultInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfSpaceStatusResult">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="SpaceStatusResult" type="na:SpaceStatusResult"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfStorageServiceDatasetInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="StorageServiceDatasetInfo" type="na:StorageServiceDatasetInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfStorageServiceInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="StorageServiceInfo" type="na:StorageServiceInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfStorageServiceNodeAttributes">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="StorageServiceNodeAttributes" type="na:StorageServiceNodeAttributes"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfStorageServiceNodeInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="StorageServiceNodeInfo" type="na:StorageServiceNodeInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfStorageSetInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="StorageSetInfo" type="na:StorageSetInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfString">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="String" type="xsd:string"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfTargetInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="TargetInfo" type="na:TargetInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThresholdInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThresholdInfo" type="na:ThresholdInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThresholdInfo2">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThresholdInfo2" type="na:ThresholdInfo2"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThresholdTemplate">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThresholdTemplate" type="na:ThresholdTemplate"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThresholdTemplateInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThresholdTemplateInfo" type="na:ThresholdTemplateInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThrottleAssignee">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThrottleAssignee" type="na:ThrottleAssignee"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThrottleContent">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThrottleContent" type="na:ThrottleContent"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfThrottleItemInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="ThrottleItemInfo" type="na:ThrottleItemInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfTimeRange">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="TimeRange" type="na:TimeRange"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfTimezoneInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="TimezoneInfo" type="na:TimezoneInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfTrapDestination">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="TrapDestination" type="na:TrapDestination"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfUserReportInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="UserReportInfo" type="na:UserReportInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfVersionMemberInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="VersionMemberInfo" type="na:VersionMemberInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfVfilerNetworkResource">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="VfilerNetworkResource" type="na:VfilerNetworkResource"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfVfilerTemplateInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="VfilerTemplateInfo" type="na:VfilerTemplateInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfVolumeAggregatePair">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="VolumeAggregatePair" type="na:VolumeAggregatePair"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfVolumeInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="VolumeInfo" type="na:VolumeInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfVolumeOption">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="VolumeOption" type="na:VolumeOption"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfWeeklyInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="WeeklyInfo" type="na:WeeklyInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfWeeklySubscheduleInfo">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="WeeklySubscheduleInfo" type="na:WeeklySubscheduleInfo"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="FaultDetail">
                <xsd:annotation>
                    <xsd:documentation>Faults will use this type to provide access to error information and reason.</xsd:documentation>
                </xsd:annotation>
                <xsd:sequence>
                    <xsd:element name="OperationError" type="na:OperationError"/>
                    <xsd:element name="Reason" type="xsd:string"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="OperationError">
                <xsd:annotation>
                    <xsd:documentation>OperationError is returned as part of FaultDetail, and used for documenting possible errors returned from an operation</xsd:documentation>
                </xsd:annotation>
                <xsd:sequence>
                    <xsd:element name="Code" type="xsd:unsignedInt"/>
                    <xsd:element name="Name" type="xsd:string"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="ArrayOfOperationError">
                <xsd:sequence>
                    <xsd:element maxOccurs="unbounded" name="OperationError" type="na:OperationError"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:complexType name="OperationDocumentation">
                <xsd:annotation>
                    <xsd:documentation>The OperationDocumentation type is used to document operations.</xsd:documentation>
                </xsd:annotation>
                <xsd:sequence>
                    <xsd:element minOccurs="0" name="Description" type="xsd:string"/>
                    <xsd:element minOccurs="0" name="Category" type="xsd:string"/>
                    <xsd:element minOccurs="0" name="Status" type="na:OperationStatus"/>
                    <xsd:element minOccurs="0" name="OperationErrors" type="na:ArrayOfOperationError"/>
                </xsd:sequence>
            </xsd:complexType>
            <xsd:simpleType name="OperationStatus">
                <xsd:restriction base="xsd:string">
                    <xsd:enumeration value="debug"/>
                    <xsd:enumeration value="internal"/>
                    <xsd:enumeration value="proposed"/>
                    <xsd:enumeration value="supported"/>
                    <xsd:enumeration value="unsupported"/>
                </xsd:restriction>
            </xsd:simpleType>
            <xsd:complexType name="CategoryDocumentation">
                <xsd:annotation>
                    <xsd:documentation>The CategoryDocumentation type is used to document categories.  Categories are groups of related operations.</xsd:documentation>
                </xsd:annotation>
                <xsd:sequence>
                    <xsd:element name="Name" type="xsd:string"/>
                    <xsd:element minOccurs="0" name="Synopsis" type="xsd:string"/>
                    <xsd:element minOccurs="0" name="Discussion" type="xsd:string"/>
                </xsd:sequence>
            </xsd:complexType>
        </xsd:schema>
    </types>
    <message name="AggregateListInfoIterEndRequest">
        <part element="na:AggregateListInfoIterEnd" name="parameters"/>
    </message>
    <message name="AggregateListInfoIterEndResponse">
        <part element="na:AggregateListInfoIterEndResult" name="results"/>
    </message>
    <message name="AggregateListInfoIterNextRequest">
        <part element="na:AggregateListInfoIterNext" name="parameters"/>
    </message>
    <message name="AggregateListInfoIterNextResponse">
        <part element="na:AggregateListInfoIterNextResult" name="results"/>
    </message>
    <message name="AggregateListInfoIterStartRequest">
        <part element="na:AggregateListInfoIterStart" name="parameters"/>
    </message>
    <message name="AggregateListInfoIterStartResponse">
        <part element="na:AggregateListInfoIterStartResult" name="results"/>
    </message>
    <message name="AggregateModifyRequest">
        <part element="na:AggregateModify" name="parameters"/>
    </message>
    <message name="AggregateModifyResponse">
        <part element="na:AggregateModifyResult" name="results"/>
    </message>
    <message name="AggregateSpaceManagementAddOperationRequest">
        <part element="na:AggregateSpaceManagementAddOperation" name="parameters"/>
    </message>
    <message name="AggregateSpaceManagementAddOperationResponse">
        <part element="na:AggregateSpaceManagementAddOperationResult" name="results"/>
    </message>
    <message name="AggregateSpaceManagementBeginRequest">
        <part element="na:AggregateSpaceManagementBegin" name="parameters"/>
    </message>
    <message name="AggregateSpaceManagementBeginResponse">
        <part element="na:AggregateSpaceManagementBeginResult" name="results"/>
    </message>
    <message name="AggregateSpaceManagementCommitRequest">
        <part element="na:AggregateSpaceManagementCommit" name="parameters"/>
    </message>
    <message name="AggregateSpaceManagementCommitResponse">
        <part element="na:AggregateSpaceManagementCommitResult" name="results"/>
    </message>
    <message name="AggregateSpaceManagementRemoveOperationRequest">
        <part element="na:AggregateSpaceManagementRemoveOperation" name="parameters"/>
    </message>
    <message name="AggregateSpaceManagementRemoveOperationResponse">
        <part element="na:AggregateSpaceManagementRemoveOperationResult" name="results"/>
    </message>
    <message name="AggregateSpaceManagementRollbackRequest">
        <part element="na:AggregateSpaceManagementRollback" name="parameters"/>
    </message>
    <message name="AggregateSpaceManagementRollbackResponse">
        <part element="na:AggregateSpaceManagementRollbackResult" name="results"/>
    </message>
    <message name="AlarmCreateRequest">
        <part element="na:AlarmCreate" name="parameters"/>
    </message>
    <message name="AlarmCreateResponse">
        <part element="na:AlarmCreateResult" name="results"/>
    </message>
    <message name="AlarmDestroyRequest">
        <part element="na:AlarmDestroy" name="parameters"/>
    </message>
    <message name="AlarmDestroyResponse">
        <part element="na:AlarmDestroyResult" name="results"/>
    </message>
    <message name="AlarmGetDefaultsRequest">
        <part element="na:AlarmGetDefaults" name="parameters"/>
    </message>
    <message name="AlarmGetDefaultsResponse">
        <part element="na:AlarmGetDefaultsResult" name="results"/>
    </message>
    <message name="AlarmListInfoIterEndRequest">
        <part element="na:AlarmListInfoIterEnd" name="parameters"/>
    </message>
    <message name="AlarmListInfoIterEndResponse">
        <part element="na:AlarmListInfoIterEndResult" name="results"/>
    </message>
    <message name="AlarmListInfoIterNextRequest">
        <part element="na:AlarmListInfoIterNext" name="parameters"/>
    </message>
    <message name="AlarmListInfoIterNextResponse">
        <part element="na:AlarmListInfoIterNextResult" name="results"/>
    </message>
    <message name="AlarmListInfoIterStartRequest">
        <part element="na:AlarmListInfoIterStart" name="parameters"/>
    </message>
    <message name="AlarmListInfoIterStartResponse">
        <part element="na:AlarmListInfoIterStartResult" name="results"/>
    </message>
    <message name="AlarmModifyRequest">
        <part element="na:AlarmModify" name="parameters"/>
    </message>
    <message name="AlarmModifyResponse">
        <part element="na:AlarmModifyResult" name="results"/>
    </message>
    <message name="AlarmTestRequest">
        <part element="na:AlarmTest" name="parameters"/>
    </message>
    <message name="AlarmTestResponse">
        <part element="na:AlarmTestResult" name="results"/>
    </message>
    <message name="ApiProxyRequest">
        <part element="na:ApiProxy" name="parameters"/>
    </message>
    <message name="ApiProxyResponse">
        <part element="na:ApiProxyResult" name="results"/>
    </message>
    <message name="AuditLogAddEntryRequest">
        <part element="na:AuditLogAddEntry" name="parameters"/>
    </message>
    <message name="AuditLogAddEntryResponse">
        <part element="na:AuditLogAddEntryResult" name="results"/>
    </message>
    <message name="CifsDomainListInfoIterEndRequest">
        <part element="na:CifsDomainListInfoIterEnd" name="parameters"/>
    </message>
    <message name="CifsDomainListInfoIterEndResponse">
        <part element="na:CifsDomainListInfoIterEndResult" name="results"/>
    </message>
    <message name="CifsDomainListInfoIterNextRequest">
        <part element="na:CifsDomainListInfoIterNext" name="parameters"/>
    </message>
    <message name="CifsDomainListInfoIterNextResponse">
        <part element="na:CifsDomainListInfoIterNextResult" name="results"/>
    </message>
    <message name="CifsDomainListInfoIterStartRequest">
        <part element="na:CifsDomainListInfoIterStart" name="parameters"/>
    </message>
    <message name="CifsDomainListInfoIterStartResponse">
        <part element="na:CifsDomainListInfoIterStartResult" name="results"/>
    </message>
    <message name="ClientRegistryDestroyRequest">
        <part element="na:ClientRegistryDestroy" name="parameters"/>
    </message>
    <message name="ClientRegistryDestroyResponse">
        <part element="na:ClientRegistryDestroyResult" name="results"/>
    </message>
    <message name="ClientRegistryGetRequest">
        <part element="na:ClientRegistryGet" name="parameters"/>
    </message>
    <message name="ClientRegistryGetResponse">
        <part element="na:ClientRegistryGetResult" name="results"/>
    </message>
    <message name="ClientRegistrySetRequest">
        <part element="na:ClientRegistrySet" name="parameters"/>
    </message>
    <message name="ClientRegistrySetResponse">
        <part element="na:ClientRegistrySetResult" name="results"/>
    </message>
    <message name="CommentFieldCreateRequest">
        <part element="na:CommentFieldCreate" name="parameters"/>
    </message>
    <message name="CommentFieldCreateResponse">
        <part element="na:CommentFieldCreateResult" name="results"/>
    </message>
    <message name="CommentFieldDestroyRequest">
        <part element="na:CommentFieldDestroy" name="parameters"/>
    </message>
    <message name="CommentFieldDestroyResponse">
        <part element="na:CommentFieldDestroyResult" name="results"/>
    </message>
    <message name="CommentFieldListInfoIterEndRequest">
        <part element="na:CommentFieldListInfoIterEnd" name="parameters"/>
    </message>
    <message name="CommentFieldListInfoIterEndResponse">
        <part element="na:CommentFieldListInfoIterEndResult" name="results"/>
    </message>
    <message name="CommentFieldListInfoIterNextRequest">
        <part element="na:CommentFieldListInfoIterNext" name="parameters"/>
    </message>
    <message name="CommentFieldListInfoIterNextResponse">
        <part element="na:CommentFieldListInfoIterNextResult" name="results"/>
    </message>
    <message name="CommentFieldListInfoIterStartRequest">
        <part element="na:CommentFieldListInfoIterStart" name="parameters"/>
    </message>
    <message name="CommentFieldListInfoIterStartResponse">
        <part element="na:CommentFieldListInfoIterStartResult" name="results"/>
    </message>
    <message name="CommentFieldModifyRequest">
        <part element="na:CommentFieldModify" name="parameters"/>
    </message>
    <message name="CommentFieldModifyResponse">
        <part element="na:CommentFieldModifyResult" name="results"/>
    </message>
    <message name="CommentFieldValuesListInfoIterEndRequest">
        <part element="na:CommentFieldValuesListInfoIterEnd" name="parameters"/>
    </message>
    <message name="CommentFieldValuesListInfoIterEndResponse">
        <part element="na:CommentFieldValuesListInfoIterEndResult" name="results"/>
    </message>
    <message name="CommentFieldValuesListInfoIterNextRequest">
        <part element="na:CommentFieldValuesListInfoIterNext" name="parameters"/>
    </message>
    <message name="CommentFieldValuesListInfoIterNextResponse">
        <part element="na:CommentFieldValuesListInfoIterNextResult" name="results"/>
    </message>
    <message name="CommentFieldValuesListInfoIterStartRequest">
        <part element="na:CommentFieldValuesListInfoIterStart" name="parameters"/>
    </message>
    <message name="CommentFieldValuesListInfoIterStartResponse">
        <part element="na:CommentFieldValuesListInfoIterStartResult" name="results"/>
    </message>
    <message name="CommentSetObjectValueRequest">
        <part element="na:CommentSetObjectValue" name="parameters"/>
    </message>
    <message name="CommentSetObjectValueResponse">
        <part element="na:CommentSetObjectValueResult" name="results"/>
    </message>
    <message name="DatasetAddMemberRequest">
        <part element="na:DatasetAddMember" name="parameters"/>
    </message>
    <message name="DatasetAddMemberResponse">
        <part element="na:DatasetAddMemberResult" name="results"/>
    </message>
    <message name="DatasetAddMemberByDynamicReferenceRequest">
        <part element="na:DatasetAddMemberByDynamicReference" name="parameters"/>
    </message>
    <message name="DatasetAddMemberByDynamicReferenceResponse">
        <part element="na:DatasetAddMemberByDynamicReferenceResult" name="results"/>
    </message>
    <message name="DatasetAddResourcepoolRequest">
        <part element="na:DatasetAddResourcepool" name="parameters"/>
    </message>
    <message name="DatasetAddResourcepoolResponse">
        <part element="na:DatasetAddResourcepoolResult" name="results"/>
    </message>
    <message name="DatasetBeginFailoverRequest">
        <part element="na:DatasetBeginFailover" name="parameters"/>
    </message>
    <message name="DatasetBeginFailoverResponse">
        <part element="na:DatasetBeginFailoverResult" name="results"/>
    </message>
    <message name="DatasetBeginFailoverScriptTestRequest">
        <part element="na:DatasetBeginFailoverScriptTest" name="parameters"/>
    </message>
    <message name="DatasetBeginFailoverScriptTestResponse">
        <part element="na:DatasetBeginFailoverScriptTestResult" name="results"/>
    </message>
    <message name="DatasetChangeDrStateRequest">
        <part element="na:DatasetChangeDrState" name="parameters"/>
    </message>
    <message name="DatasetChangeDrStateResponse">
        <part element="na:DatasetChangeDrStateResult" name="results"/>
    </message>
    <message name="DatasetConformBeginRequest">
        <part element="na:DatasetConformBegin" name="parameters"/>
    </message>
    <message name="DatasetConformBeginResponse">
        <part element="na:DatasetConformBeginResult" name="results"/>
    </message>
    <message name="DatasetCreateRequest">
        <part element="na:DatasetCreate" name="parameters"/>
    </message>
    <message name="DatasetCreateResponse">
        <part element="na:DatasetCreateResult" name="results"/>
    </message>
    <message name="DatasetDestroyRequest">
        <part element="na:DatasetDestroy" name="parameters"/>
    </message>
    <message name="DatasetDestroyResponse">
        <part element="na:DatasetDestroyResult" name="results"/>
    </message>
    <message name="DatasetDynamicReferenceListInfoIterEndRequest">
        <part element="na:DatasetDynamicReferenceListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DatasetDynamicReferenceListInfoIterEndResponse">
        <part element="na:DatasetDynamicReferenceListInfoIterEndResult" name="results"/>
    </message>
    <message name="DatasetDynamicReferenceListInfoIterNextRequest">
        <part element="na:DatasetDynamicReferenceListInfoIterNext" name="parameters"/>
    </message>
    <message name="DatasetDynamicReferenceListInfoIterNextResponse">
        <part element="na:DatasetDynamicReferenceListInfoIterNextResult" name="results"/>
    </message>
    <message name="DatasetDynamicReferenceListInfoIterStartRequest">
        <part element="na:DatasetDynamicReferenceListInfoIterStart" name="parameters"/>
    </message>
    <message name="DatasetDynamicReferenceListInfoIterStartResponse">
        <part element="na:DatasetDynamicReferenceListInfoIterStartResult" name="results"/>
    </message>
    <message name="DatasetEditBeginRequest">
        <part element="na:DatasetEditBegin" name="parameters"/>
    </message>
    <message name="DatasetEditBeginResponse">
        <part element="na:DatasetEditBeginResult" name="results"/>
    </message>
    <message name="DatasetEditCommitRequest">
        <part element="na:DatasetEditCommit" name="parameters"/>
    </message>
    <message name="DatasetEditCommitResponse">
        <part element="na:DatasetEditCommitResult" name="results"/>
    </message>
    <message name="DatasetEditRollbackRequest">
        <part element="na:DatasetEditRollback" name="parameters"/>
    </message>
    <message name="DatasetEditRollbackResponse">
        <part element="na:DatasetEditRollbackResult" name="results"/>
    </message>
    <message name="DatasetListInfoIterEndRequest">
        <part element="na:DatasetListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DatasetListInfoIterEndResponse">
        <part element="na:DatasetListInfoIterEndResult" name="results"/>
    </message>
    <message name="DatasetListInfoIterNextRequest">
        <part element="na:DatasetListInfoIterNext" name="parameters"/>
    </message>
    <message name="DatasetListInfoIterNextResponse">
        <part element="na:DatasetListInfoIterNextResult" name="results"/>
    </message>
    <message name="DatasetListInfoIterStartRequest">
        <part element="na:DatasetListInfoIterStart" name="parameters"/>
    </message>
    <message name="DatasetListInfoIterStartResponse">
        <part element="na:DatasetListInfoIterStartResult" name="results"/>
    </message>
    <message name="DatasetMemberDedupeAbortRequest">
        <part element="na:DatasetMemberDedupeAbort" name="parameters"/>
    </message>
    <message name="DatasetMemberDedupeAbortResponse">
        <part element="na:DatasetMemberDedupeAbortResult" name="results"/>
    </message>
    <message name="DatasetMemberDedupeStartRequest">
        <part element="na:DatasetMemberDedupeStart" name="parameters"/>
    </message>
    <message name="DatasetMemberDedupeStartResponse">
        <part element="na:DatasetMemberDedupeStartResult" name="results"/>
    </message>
    <message name="DatasetMemberDeleteSnapshotsRequest">
        <part element="na:DatasetMemberDeleteSnapshots" name="parameters"/>
    </message>
    <message name="DatasetMemberDeleteSnapshotsResponse">
        <part element="na:DatasetMemberDeleteSnapshotsResult" name="results"/>
    </message>
    <message name="DatasetMemberListInfoIterEndRequest">
        <part element="na:DatasetMemberListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DatasetMemberListInfoIterEndResponse">
        <part element="na:DatasetMemberListInfoIterEndResult" name="results"/>
    </message>
    <message name="DatasetMemberListInfoIterNextRequest">
        <part element="na:DatasetMemberListInfoIterNext" name="parameters"/>
    </message>
    <message name="DatasetMemberListInfoIterNextResponse">
        <part element="na:DatasetMemberListInfoIterNextResult" name="results"/>
    </message>
    <message name="DatasetMemberListInfoIterStartRequest">
        <part element="na:DatasetMemberListInfoIterStart" name="parameters"/>
    </message>
    <message name="DatasetMemberListInfoIterStartResponse">
        <part element="na:DatasetMemberListInfoIterStartResult" name="results"/>
    </message>
    <message name="DatasetMemberUndedupeStartRequest">
        <part element="na:DatasetMemberUndedupeStart" name="parameters"/>
    </message>
    <message name="DatasetMemberUndedupeStartResponse">
        <part element="na:DatasetMemberUndedupeStartResult" name="results"/>
    </message>
    <message name="DatasetMissingMemberListInfoIterEndRequest">
        <part element="na:DatasetMissingMemberListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DatasetMissingMemberListInfoIterEndResponse">
        <part element="na:DatasetMissingMemberListInfoIterEndResult" name="results"/>
    </message>
    <message name="DatasetMissingMemberListInfoIterNextRequest">
        <part element="na:DatasetMissingMemberListInfoIterNext" name="parameters"/>
    </message>
    <message name="DatasetMissingMemberListInfoIterNextResponse">
        <part element="na:DatasetMissingMemberListInfoIterNextResult" name="results"/>
    </message>
    <message name="DatasetMissingMemberListInfoIterStartRequest">
        <part element="na:DatasetMissingMemberListInfoIterStart" name="parameters"/>
    </message>
    <message name="DatasetMissingMemberListInfoIterStartResponse">
        <part element="na:DatasetMissingMemberListInfoIterStartResult" name="results"/>
    </message>
    <message name="DatasetModifyRequest">
        <part element="na:DatasetModify" name="parameters"/>
    </message>
    <message name="DatasetModifyResponse">
        <part element="na:DatasetModifyResult" name="results"/>
    </message>
    <message name="DatasetModifyNodeRequest">
        <part element="na:DatasetModifyNode" name="parameters"/>
    </message>
    <message name="DatasetModifyNodeResponse">
        <part element="na:DatasetModifyNodeResult" name="results"/>
    </message>
    <message name="DatasetProvisionMemberRequest">
        <part element="na:DatasetProvisionMember" name="parameters"/>
    </message>
    <message name="DatasetProvisionMemberResponse">
        <part element="na:DatasetProvisionMemberResult" name="results"/>
    </message>
    <message name="DatasetRemoveMemberRequest">
        <part element="na:DatasetRemoveMember" name="parameters"/>
    </message>
    <message name="DatasetRemoveMemberResponse">
        <part element="na:DatasetRemoveMemberResult" name="results"/>
    </message>
    <message name="DatasetRemoveMemberByDynamicReferenceRequest">
        <part element="na:DatasetRemoveMemberByDynamicReference" name="parameters"/>
    </message>
    <message name="DatasetRemoveMemberByDynamicReferenceResponse">
        <part element="na:DatasetRemoveMemberByDynamicReferenceResult" name="results"/>
    </message>
    <message name="DatasetRemoveResourcepoolRequest">
        <part element="na:DatasetRemoveResourcepool" name="parameters"/>
    </message>
    <message name="DatasetRemoveResourcepoolResponse">
        <part element="na:DatasetRemoveResourcepoolResult" name="results"/>
    </message>
    <message name="DatasetReplacePrimaryMembersRequest">
        <part element="na:DatasetReplacePrimaryMembers" name="parameters"/>
    </message>
    <message name="DatasetReplacePrimaryMembersResponse">
        <part element="na:DatasetReplacePrimaryMembersResult" name="results"/>
    </message>
    <message name="DatasetResizeMemberRequest">
        <part element="na:DatasetResizeMember" name="parameters"/>
    </message>
    <message name="DatasetResizeMemberResponse">
        <part element="na:DatasetResizeMemberResult" name="results"/>
    </message>
    <message name="DatasetSetRequest">
        <part element="na:DatasetSet" name="parameters"/>
    </message>
    <message name="DatasetSetResponse">
        <part element="na:DatasetSetResult" name="results"/>
    </message>
    <message name="DatasetSetStoragesetRequest">
        <part element="na:DatasetSetStorageset" name="parameters"/>
    </message>
    <message name="DatasetSetStoragesetResponse">
        <part element="na:DatasetSetStoragesetResult" name="results"/>
    </message>
    <message name="DatasetUpdateDrStatusRequest">
        <part element="na:DatasetUpdateDrStatus" name="parameters"/>
    </message>
    <message name="DatasetUpdateDrStatusResponse">
        <part element="na:DatasetUpdateDrStatusResult" name="results"/>
    </message>
    <message name="DatasetUpdateProtectionStatusRequest">
        <part element="na:DatasetUpdateProtectionStatus" name="parameters"/>
    </message>
    <message name="DatasetUpdateProtectionStatusResponse">
        <part element="na:DatasetUpdateProtectionStatusResult" name="results"/>
    </message>
    <message name="DfmAboutRequest">
        <part element="na:DfmAbout" name="parameters"/>
    </message>
    <message name="DfmAboutResponse">
        <part element="na:DfmAboutResult" name="results"/>
    </message>
    <message name="DfmGetApiStatisticsRequest">
        <part element="na:DfmGetApiStatistics" name="parameters"/>
    </message>
    <message name="DfmGetApiStatisticsResponse">
        <part element="na:DfmGetApiStatisticsResult" name="results"/>
    </message>
    <message name="DfmGetResourcePropertyValuesRequest">
        <part element="na:DfmGetResourcePropertyValues" name="parameters"/>
    </message>
    <message name="DfmGetResourcePropertyValuesResponse">
        <part element="na:DfmGetResourcePropertyValuesResult" name="results"/>
    </message>
    <message name="DfmObjectRefreshRequest">
        <part element="na:DfmObjectRefresh" name="parameters"/>
    </message>
    <message name="DfmObjectRefreshResponse">
        <part element="na:DfmObjectRefreshResult" name="results"/>
    </message>
    <message name="DfmObjectsGetStatusRequest">
        <part element="na:DfmObjectsGetStatus" name="parameters"/>
    </message>
    <message name="DfmObjectsGetStatusResponse">
        <part element="na:DfmObjectsGetStatusResult" name="results"/>
    </message>
    <message name="DfmRelatedObjectsListInfoRequest">
        <part element="na:DfmRelatedObjectsListInfo" name="parameters"/>
    </message>
    <message name="DfmRelatedObjectsListInfoResponse">
        <part element="na:DfmRelatedObjectsListInfoResult" name="results"/>
    </message>
    <message name="DfmScheduleContentGetRequest">
        <part element="na:DfmScheduleContentGet" name="parameters"/>
    </message>
    <message name="DfmScheduleContentGetResponse">
        <part element="na:DfmScheduleContentGetResult" name="results"/>
    </message>
    <message name="DfmScheduleCreateRequest">
        <part element="na:DfmScheduleCreate" name="parameters"/>
    </message>
    <message name="DfmScheduleCreateResponse">
        <part element="na:DfmScheduleCreateResult" name="results"/>
    </message>
    <message name="DfmScheduleDailyAddRequest">
        <part element="na:DfmScheduleDailyAdd" name="parameters"/>
    </message>
    <message name="DfmScheduleDailyAddResponse">
        <part element="na:DfmScheduleDailyAddResult" name="results"/>
    </message>
    <message name="DfmScheduleDailyDeleteRequest">
        <part element="na:DfmScheduleDailyDelete" name="parameters"/>
    </message>
    <message name="DfmScheduleDailyDeleteResponse">
        <part element="na:DfmScheduleDailyDeleteResult" name="results"/>
    </message>
    <message name="DfmScheduleDailyModifyRequest">
        <part element="na:DfmScheduleDailyModify" name="parameters"/>
    </message>
    <message name="DfmScheduleDailyModifyResponse">
        <part element="na:DfmScheduleDailyModifyResult" name="results"/>
    </message>
    <message name="DfmScheduleDependencyRequest">
        <part element="na:DfmScheduleDependency" name="parameters"/>
    </message>
    <message name="DfmScheduleDependencyResponse">
        <part element="na:DfmScheduleDependencyResult" name="results"/>
    </message>
    <message name="DfmScheduleDestroyRequest">
        <part element="na:DfmScheduleDestroy" name="parameters"/>
    </message>
    <message name="DfmScheduleDestroyResponse">
        <part element="na:DfmScheduleDestroyResult" name="results"/>
    </message>
    <message name="DfmScheduleHourlyAddRequest">
        <part element="na:DfmScheduleHourlyAdd" name="parameters"/>
    </message>
    <message name="DfmScheduleHourlyAddResponse">
        <part element="na:DfmScheduleHourlyAddResult" name="results"/>
    </message>
    <message name="DfmScheduleHourlyDeleteRequest">
        <part element="na:DfmScheduleHourlyDelete" name="parameters"/>
    </message>
    <message name="DfmScheduleHourlyDeleteResponse">
        <part element="na:DfmScheduleHourlyDeleteResult" name="results"/>
    </message>
    <message name="DfmScheduleHourlyModifyRequest">
        <part element="na:DfmScheduleHourlyModify" name="parameters"/>
    </message>
    <message name="DfmScheduleHourlyModifyResponse">
        <part element="na:DfmScheduleHourlyModifyResult" name="results"/>
    </message>
    <message name="DfmScheduleListRequest">
        <part element="na:DfmScheduleList" name="parameters"/>
    </message>
    <message name="DfmScheduleListResponse">
        <part element="na:DfmScheduleListResult" name="results"/>
    </message>
    <message name="DfmScheduleListInfoIterEndRequest">
        <part element="na:DfmScheduleListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DfmScheduleListInfoIterEndResponse">
        <part element="na:DfmScheduleListInfoIterEndResult" name="results"/>
    </message>
    <message name="DfmScheduleListInfoIterNextRequest">
        <part element="na:DfmScheduleListInfoIterNext" name="parameters"/>
    </message>
    <message name="DfmScheduleListInfoIterNextResponse">
        <part element="na:DfmScheduleListInfoIterNextResult" name="results"/>
    </message>
    <message name="DfmScheduleListInfoIterStartRequest">
        <part element="na:DfmScheduleListInfoIterStart" name="parameters"/>
    </message>
    <message name="DfmScheduleListInfoIterStartResponse">
        <part element="na:DfmScheduleListInfoIterStartResult" name="results"/>
    </message>
    <message name="DfmScheduleModifyRequest">
        <part element="na:DfmScheduleModify" name="parameters"/>
    </message>
    <message name="DfmScheduleModifyResponse">
        <part element="na:DfmScheduleModifyResult" name="results"/>
    </message>
    <message name="DfmScheduleMonthlyAddRequest">
        <part element="na:DfmScheduleMonthlyAdd" name="parameters"/>
    </message>
    <message name="DfmScheduleMonthlyAddResponse">
        <part element="na:DfmScheduleMonthlyAddResult" name="results"/>
    </message>
    <message name="DfmScheduleMonthlyDeleteRequest">
        <part element="na:DfmScheduleMonthlyDelete" name="parameters"/>
    </message>
    <message name="DfmScheduleMonthlyDeleteResponse">
        <part element="na:DfmScheduleMonthlyDeleteResult" name="results"/>
    </message>
    <message name="DfmScheduleMonthlyModifyRequest">
        <part element="na:DfmScheduleMonthlyModify" name="parameters"/>
    </message>
    <message name="DfmScheduleMonthlyModifyResponse">
        <part element="na:DfmScheduleMonthlyModifyResult" name="results"/>
    </message>
    <message name="DfmScheduleMonthlySubscheduleSetRequest">
        <part element="na:DfmScheduleMonthlySubscheduleSet" name="parameters"/>
    </message>
    <message name="DfmScheduleMonthlySubscheduleSetResponse">
        <part element="na:DfmScheduleMonthlySubscheduleSetResult" name="results"/>
    </message>
    <message name="DfmScheduleMonthlySubscheduleUnsetRequest">
        <part element="na:DfmScheduleMonthlySubscheduleUnset" name="parameters"/>
    </message>
    <message name="DfmScheduleMonthlySubscheduleUnsetResponse">
        <part element="na:DfmScheduleMonthlySubscheduleUnsetResult" name="results"/>
    </message>
    <message name="DfmScheduleRenameRequest">
        <part element="na:DfmScheduleRename" name="parameters"/>
    </message>
    <message name="DfmScheduleRenameResponse">
        <part element="na:DfmScheduleRenameResult" name="results"/>
    </message>
    <message name="DfmScheduleWeeklyAddRequest">
        <part element="na:DfmScheduleWeeklyAdd" name="parameters"/>
    </message>
    <message name="DfmScheduleWeeklyAddResponse">
        <part element="na:DfmScheduleWeeklyAddResult" name="results"/>
    </message>
    <message name="DfmScheduleWeeklyDeleteRequest">
        <part element="na:DfmScheduleWeeklyDelete" name="parameters"/>
    </message>
    <message name="DfmScheduleWeeklyDeleteResponse">
        <part element="na:DfmScheduleWeeklyDeleteResult" name="results"/>
    </message>
    <message name="DfmScheduleWeeklyModifyRequest">
        <part element="na:DfmScheduleWeeklyModify" name="parameters"/>
    </message>
    <message name="DfmScheduleWeeklyModifyResponse">
        <part element="na:DfmScheduleWeeklyModifyResult" name="results"/>
    </message>
    <message name="DfmScheduleWeeklySubscheduleAddRequest">
        <part element="na:DfmScheduleWeeklySubscheduleAdd" name="parameters"/>
    </message>
    <message name="DfmScheduleWeeklySubscheduleAddResponse">
        <part element="na:DfmScheduleWeeklySubscheduleAddResult" name="results"/>
    </message>
    <message name="DfmScheduleWeeklySubscheduleDeleteRequest">
        <part element="na:DfmScheduleWeeklySubscheduleDelete" name="parameters"/>
    </message>
    <message name="DfmScheduleWeeklySubscheduleDeleteResponse">
        <part element="na:DfmScheduleWeeklySubscheduleDeleteResult" name="results"/>
    </message>
    <message name="DfmScheduleWeeklySubscheduleModifyRequest">
        <part element="na:DfmScheduleWeeklySubscheduleModify" name="parameters"/>
    </message>
    <message name="DfmScheduleWeeklySubscheduleModifyResponse">
        <part element="na:DfmScheduleWeeklySubscheduleModifyResult" name="results"/>
    </message>
    <message name="DfmServerListDiagnosticInfoRequest">
        <part element="na:DfmServerListDiagnosticInfo" name="parameters"/>
    </message>
    <message name="DfmServerListDiagnosticInfoResponse">
        <part element="na:DfmServerListDiagnosticInfoResult" name="results"/>
    </message>
    <message name="DfmUserPrivGetRequest">
        <part element="na:DfmUserPrivGet" name="parameters"/>
    </message>
    <message name="DfmUserPrivGetResponse">
        <part element="na:DfmUserPrivGetResult" name="results"/>
    </message>
    <message name="DiskListInfoIterEndRequest">
        <part element="na:DiskListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DiskListInfoIterEndResponse">
        <part element="na:DiskListInfoIterEndResult" name="results"/>
    </message>
    <message name="DiskListInfoIterNextRequest">
        <part element="na:DiskListInfoIterNext" name="parameters"/>
    </message>
    <message name="DiskListInfoIterNextResponse">
        <part element="na:DiskListInfoIterNextResult" name="results"/>
    </message>
    <message name="DiskListInfoIterStartRequest">
        <part element="na:DiskListInfoIterStart" name="parameters"/>
    </message>
    <message name="DiskListInfoIterStartResponse">
        <part element="na:DiskListInfoIterStartResult" name="results"/>
    </message>
    <message name="DpBackupContentListIterEndRequest">
        <part element="na:DpBackupContentListIterEnd" name="parameters"/>
    </message>
    <message name="DpBackupContentListIterEndResponse">
        <part element="na:DpBackupContentListIterEndResult" name="results"/>
    </message>
    <message name="DpBackupContentListIterNextRequest">
        <part element="na:DpBackupContentListIterNext" name="parameters"/>
    </message>
    <message name="DpBackupContentListIterNextResponse">
        <part element="na:DpBackupContentListIterNextResult" name="results"/>
    </message>
    <message name="DpBackupContentListIterStartRequest">
        <part element="na:DpBackupContentListIterStart" name="parameters"/>
    </message>
    <message name="DpBackupContentListIterStartResponse">
        <part element="na:DpBackupContentListIterStartResult" name="results"/>
    </message>
    <message name="DpBackupGetLocationRequest">
        <part element="na:DpBackupGetLocation" name="parameters"/>
    </message>
    <message name="DpBackupGetLocationResponse">
        <part element="na:DpBackupGetLocationResult" name="results"/>
    </message>
    <message name="DpBackupListIterEndRequest">
        <part element="na:DpBackupListIterEnd" name="parameters"/>
    </message>
    <message name="DpBackupListIterEndResponse">
        <part element="na:DpBackupListIterEndResult" name="results"/>
    </message>
    <message name="DpBackupListIterNextRequest">
        <part element="na:DpBackupListIterNext" name="parameters"/>
    </message>
    <message name="DpBackupListIterNextResponse">
        <part element="na:DpBackupListIterNextResult" name="results"/>
    </message>
    <message name="DpBackupListIterStartRequest">
        <part element="na:DpBackupListIterStart" name="parameters"/>
    </message>
    <message name="DpBackupListIterStartResponse">
        <part element="na:DpBackupListIterStartResult" name="results"/>
    </message>
    <message name="DpBackupStartRequest">
        <part element="na:DpBackupStart" name="parameters"/>
    </message>
    <message name="DpBackupStartResponse">
        <part element="na:DpBackupStartResult" name="results"/>
    </message>
    <message name="DpBackupVersionCreateRequest">
        <part element="na:DpBackupVersionCreate" name="parameters"/>
    </message>
    <message name="DpBackupVersionCreateResponse">
        <part element="na:DpBackupVersionCreateResult" name="results"/>
    </message>
    <message name="DpBackupVersionDeleteRequest">
        <part element="na:DpBackupVersionDelete" name="parameters"/>
    </message>
    <message name="DpBackupVersionDeleteResponse">
        <part element="na:DpBackupVersionDeleteResult" name="results"/>
    </message>
    <message name="DpBackupVersionListIterEndRequest">
        <part element="na:DpBackupVersionListIterEnd" name="parameters"/>
    </message>
    <message name="DpBackupVersionListIterEndResponse">
        <part element="na:DpBackupVersionListIterEndResult" name="results"/>
    </message>
    <message name="DpBackupVersionListIterNextRequest">
        <part element="na:DpBackupVersionListIterNext" name="parameters"/>
    </message>
    <message name="DpBackupVersionListIterNextResponse">
        <part element="na:DpBackupVersionListIterNextResult" name="results"/>
    </message>
    <message name="DpBackupVersionListIterStartRequest">
        <part element="na:DpBackupVersionListIterStart" name="parameters"/>
    </message>
    <message name="DpBackupVersionListIterStartResponse">
        <part element="na:DpBackupVersionListIterStartResult" name="results"/>
    </message>
    <message name="DpBackupVersionModifyRequest">
        <part element="na:DpBackupVersionModify" name="parameters"/>
    </message>
    <message name="DpBackupVersionModifyResponse">
        <part element="na:DpBackupVersionModifyResult" name="results"/>
    </message>
    <message name="DpDashboardGetDrDatasetCountsRequest">
        <part element="na:DpDashboardGetDrDatasetCounts" name="parameters"/>
    </message>
    <message name="DpDashboardGetDrDatasetCountsResponse">
        <part element="na:DpDashboardGetDrDatasetCountsResult" name="results"/>
    </message>
    <message name="DpDashboardGetLaggedDatasetsRequest">
        <part element="na:DpDashboardGetLaggedDatasets" name="parameters"/>
    </message>
    <message name="DpDashboardGetLaggedDatasetsResponse">
        <part element="na:DpDashboardGetLaggedDatasetsResult" name="results"/>
    </message>
    <message name="DpDashboardGetLaggedRelationshipsRequest">
        <part element="na:DpDashboardGetLaggedRelationships" name="parameters"/>
    </message>
    <message name="DpDashboardGetLaggedRelationshipsResponse">
        <part element="na:DpDashboardGetLaggedRelationshipsResult" name="results"/>
    </message>
    <message name="DpDashboardGetProtectedDataCountsRequest">
        <part element="na:DpDashboardGetProtectedDataCounts" name="parameters"/>
    </message>
    <message name="DpDashboardGetProtectedDataCountsResponse">
        <part element="na:DpDashboardGetProtectedDataCountsResult" name="results"/>
    </message>
    <message name="DpDashboardGetProtectedDataCounts2Request">
        <part element="na:DpDashboardGetProtectedDataCounts2" name="parameters"/>
    </message>
    <message name="DpDashboardGetProtectedDataCounts2Response">
        <part element="na:DpDashboardGetProtectedDataCounts2Result" name="results"/>
    </message>
    <message name="DpGetDatasetBackupJobsDataRequest">
        <part element="na:DpGetDatasetBackupJobsData" name="parameters"/>
    </message>
    <message name="DpGetDatasetBackupJobsDataResponse">
        <part element="na:DpGetDatasetBackupJobsDataResult" name="results"/>
    </message>
    <message name="DpJobAbortRequest">
        <part element="na:DpJobAbort" name="parameters"/>
    </message>
    <message name="DpJobAbortResponse">
        <part element="na:DpJobAbortResult" name="results"/>
    </message>
    <message name="DpJobListIterEndRequest">
        <part element="na:DpJobListIterEnd" name="parameters"/>
    </message>
    <message name="DpJobListIterEndResponse">
        <part element="na:DpJobListIterEndResult" name="results"/>
    </message>
    <message name="DpJobListIterNextRequest">
        <part element="na:DpJobListIterNext" name="parameters"/>
    </message>
    <message name="DpJobListIterNextResponse">
        <part element="na:DpJobListIterNextResult" name="results"/>
    </message>
    <message name="DpJobListIterStartRequest">
        <part element="na:DpJobListIterStart" name="parameters"/>
    </message>
    <message name="DpJobListIterStartResponse">
        <part element="na:DpJobListIterStartResult" name="results"/>
    </message>
    <message name="DpJobProgressEventListIterEndRequest">
        <part element="na:DpJobProgressEventListIterEnd" name="parameters"/>
    </message>
    <message name="DpJobProgressEventListIterEndResponse">
        <part element="na:DpJobProgressEventListIterEndResult" name="results"/>
    </message>
    <message name="DpJobProgressEventListIterNextRequest">
        <part element="na:DpJobProgressEventListIterNext" name="parameters"/>
    </message>
    <message name="DpJobProgressEventListIterNextResponse">
        <part element="na:DpJobProgressEventListIterNextResult" name="results"/>
    </message>
    <message name="DpJobProgressEventListIterStartRequest">
        <part element="na:DpJobProgressEventListIterStart" name="parameters"/>
    </message>
    <message name="DpJobProgressEventListIterStartResponse">
        <part element="na:DpJobProgressEventListIterStartResult" name="results"/>
    </message>
    <message name="DpJobPurgeRequest">
        <part element="na:DpJobPurge" name="parameters"/>
    </message>
    <message name="DpJobPurgeResponse">
        <part element="na:DpJobPurgeResult" name="results"/>
    </message>
    <message name="DpJobScheduleGetLastChangedRequest">
        <part element="na:DpJobScheduleGetLastChanged" name="parameters"/>
    </message>
    <message name="DpJobScheduleGetLastChangedResponse">
        <part element="na:DpJobScheduleGetLastChangedResult" name="results"/>
    </message>
    <message name="DpJobScheduleListIterEndRequest">
        <part element="na:DpJobScheduleListIterEnd" name="parameters"/>
    </message>
    <message name="DpJobScheduleListIterEndResponse">
        <part element="na:DpJobScheduleListIterEndResult" name="results"/>
    </message>
    <message name="DpJobScheduleListIterNextRequest">
        <part element="na:DpJobScheduleListIterNext" name="parameters"/>
    </message>
    <message name="DpJobScheduleListIterNextResponse">
        <part element="na:DpJobScheduleListIterNextResult" name="results"/>
    </message>
    <message name="DpJobScheduleListIterStartRequest">
        <part element="na:DpJobScheduleListIterStart" name="parameters"/>
    </message>
    <message name="DpJobScheduleListIterStartResponse">
        <part element="na:DpJobScheduleListIterStartResult" name="results"/>
    </message>
    <message name="DpOssvApplicationListInfoIterEndRequest">
        <part element="na:DpOssvApplicationListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DpOssvApplicationListInfoIterEndResponse">
        <part element="na:DpOssvApplicationListInfoIterEndResult" name="results"/>
    </message>
    <message name="DpOssvApplicationListInfoIterNextRequest">
        <part element="na:DpOssvApplicationListInfoIterNext" name="parameters"/>
    </message>
    <message name="DpOssvApplicationListInfoIterNextResponse">
        <part element="na:DpOssvApplicationListInfoIterNextResult" name="results"/>
    </message>
    <message name="DpOssvApplicationListInfoIterStartRequest">
        <part element="na:DpOssvApplicationListInfoIterStart" name="parameters"/>
    </message>
    <message name="DpOssvApplicationListInfoIterStartResponse">
        <part element="na:DpOssvApplicationListInfoIterStartResult" name="results"/>
    </message>
    <message name="DpOssvApplicationRestoreDestinationListInfoIterEndRequest">
        <part element="na:DpOssvApplicationRestoreDestinationListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DpOssvApplicationRestoreDestinationListInfoIterEndResponse">
        <part element="na:DpOssvApplicationRestoreDestinationListInfoIterEndResult" name="results"/>
    </message>
    <message name="DpOssvApplicationRestoreDestinationListInfoIterNextRequest">
        <part element="na:DpOssvApplicationRestoreDestinationListInfoIterNext" name="parameters"/>
    </message>
    <message name="DpOssvApplicationRestoreDestinationListInfoIterNextResponse">
        <part element="na:DpOssvApplicationRestoreDestinationListInfoIterNextResult" name="results"/>
    </message>
    <message name="DpOssvApplicationRestoreDestinationListInfoIterStartRequest">
        <part element="na:DpOssvApplicationRestoreDestinationListInfoIterStart" name="parameters"/>
    </message>
    <message name="DpOssvApplicationRestoreDestinationListInfoIterStartResponse">
        <part element="na:DpOssvApplicationRestoreDestinationListInfoIterStartResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryAddRequest">
        <part element="na:DpOssvDirectoryAdd" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryAddResponse">
        <part element="na:DpOssvDirectoryAddResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryBrowseIterEndRequest">
        <part element="na:DpOssvDirectoryBrowseIterEnd" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryBrowseIterEndResponse">
        <part element="na:DpOssvDirectoryBrowseIterEndResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryBrowseIterNextRequest">
        <part element="na:DpOssvDirectoryBrowseIterNext" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryBrowseIterNextResponse">
        <part element="na:DpOssvDirectoryBrowseIterNextResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryBrowseIterStartRequest">
        <part element="na:DpOssvDirectoryBrowseIterStart" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryBrowseIterStartResponse">
        <part element="na:DpOssvDirectoryBrowseIterStartResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryDiscoveredIterEndRequest">
        <part element="na:DpOssvDirectoryDiscoveredIterEnd" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryDiscoveredIterEndResponse">
        <part element="na:DpOssvDirectoryDiscoveredIterEndResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryDiscoveredIterNextRequest">
        <part element="na:DpOssvDirectoryDiscoveredIterNext" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryDiscoveredIterNextResponse">
        <part element="na:DpOssvDirectoryDiscoveredIterNextResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryDiscoveredIterStartRequest">
        <part element="na:DpOssvDirectoryDiscoveredIterStart" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryDiscoveredIterStartResponse">
        <part element="na:DpOssvDirectoryDiscoveredIterStartResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryModifyRequest">
        <part element="na:DpOssvDirectoryModify" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryModifyResponse">
        <part element="na:DpOssvDirectoryModifyResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryRootsIterEndRequest">
        <part element="na:DpOssvDirectoryRootsIterEnd" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryRootsIterEndResponse">
        <part element="na:DpOssvDirectoryRootsIterEndResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryRootsIterNextRequest">
        <part element="na:DpOssvDirectoryRootsIterNext" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryRootsIterNextResponse">
        <part element="na:DpOssvDirectoryRootsIterNextResult" name="results"/>
    </message>
    <message name="DpOssvDirectoryRootsIterStartRequest">
        <part element="na:DpOssvDirectoryRootsIterStart" name="parameters"/>
    </message>
    <message name="DpOssvDirectoryRootsIterStartResponse">
        <part element="na:DpOssvDirectoryRootsIterStartResult" name="results"/>
    </message>
    <message name="DpPolicyCopyRequest">
        <part element="na:DpPolicyCopy" name="parameters"/>
    </message>
    <message name="DpPolicyCopyResponse">
        <part element="na:DpPolicyCopyResult" name="results"/>
    </message>
    <message name="DpPolicyDestroyRequest">
        <part element="na:DpPolicyDestroy" name="parameters"/>
    </message>
    <message name="DpPolicyDestroyResponse">
        <part element="na:DpPolicyDestroyResult" name="results"/>
    </message>
    <message name="DpPolicyEditBeginRequest">
        <part element="na:DpPolicyEditBegin" name="parameters"/>
    </message>
    <message name="DpPolicyEditBeginResponse">
        <part element="na:DpPolicyEditBeginResult" name="results"/>
    </message>
    <message name="DpPolicyEditCommitRequest">
        <part element="na:DpPolicyEditCommit" name="parameters"/>
    </message>
    <message name="DpPolicyEditCommitResponse">
        <part element="na:DpPolicyEditCommitResult" name="results"/>
    </message>
    <message name="DpPolicyEditRollbackRequest">
        <part element="na:DpPolicyEditRollback" name="parameters"/>
    </message>
    <message name="DpPolicyEditRollbackResponse">
        <part element="na:DpPolicyEditRollbackResult" name="results"/>
    </message>
    <message name="DpPolicyGetDefaultPropertyValuesRequest">
        <part element="na:DpPolicyGetDefaultPropertyValues" name="parameters"/>
    </message>
    <message name="DpPolicyGetDefaultPropertyValuesResponse">
        <part element="na:DpPolicyGetDefaultPropertyValuesResult" name="results"/>
    </message>
    <message name="DpPolicyListIterEndRequest">
        <part element="na:DpPolicyListIterEnd" name="parameters"/>
    </message>
    <message name="DpPolicyListIterEndResponse">
        <part element="na:DpPolicyListIterEndResult" name="results"/>
    </message>
    <message name="DpPolicyListIterNextRequest">
        <part element="na:DpPolicyListIterNext" name="parameters"/>
    </message>
    <message name="DpPolicyListIterNextResponse">
        <part element="na:DpPolicyListIterNextResult" name="results"/>
    </message>
    <message name="DpPolicyListIterStartRequest">
        <part element="na:DpPolicyListIterStart" name="parameters"/>
    </message>
    <message name="DpPolicyListIterStartResponse">
        <part element="na:DpPolicyListIterStartResult" name="results"/>
    </message>
    <message name="DpPolicyModifyRequest">
        <part element="na:DpPolicyModify" name="parameters"/>
    </message>
    <message name="DpPolicyModifyResponse">
        <part element="na:DpPolicyModifyResult" name="results"/>
    </message>
    <message name="DpRelationshipListInfoIterEndRequest">
        <part element="na:DpRelationshipListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DpRelationshipListInfoIterEndResponse">
        <part element="na:DpRelationshipListInfoIterEndResult" name="results"/>
    </message>
    <message name="DpRelationshipListInfoIterNextRequest">
        <part element="na:DpRelationshipListInfoIterNext" name="parameters"/>
    </message>
    <message name="DpRelationshipListInfoIterNextResponse">
        <part element="na:DpRelationshipListInfoIterNextResult" name="results"/>
    </message>
    <message name="DpRelationshipListInfoIterStartRequest">
        <part element="na:DpRelationshipListInfoIterStart" name="parameters"/>
    </message>
    <message name="DpRelationshipListInfoIterStartResponse">
        <part element="na:DpRelationshipListInfoIterStartResult" name="results"/>
    </message>
    <message name="DpRelationshipModifyRequest">
        <part element="na:DpRelationshipModify" name="parameters"/>
    </message>
    <message name="DpRelationshipModifyResponse">
        <part element="na:DpRelationshipModifyResult" name="results"/>
    </message>
    <message name="DpRestoreToNewPathRequest">
        <part element="na:DpRestoreToNewPath" name="parameters"/>
    </message>
    <message name="DpRestoreToNewPathResponse">
        <part element="na:DpRestoreToNewPathResult" name="results"/>
    </message>
    <message name="DpRestoreToPrimaryRequest">
        <part element="na:DpRestoreToPrimary" name="parameters"/>
    </message>
    <message name="DpRestoreToPrimaryResponse">
        <part element="na:DpRestoreToPrimaryResult" name="results"/>
    </message>
    <message name="DpScheduleContentGetRequest">
        <part element="na:DpScheduleContentGet" name="parameters"/>
    </message>
    <message name="DpScheduleContentGetResponse">
        <part element="na:DpScheduleContentGetResult" name="results"/>
    </message>
    <message name="DpScheduleCreateRequest">
        <part element="na:DpScheduleCreate" name="parameters"/>
    </message>
    <message name="DpScheduleCreateResponse">
        <part element="na:DpScheduleCreateResult" name="results"/>
    </message>
    <message name="DpScheduleDailyAddRequest">
        <part element="na:DpScheduleDailyAdd" name="parameters"/>
    </message>
    <message name="DpScheduleDailyAddResponse">
        <part element="na:DpScheduleDailyAddResult" name="results"/>
    </message>
    <message name="DpScheduleDailyDeleteRequest">
        <part element="na:DpScheduleDailyDelete" name="parameters"/>
    </message>
    <message name="DpScheduleDailyDeleteResponse">
        <part element="na:DpScheduleDailyDeleteResult" name="results"/>
    </message>
    <message name="DpScheduleDailyModifyRequest">
        <part element="na:DpScheduleDailyModify" name="parameters"/>
    </message>
    <message name="DpScheduleDailyModifyResponse">
        <part element="na:DpScheduleDailyModifyResult" name="results"/>
    </message>
    <message name="DpScheduleDependencyRequest">
        <part element="na:DpScheduleDependency" name="parameters"/>
    </message>
    <message name="DpScheduleDependencyResponse">
        <part element="na:DpScheduleDependencyResult" name="results"/>
    </message>
    <message name="DpScheduleDestroyRequest">
        <part element="na:DpScheduleDestroy" name="parameters"/>
    </message>
    <message name="DpScheduleDestroyResponse">
        <part element="na:DpScheduleDestroyResult" name="results"/>
    </message>
    <message name="DpScheduleHourlyAddRequest">
        <part element="na:DpScheduleHourlyAdd" name="parameters"/>
    </message>
    <message name="DpScheduleHourlyAddResponse">
        <part element="na:DpScheduleHourlyAddResult" name="results"/>
    </message>
    <message name="DpScheduleHourlyDeleteRequest">
        <part element="na:DpScheduleHourlyDelete" name="parameters"/>
    </message>
    <message name="DpScheduleHourlyDeleteResponse">
        <part element="na:DpScheduleHourlyDeleteResult" name="results"/>
    </message>
    <message name="DpScheduleHourlyModifyRequest">
        <part element="na:DpScheduleHourlyModify" name="parameters"/>
    </message>
    <message name="DpScheduleHourlyModifyResponse">
        <part element="na:DpScheduleHourlyModifyResult" name="results"/>
    </message>
    <message name="DpScheduleListRequest">
        <part element="na:DpScheduleList" name="parameters"/>
    </message>
    <message name="DpScheduleListResponse">
        <part element="na:DpScheduleListResult" name="results"/>
    </message>
    <message name="DpScheduleListInfoIterEndRequest">
        <part element="na:DpScheduleListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DpScheduleListInfoIterEndResponse">
        <part element="na:DpScheduleListInfoIterEndResult" name="results"/>
    </message>
    <message name="DpScheduleListInfoIterNextRequest">
        <part element="na:DpScheduleListInfoIterNext" name="parameters"/>
    </message>
    <message name="DpScheduleListInfoIterNextResponse">
        <part element="na:DpScheduleListInfoIterNextResult" name="results"/>
    </message>
    <message name="DpScheduleListInfoIterStartRequest">
        <part element="na:DpScheduleListInfoIterStart" name="parameters"/>
    </message>
    <message name="DpScheduleListInfoIterStartResponse">
        <part element="na:DpScheduleListInfoIterStartResult" name="results"/>
    </message>
    <message name="DpScheduleModifyRequest">
        <part element="na:DpScheduleModify" name="parameters"/>
    </message>
    <message name="DpScheduleModifyResponse">
        <part element="na:DpScheduleModifyResult" name="results"/>
    </message>
    <message name="DpScheduleMonthlyAddRequest">
        <part element="na:DpScheduleMonthlyAdd" name="parameters"/>
    </message>
    <message name="DpScheduleMonthlyAddResponse">
        <part element="na:DpScheduleMonthlyAddResult" name="results"/>
    </message>
    <message name="DpScheduleMonthlyDeleteRequest">
        <part element="na:DpScheduleMonthlyDelete" name="parameters"/>
    </message>
    <message name="DpScheduleMonthlyDeleteResponse">
        <part element="na:DpScheduleMonthlyDeleteResult" name="results"/>
    </message>
    <message name="DpScheduleMonthlyModifyRequest">
        <part element="na:DpScheduleMonthlyModify" name="parameters"/>
    </message>
    <message name="DpScheduleMonthlyModifyResponse">
        <part element="na:DpScheduleMonthlyModifyResult" name="results"/>
    </message>
    <message name="DpScheduleMonthlySubscheduleSetRequest">
        <part element="na:DpScheduleMonthlySubscheduleSet" name="parameters"/>
    </message>
    <message name="DpScheduleMonthlySubscheduleSetResponse">
        <part element="na:DpScheduleMonthlySubscheduleSetResult" name="results"/>
    </message>
    <message name="DpScheduleMonthlySubscheduleUnsetRequest">
        <part element="na:DpScheduleMonthlySubscheduleUnset" name="parameters"/>
    </message>
    <message name="DpScheduleMonthlySubscheduleUnsetResponse">
        <part element="na:DpScheduleMonthlySubscheduleUnsetResult" name="results"/>
    </message>
    <message name="DpScheduleRenameRequest">
        <part element="na:DpScheduleRename" name="parameters"/>
    </message>
    <message name="DpScheduleRenameResponse">
        <part element="na:DpScheduleRenameResult" name="results"/>
    </message>
    <message name="DpScheduleWeeklyAddRequest">
        <part element="na:DpScheduleWeeklyAdd" name="parameters"/>
    </message>
    <message name="DpScheduleWeeklyAddResponse">
        <part element="na:DpScheduleWeeklyAddResult" name="results"/>
    </message>
    <message name="DpScheduleWeeklyDeleteRequest">
        <part element="na:DpScheduleWeeklyDelete" name="parameters"/>
    </message>
    <message name="DpScheduleWeeklyDeleteResponse">
        <part element="na:DpScheduleWeeklyDeleteResult" name="results"/>
    </message>
    <message name="DpScheduleWeeklyModifyRequest">
        <part element="na:DpScheduleWeeklyModify" name="parameters"/>
    </message>
    <message name="DpScheduleWeeklyModifyResponse">
        <part element="na:DpScheduleWeeklyModifyResult" name="results"/>
    </message>
    <message name="DpScheduleWeeklySubscheduleAddRequest">
        <part element="na:DpScheduleWeeklySubscheduleAdd" name="parameters"/>
    </message>
    <message name="DpScheduleWeeklySubscheduleAddResponse">
        <part element="na:DpScheduleWeeklySubscheduleAddResult" name="results"/>
    </message>
    <message name="DpScheduleWeeklySubscheduleDeleteRequest">
        <part element="na:DpScheduleWeeklySubscheduleDelete" name="parameters"/>
    </message>
    <message name="DpScheduleWeeklySubscheduleDeleteResponse">
        <part element="na:DpScheduleWeeklySubscheduleDeleteResult" name="results"/>
    </message>
    <message name="DpScheduleWeeklySubscheduleModifyRequest">
        <part element="na:DpScheduleWeeklySubscheduleModify" name="parameters"/>
    </message>
    <message name="DpScheduleWeeklySubscheduleModifyResponse">
        <part element="na:DpScheduleWeeklySubscheduleModifyResult" name="results"/>
    </message>
    <message name="DpThrottleCreateRequest">
        <part element="na:DpThrottleCreate" name="parameters"/>
    </message>
    <message name="DpThrottleCreateResponse">
        <part element="na:DpThrottleCreateResult" name="results"/>
    </message>
    <message name="DpThrottleDependencyRequest">
        <part element="na:DpThrottleDependency" name="parameters"/>
    </message>
    <message name="DpThrottleDependencyResponse">
        <part element="na:DpThrottleDependencyResult" name="results"/>
    </message>
    <message name="DpThrottleDestroyRequest">
        <part element="na:DpThrottleDestroy" name="parameters"/>
    </message>
    <message name="DpThrottleDestroyResponse">
        <part element="na:DpThrottleDestroyResult" name="results"/>
    </message>
    <message name="DpThrottleItemAddRequest">
        <part element="na:DpThrottleItemAdd" name="parameters"/>
    </message>
    <message name="DpThrottleItemAddResponse">
        <part element="na:DpThrottleItemAddResult" name="results"/>
    </message>
    <message name="DpThrottleItemDeleteRequest">
        <part element="na:DpThrottleItemDelete" name="parameters"/>
    </message>
    <message name="DpThrottleItemDeleteResponse">
        <part element="na:DpThrottleItemDeleteResult" name="results"/>
    </message>
    <message name="DpThrottleListInfoIterEndRequest">
        <part element="na:DpThrottleListInfoIterEnd" name="parameters"/>
    </message>
    <message name="DpThrottleListInfoIterEndResponse">
        <part element="na:DpThrottleListInfoIterEndResult" name="results"/>
    </message>
    <message name="DpThrottleListInfoIterNextRequest">
        <part element="na:DpThrottleListInfoIterNext" name="parameters"/>
    </message>
    <message name="DpThrottleListInfoIterNextResponse">
        <part element="na:DpThrottleListInfoIterNextResult" name="results"/>
    </message>
    <message name="DpThrottleListInfoIterStartRequest">
        <part element="na:DpThrottleListInfoIterStart" name="parameters"/>
    </message>
    <message name="DpThrottleListInfoIterStartResponse">
        <part element="na:DpThrottleListInfoIterStartResult" name="results"/>
    </message>
    <message name="DpThrottleModifyRequest">
        <part element="na:DpThrottleModify" name="parameters"/>
    </message>
    <message name="DpThrottleModifyResponse">
        <part element="na:DpThrottleModifyResult" name="results"/>
    </message>
    <message name="DpThrottleRenameRequest">
        <part element="na:DpThrottleRename" name="parameters"/>
    </message>
    <message name="DpThrottleRenameResponse">
        <part element="na:DpThrottleRenameResult" name="results"/>
    </message>
    <message name="EventAcknowledgeRequest">
        <part element="na:EventAcknowledge" name="parameters"/>
    </message>
    <message name="EventAcknowledgeResponse">
        <part element="na:EventAcknowledgeResult" name="results"/>
    </message>
    <message name="EventDeleteRequest">
        <part element="na:EventDelete" name="parameters"/>
    </message>
    <message name="EventDeleteResponse">
        <part element="na:EventDeleteResult" name="results"/>
    </message>
    <message name="EventGenerateRequest">
        <part element="na:EventGenerate" name="parameters"/>
    </message>
    <message name="EventGenerateResponse">
        <part element="na:EventGenerateResult" name="results"/>
    </message>
    <message name="EventListIterEndRequest">
        <part element="na:EventListIterEnd" name="parameters"/>
    </message>
    <message name="EventListIterEndResponse">
        <part element="na:EventListIterEndResult" name="results"/>
    </message>
    <message name="EventListIterNextRequest">
        <part element="na:EventListIterNext" name="parameters"/>
    </message>
    <message name="EventListIterNextResponse">
        <part element="na:EventListIterNextResult" name="results"/>
    </message>
    <message name="EventListIterStartRequest">
        <part element="na:EventListIterStart" name="parameters"/>
    </message>
    <message name="EventListIterStartResponse">
        <part element="na:EventListIterStartResult" name="results"/>
    </message>
    <message name="EventStatusChangeListIterEndRequest">
        <part element="na:EventStatusChangeListIterEnd" name="parameters"/>
    </message>
    <message name="EventStatusChangeListIterEndResponse">
        <part element="na:EventStatusChangeListIterEndResult" name="results"/>
    </message>
    <message name="EventStatusChangeListIterNextRequest">
        <part element="na:EventStatusChangeListIterNext" name="parameters"/>
    </message>
    <message name="EventStatusChangeListIterNextResponse">
        <part element="na:EventStatusChangeListIterNextResult" name="results"/>
    </message>
    <message name="EventStatusChangeListIterStartRequest">
        <part element="na:EventStatusChangeListIterStart" name="parameters"/>
    </message>
    <message name="EventStatusChangeListIterStartResponse">
        <part element="na:EventStatusChangeListIterStartResult" name="results"/>
    </message>
    <message name="EventclassAddCustomRequest">
        <part element="na:EventclassAddCustom" name="parameters"/>
    </message>
    <message name="EventclassAddCustomResponse">
        <part element="na:EventclassAddCustomResult" name="results"/>
    </message>
    <message name="EventclassDeleteCustomRequest">
        <part element="na:EventclassDeleteCustom" name="parameters"/>
    </message>
    <message name="EventclassDeleteCustomResponse">
        <part element="na:EventclassDeleteCustomResult" name="results"/>
    </message>
    <message name="EventclassListRequest">
        <part element="na:EventclassList" name="parameters"/>
    </message>
    <message name="EventclassListResponse">
        <part element="na:EventclassListResult" name="results"/>
    </message>
    <message name="EventclassListIterEndRequest">
        <part element="na:EventclassListIterEnd" name="parameters"/>
    </message>
    <message name="EventclassListIterEndResponse">
        <part element="na:EventclassListIterEndResult" name="results"/>
    </message>
    <message name="EventclassListIterNextRequest">
        <part element="na:EventclassListIterNext" name="parameters"/>
    </message>
    <message name="EventclassListIterNextResponse">
        <part element="na:EventclassListIterNextResult" name="results"/>
    </message>
    <message name="EventclassListIterStartRequest">
        <part element="na:EventclassListIterStart" name="parameters"/>
    </message>
    <message name="EventclassListIterStartResponse">
        <part element="na:EventclassListIterStartResult" name="results"/>
    </message>
    <message name="FcpTargetListInfoIterEndRequest">
        <part element="na:FcpTargetListInfoIterEnd" name="parameters"/>
    </message>
    <message name="FcpTargetListInfoIterEndResponse">
        <part element="na:FcpTargetListInfoIterEndResult" name="results"/>
    </message>
    <message name="FcpTargetListInfoIterNextRequest">
        <part element="na:FcpTargetListInfoIterNext" name="parameters"/>
    </message>
    <message name="FcpTargetListInfoIterNextResponse">
        <part element="na:FcpTargetListInfoIterNextResult" name="results"/>
    </message>
    <message name="FcpTargetListInfoIterStartRequest">
        <part element="na:FcpTargetListInfoIterStart" name="parameters"/>
    </message>
    <message name="FcpTargetListInfoIterStartResponse">
        <part element="na:FcpTargetListInfoIterStartResult" name="results"/>
    </message>
    <message name="GraphDataListInfoRequest">
        <part element="na:GraphDataListInfo" name="parameters"/>
    </message>
    <message name="GraphDataListInfoResponse">
        <part element="na:GraphDataListInfoResult" name="results"/>
    </message>
    <message name="GraphListInfoIterEndRequest">
        <part element="na:GraphListInfoIterEnd" name="parameters"/>
    </message>
    <message name="GraphListInfoIterEndResponse">
        <part element="na:GraphListInfoIterEndResult" name="results"/>
    </message>
    <message name="GraphListInfoIterNextRequest">
        <part element="na:GraphListInfoIterNext" name="parameters"/>
    </message>
    <message name="GraphListInfoIterNextResponse">
        <part element="na:GraphListInfoIterNextResult" name="results"/>
    </message>
    <message name="GraphListInfoIterStartRequest">
        <part element="na:GraphListInfoIterStart" name="parameters"/>
    </message>
    <message name="GraphListInfoIterStartResponse">
        <part element="na:GraphListInfoIterStartResult" name="results"/>
    </message>
    <message name="GroupAddMemberRequest">
        <part element="na:GroupAddMember" name="parameters"/>
    </message>
    <message name="GroupAddMemberResponse">
        <part element="na:GroupAddMemberResult" name="results"/>
    </message>
    <message name="GroupCopyRequest">
        <part element="na:GroupCopy" name="parameters"/>
    </message>
    <message name="GroupCopyResponse">
        <part element="na:GroupCopyResult" name="results"/>
    </message>
    <message name="GroupCreateRequest">
        <part element="na:GroupCreate" name="parameters"/>
    </message>
    <message name="GroupCreateResponse">
        <part element="na:GroupCreateResult" name="results"/>
    </message>
    <message name="GroupDeleteMemberRequest">
        <part element="na:GroupDeleteMember" name="parameters"/>
    </message>
    <message name="GroupDeleteMemberResponse">
        <part element="na:GroupDeleteMemberResult" name="results"/>
    </message>
    <message name="GroupDestroyRequest">
        <part element="na:GroupDestroy" name="parameters"/>
    </message>
    <message name="GroupDestroyResponse">
        <part element="na:GroupDestroyResult" name="results"/>
    </message>
    <message name="GroupGetOptionsRequest">
        <part element="na:GroupGetOptions" name="parameters"/>
    </message>
    <message name="GroupGetOptionsResponse">
        <part element="na:GroupGetOptionsResult" name="results"/>
    </message>
    <message name="GroupGetStatusRequest">
        <part element="na:GroupGetStatus" name="parameters"/>
    </message>
    <message name="GroupGetStatusResponse">
        <part element="na:GroupGetStatusResult" name="results"/>
    </message>
    <message name="GroupIsMemberOfRequest">
        <part element="na:GroupIsMemberOf" name="parameters"/>
    </message>
    <message name="GroupIsMemberOfResponse">
        <part element="na:GroupIsMemberOfResult" name="results"/>
    </message>
    <message name="GroupListIterEndRequest">
        <part element="na:GroupListIterEnd" name="parameters"/>
    </message>
    <message name="GroupListIterEndResponse">
        <part element="na:GroupListIterEndResult" name="results"/>
    </message>
    <message name="GroupListIterNextRequest">
        <part element="na:GroupListIterNext" name="parameters"/>
    </message>
    <message name="GroupListIterNextResponse">
        <part element="na:GroupListIterNextResult" name="results"/>
    </message>
    <message name="GroupListIterStartRequest">
        <part element="na:GroupListIterStart" name="parameters"/>
    </message>
    <message name="GroupListIterStartResponse">
        <part element="na:GroupListIterStartResult" name="results"/>
    </message>
    <message name="GroupMemberListIterEndRequest">
        <part element="na:GroupMemberListIterEnd" name="parameters"/>
    </message>
    <message name="GroupMemberListIterEndResponse">
        <part element="na:GroupMemberListIterEndResult" name="results"/>
    </message>
    <message name="GroupMemberListIterNextRequest">
        <part element="na:GroupMemberListIterNext" name="parameters"/>
    </message>
    <message name="GroupMemberListIterNextResponse">
        <part element="na:GroupMemberListIterNextResult" name="results"/>
    </message>
    <message name="GroupMemberListIterStartRequest">
        <part element="na:GroupMemberListIterStart" name="parameters"/>
    </message>
    <message name="GroupMemberListIterStartResponse">
        <part element="na:GroupMemberListIterStartResult" name="results"/>
    </message>
    <message name="GroupMoveRequest">
        <part element="na:GroupMove" name="parameters"/>
    </message>
    <message name="GroupMoveResponse">
        <part element="na:GroupMoveResult" name="results"/>
    </message>
    <message name="GroupRenameRequest">
        <part element="na:GroupRename" name="parameters"/>
    </message>
    <message name="GroupRenameResponse">
        <part element="na:GroupRenameResult" name="results"/>
    </message>
    <message name="GroupSetOptionsRequest">
        <part element="na:GroupSetOptions" name="parameters"/>
    </message>
    <message name="GroupSetOptionsResponse">
        <part element="na:GroupSetOptionsResult" name="results"/>
    </message>
    <message name="HostAddRequest">
        <part element="na:HostAdd" name="parameters"/>
    </message>
    <message name="HostAddResponse">
        <part element="na:HostAddResult" name="results"/>
    </message>
    <message name="HostAddLicenseRequest">
        <part element="na:HostAddLicense" name="parameters"/>
    </message>
    <message name="HostAddLicenseResponse">
        <part element="na:HostAddLicenseResult" name="results"/>
    </message>
    <message name="HostAddOssvRequest">
        <part element="na:HostAddOssv" name="parameters"/>
    </message>
    <message name="HostAddOssvResponse">
        <part element="na:HostAddOssvResult" name="results"/>
    </message>
    <message name="HostAgentOssvServiceStartRequest">
        <part element="na:HostAgentOssvServiceStart" name="parameters"/>
    </message>
    <message name="HostAgentOssvServiceStartResponse">
        <part element="na:HostAgentOssvServiceStartResult" name="results"/>
    </message>
    <message name="HostAgentOssvServiceStopRequest">
        <part element="na:HostAgentOssvServiceStop" name="parameters"/>
    </message>
    <message name="HostAgentOssvServiceStopResponse">
        <part element="na:HostAgentOssvServiceStopResult" name="results"/>
    </message>
    <message name="HostCapabilityListIterEndRequest">
        <part element="na:HostCapabilityListIterEnd" name="parameters"/>
    </message>
    <message name="HostCapabilityListIterEndResponse">
        <part element="na:HostCapabilityListIterEndResult" name="results"/>
    </message>
    <message name="HostCapabilityListIterNextRequest">
        <part element="na:HostCapabilityListIterNext" name="parameters"/>
    </message>
    <message name="HostCapabilityListIterNextResponse">
        <part element="na:HostCapabilityListIterNextResult" name="results"/>
    </message>
    <message name="HostCapabilityListIterStartRequest">
        <part element="na:HostCapabilityListIterStart" name="parameters"/>
    </message>
    <message name="HostCapabilityListIterStartResponse">
        <part element="na:HostCapabilityListIterStartResult" name="results"/>
    </message>
    <message name="HostCreateNdmpuserRequest">
        <part element="na:HostCreateNdmpuser" name="parameters"/>
    </message>
    <message name="HostCreateNdmpuserResponse">
        <part element="na:HostCreateNdmpuserResult" name="results"/>
    </message>
    <message name="HostDomainuserAddRequest">
        <part element="na:HostDomainuserAdd" name="parameters"/>
    </message>
    <message name="HostDomainuserAddResponse">
        <part element="na:HostDomainuserAddResult" name="results"/>
    </message>
    <message name="HostDomainuserListIterEndRequest">
        <part element="na:HostDomainuserListIterEnd" name="parameters"/>
    </message>
    <message name="HostDomainuserListIterEndResponse">
        <part element="na:HostDomainuserListIterEndResult" name="results"/>
    </message>
    <message name="HostDomainuserListIterNextRequest">
        <part element="na:HostDomainuserListIterNext" name="parameters"/>
    </message>
    <message name="HostDomainuserListIterNextResponse">
        <part element="na:HostDomainuserListIterNextResult" name="results"/>
    </message>
    <message name="HostDomainuserListIterStartRequest">
        <part element="na:HostDomainuserListIterStart" name="parameters"/>
    </message>
    <message name="HostDomainuserListIterStartResponse">
        <part element="na:HostDomainuserListIterStartResult" name="results"/>
    </message>
    <message name="HostDomainuserPushRequest">
        <part element="na:HostDomainuserPush" name="parameters"/>
    </message>
    <message name="HostDomainuserPushResponse">
        <part element="na:HostDomainuserPushResult" name="results"/>
    </message>
    <message name="HostDomainuserRemoveRequest">
        <part element="na:HostDomainuserRemove" name="parameters"/>
    </message>
    <message name="HostDomainuserRemoveResponse">
        <part element="na:HostDomainuserRemoveResult" name="results"/>
    </message>
    <message name="HostGetDefaultsRequest">
        <part element="na:HostGetDefaults" name="parameters"/>
    </message>
    <message name="HostGetDefaultsResponse">
        <part element="na:HostGetDefaultsResult" name="results"/>
    </message>
    <message name="HostListInfoIterEndRequest">
        <part element="na:HostListInfoIterEnd" name="parameters"/>
    </message>
    <message name="HostListInfoIterEndResponse">
        <part element="na:HostListInfoIterEndResult" name="results"/>
    </message>
    <message name="HostListInfoIterNextRequest">
        <part element="na:HostListInfoIterNext" name="parameters"/>
    </message>
    <message name="HostListInfoIterNextResponse">
        <part element="na:HostListInfoIterNextResult" name="results"/>
    </message>
    <message name="HostListInfoIterStartRequest">
        <part element="na:HostListInfoIterStart" name="parameters"/>
    </message>
    <message name="HostListInfoIterStartResponse">
        <part element="na:HostListInfoIterStartResult" name="results"/>
    </message>
    <message name="HostModifyRequest">
        <part element="na:HostModify" name="parameters"/>
    </message>
    <message name="HostModifyResponse">
        <part element="na:HostModifyResult" name="results"/>
    </message>
    <message name="HostModifyAgentCredentialsRequest">
        <part element="na:HostModifyAgentCredentials" name="parameters"/>
    </message>
    <message name="HostModifyAgentCredentialsResponse">
        <part element="na:HostModifyAgentCredentialsResult" name="results"/>
    </message>
    <message name="HostRoleCreateRequest">
        <part element="na:HostRoleCreate" name="parameters"/>
    </message>
    <message name="HostRoleCreateResponse">
        <part element="na:HostRoleCreateResult" name="results"/>
    </message>
    <message name="HostRoleDeleteRequest">
        <part element="na:HostRoleDelete" name="parameters"/>
    </message>
    <message name="HostRoleDeleteResponse">
        <part element="na:HostRoleDeleteResult" name="results"/>
    </message>
    <message name="HostRoleListIterEndRequest">
        <part element="na:HostRoleListIterEnd" name="parameters"/>
    </message>
    <message name="HostRoleListIterEndResponse">
        <part element="na:HostRoleListIterEndResult" name="results"/>
    </message>
    <message name="HostRoleListIterNextRequest">
        <part element="na:HostRoleListIterNext" name="parameters"/>
    </message>
    <message name="HostRoleListIterNextResponse">
        <part element="na:HostRoleListIterNextResult" name="results"/>
    </message>
    <message name="HostRoleListIterStartRequest">
        <part element="na:HostRoleListIterStart" name="parameters"/>
    </message>
    <message name="HostRoleListIterStartResponse">
        <part element="na:HostRoleListIterStartResult" name="results"/>
    </message>
    <message name="HostRoleModifyRequest">
        <part element="na:HostRoleModify" name="parameters"/>
    </message>
    <message name="HostRoleModifyResponse">
        <part element="na:HostRoleModifyResult" name="results"/>
    </message>
    <message name="HostRolePushRequest">
        <part element="na:HostRolePush" name="parameters"/>
    </message>
    <message name="HostRolePushResponse">
        <part element="na:HostRolePushResult" name="results"/>
    </message>
    <message name="HostSetOptionRequest">
        <part element="na:HostSetOption" name="parameters"/>
    </message>
    <message name="HostSetOptionResponse">
        <part element="na:HostSetOptionResult" name="results"/>
    </message>
    <message name="HostUserAddRequest">
        <part element="na:HostUserAdd" name="parameters"/>
    </message>
    <message name="HostUserAddResponse">
        <part element="na:HostUserAddResult" name="results"/>
    </message>
    <message name="HostUserDeleteRequest">
        <part element="na:HostUserDelete" name="parameters"/>
    </message>
    <message name="HostUserDeleteResponse">
        <part element="na:HostUserDeleteResult" name="results"/>
    </message>
    <message name="HostUserListIterEndRequest">
        <part element="na:HostUserListIterEnd" name="parameters"/>
    </message>
    <message name="HostUserListIterEndResponse">
        <part element="na:HostUserListIterEndResult" name="results"/>
    </message>
    <message name="HostUserListIterNextRequest">
        <part element="na:HostUserListIterNext" name="parameters"/>
    </message>
    <message name="HostUserListIterNextResponse">
        <part element="na:HostUserListIterNextResult" name="results"/>
    </message>
    <message name="HostUserListIterStartRequest">
        <part element="na:HostUserListIterStart" name="parameters"/>
    </message>
    <message name="HostUserListIterStartResponse">
        <part element="na:HostUserListIterStartResult" name="results"/>
    </message>
    <message name="HostUserModifyRequest">
        <part element="na:HostUserModify" name="parameters"/>
    </message>
    <message name="HostUserModifyResponse">
        <part element="na:HostUserModifyResult" name="results"/>
    </message>
    <message name="HostUserModifyPasswordRequest">
        <part element="na:HostUserModifyPassword" name="parameters"/>
    </message>
    <message name="HostUserModifyPasswordResponse">
        <part element="na:HostUserModifyPasswordResult" name="results"/>
    </message>
    <message name="HostUserPushRequest">
        <part element="na:HostUserPush" name="parameters"/>
    </message>
    <message name="HostUserPushResponse">
        <part element="na:HostUserPushResult" name="results"/>
    </message>
    <message name="HostUsergroupCreateRequest">
        <part element="na:HostUsergroupCreate" name="parameters"/>
    </message>
    <message name="HostUsergroupCreateResponse">
        <part element="na:HostUsergroupCreateResult" name="results"/>
    </message>
    <message name="HostUsergroupDeleteRequest">
        <part element="na:HostUsergroupDelete" name="parameters"/>
    </message>
    <message name="HostUsergroupDeleteResponse">
        <part element="na:HostUsergroupDeleteResult" name="results"/>
    </message>
    <message name="HostUsergroupListIterEndRequest">
        <part element="na:HostUsergroupListIterEnd" name="parameters"/>
    </message>
    <message name="HostUsergroupListIterEndResponse">
        <part element="na:HostUsergroupListIterEndResult" name="results"/>
    </message>
    <message name="HostUsergroupListIterNextRequest">
        <part element="na:HostUsergroupListIterNext" name="parameters"/>
    </message>
    <message name="HostUsergroupListIterNextResponse">
        <part element="na:HostUsergroupListIterNextResult" name="results"/>
    </message>
    <message name="HostUsergroupListIterStartRequest">
        <part element="na:HostUsergroupListIterStart" name="parameters"/>
    </message>
    <message name="HostUsergroupListIterStartResponse">
        <part element="na:HostUsergroupListIterStartResult" name="results"/>
    </message>
    <message name="HostUsergroupModifyRequest">
        <part element="na:HostUsergroupModify" name="parameters"/>
    </message>
    <message name="HostUsergroupModifyResponse">
        <part element="na:HostUsergroupModifyResult" name="results"/>
    </message>
    <message name="HostUsergroupPushRequest">
        <part element="na:HostUsergroupPush" name="parameters"/>
    </message>
    <message name="HostUsergroupPushResponse">
        <part element="na:HostUsergroupPushResult" name="results"/>
    </message>
    <message name="IfcListInfoIterEndRequest">
        <part element="na:IfcListInfoIterEnd" name="parameters"/>
    </message>
    <message name="IfcListInfoIterEndResponse">
        <part element="na:IfcListInfoIterEndResult" name="results"/>
    </message>
    <message name="IfcListInfoIterNextRequest">
        <part element="na:IfcListInfoIterNext" name="parameters"/>
    </message>
    <message name="IfcListInfoIterNextResponse">
        <part element="na:IfcListInfoIterNextResult" name="results"/>
    </message>
    <message name="IfcListInfoIterStartRequest">
        <part element="na:IfcListInfoIterStart" name="parameters"/>
    </message>
    <message name="IfcListInfoIterStartResponse">
        <part element="na:IfcListInfoIterStartResult" name="results"/>
    </message>
    <message name="LunListInfoIterEndRequest">
        <part element="na:LunListInfoIterEnd" name="parameters"/>
    </message>
    <message name="LunListInfoIterEndResponse">
        <part element="na:LunListInfoIterEndResult" name="results"/>
    </message>
    <message name="LunListInfoIterNextRequest">
        <part element="na:LunListInfoIterNext" name="parameters"/>
    </message>
    <message name="LunListInfoIterNextResponse">
        <part element="na:LunListInfoIterNextResult" name="results"/>
    </message>
    <message name="LunListInfoIterStartRequest">
        <part element="na:LunListInfoIterStart" name="parameters"/>
    </message>
    <message name="LunListInfoIterStartResponse">
        <part element="na:LunListInfoIterStartResult" name="results"/>
    </message>
    <message name="MigrateCancelRequest">
        <part element="na:MigrateCancel" name="parameters"/>
    </message>
    <message name="MigrateCancelResponse">
        <part element="na:MigrateCancelResult" name="results"/>
    </message>
    <message name="MigrateChangeStateRequest">
        <part element="na:MigrateChangeState" name="parameters"/>
    </message>
    <message name="MigrateChangeStateResponse">
        <part element="na:MigrateChangeStateResult" name="results"/>
    </message>
    <message name="MigrateCleanupRequest">
        <part element="na:MigrateCleanup" name="parameters"/>
    </message>
    <message name="MigrateCleanupResponse">
        <part element="na:MigrateCleanupResult" name="results"/>
    </message>
    <message name="MigrateCompleteRequest">
        <part element="na:MigrateComplete" name="parameters"/>
    </message>
    <message name="MigrateCompleteResponse">
        <part element="na:MigrateCompleteResult" name="results"/>
    </message>
    <message name="MigrateFixRequest">
        <part element="na:MigrateFix" name="parameters"/>
    </message>
    <message name="MigrateFixResponse">
        <part element="na:MigrateFixResult" name="results"/>
    </message>
    <message name="MigrateRollbackRequest">
        <part element="na:MigrateRollback" name="parameters"/>
    </message>
    <message name="MigrateRollbackResponse">
        <part element="na:MigrateRollbackResult" name="results"/>
    </message>
    <message name="MigrateStartRequest">
        <part element="na:MigrateStart" name="parameters"/>
    </message>
    <message name="MigrateStartResponse">
        <part element="na:MigrateStartResult" name="results"/>
    </message>
    <message name="MigrateUpdateRequest">
        <part element="na:MigrateUpdate" name="parameters"/>
    </message>
    <message name="MigrateUpdateResponse">
        <part element="na:MigrateUpdateResult" name="results"/>
    </message>
    <message name="MigrateVolumeRequest">
        <part element="na:MigrateVolume" name="parameters"/>
    </message>
    <message name="MigrateVolumeResponse">
        <part element="na:MigrateVolumeResult" name="results"/>
    </message>
    <message name="NetifIpInterfaceListInfoRequest">
        <part element="na:NetifIpInterfaceListInfo" name="parameters"/>
    </message>
    <message name="NetifIpInterfaceListInfoResponse">
        <part element="na:NetifIpInterfaceListInfoResult" name="results"/>
    </message>
    <message name="PerfAssocViewListIterEndRequest">
        <part element="na:PerfAssocViewListIterEnd" name="parameters"/>
    </message>
    <message name="PerfAssocViewListIterEndResponse">
        <part element="na:PerfAssocViewListIterEndResult" name="results"/>
    </message>
    <message name="PerfAssocViewListIterNextRequest">
        <part element="na:PerfAssocViewListIterNext" name="parameters"/>
    </message>
    <message name="PerfAssocViewListIterNextResponse">
        <part element="na:PerfAssocViewListIterNextResult" name="results"/>
    </message>
    <message name="PerfAssocViewListIterStartRequest">
        <part element="na:PerfAssocViewListIterStart" name="parameters"/>
    </message>
    <message name="PerfAssocViewListIterStartResponse">
        <part element="na:PerfAssocViewListIterStartResult" name="results"/>
    </message>
    <message name="PerfClientStatsListInfoIterEndRequest">
        <part element="na:PerfClientStatsListInfoIterEnd" name="parameters"/>
    </message>
    <message name="PerfClientStatsListInfoIterEndResponse">
        <part element="na:PerfClientStatsListInfoIterEndResult" name="results"/>
    </message>
    <message name="PerfClientStatsListInfoIterNextRequest">
        <part element="na:PerfClientStatsListInfoIterNext" name="parameters"/>
    </message>
    <message name="PerfClientStatsListInfoIterNextResponse">
        <part element="na:PerfClientStatsListInfoIterNextResult" name="results"/>
    </message>
    <message name="PerfClientStatsListInfoIterStartRequest">
        <part element="na:PerfClientStatsListInfoIterStart" name="parameters"/>
    </message>
    <message name="PerfClientStatsListInfoIterStartResponse">
        <part element="na:PerfClientStatsListInfoIterStartResult" name="results"/>
    </message>
    <message name="PerfClientStatsPurgeRequest">
        <part element="na:PerfClientStatsPurge" name="parameters"/>
    </message>
    <message name="PerfClientStatsPurgeResponse">
        <part element="na:PerfClientStatsPurgeResult" name="results"/>
    </message>
    <message name="PerfCollectClientOperationStatisticsRequest">
        <part element="na:PerfCollectClientOperationStatistics" name="parameters"/>
    </message>
    <message name="PerfCollectClientOperationStatisticsResponse">
        <part element="na:PerfCollectClientOperationStatisticsResult" name="results"/>
    </message>
    <message name="PerfCopyCounterConfigurationRequest">
        <part element="na:PerfCopyCounterConfiguration" name="parameters"/>
    </message>
    <message name="PerfCopyCounterConfigurationResponse">
        <part element="na:PerfCopyCounterConfigurationResult" name="results"/>
    </message>
    <message name="PerfCounterGroupCreateRequest">
        <part element="na:PerfCounterGroupCreate" name="parameters"/>
    </message>
    <message name="PerfCounterGroupCreateResponse">
        <part element="na:PerfCounterGroupCreateResult" name="results"/>
    </message>
    <message name="PerfCounterGroupDestroyRequest">
        <part element="na:PerfCounterGroupDestroy" name="parameters"/>
    </message>
    <message name="PerfCounterGroupDestroyResponse">
        <part element="na:PerfCounterGroupDestroyResult" name="results"/>
    </message>
    <message name="PerfCounterGroupGetDataRequest">
        <part element="na:PerfCounterGroupGetData" name="parameters"/>
    </message>
    <message name="PerfCounterGroupGetDataResponse">
        <part element="na:PerfCounterGroupGetDataResult" name="results"/>
    </message>
    <message name="PerfCounterGroupGetDynamicDataSourcesRequest">
        <part element="na:PerfCounterGroupGetDynamicDataSources" name="parameters"/>
    </message>
    <message name="PerfCounterGroupGetDynamicDataSourcesResponse">
        <part element="na:PerfCounterGroupGetDynamicDataSourcesResult" name="results"/>
    </message>
    <message name="PerfCounterGroupListInfoRequest">
        <part element="na:PerfCounterGroupListInfo" name="parameters"/>
    </message>
    <message name="PerfCounterGroupListInfoResponse">
        <part element="na:PerfCounterGroupListInfoResult" name="results"/>
    </message>
    <message name="PerfCounterGroupListIterEndRequest">
        <part element="na:PerfCounterGroupListIterEnd" name="parameters"/>
    </message>
    <message name="PerfCounterGroupListIterEndResponse">
        <part element="na:PerfCounterGroupListIterEndResult" name="results"/>
    </message>
    <message name="PerfCounterGroupListIterNextRequest">
        <part element="na:PerfCounterGroupListIterNext" name="parameters"/>
    </message>
    <message name="PerfCounterGroupListIterNextResponse">
        <part element="na:PerfCounterGroupListIterNextResult" name="results"/>
    </message>
    <message name="PerfCounterGroupListIterStartRequest">
        <part element="na:PerfCounterGroupListIterStart" name="parameters"/>
    </message>
    <message name="PerfCounterGroupListIterStartResponse">
        <part element="na:PerfCounterGroupListIterStartResult" name="results"/>
    </message>
    <message name="PerfCounterGroupModifyRequest">
        <part element="na:PerfCounterGroupModify" name="parameters"/>
    </message>
    <message name="PerfCounterGroupModifyResponse">
        <part element="na:PerfCounterGroupModifyResult" name="results"/>
    </message>
    <message name="PerfCounterGroupStartRequest">
        <part element="na:PerfCounterGroupStart" name="parameters"/>
    </message>
    <message name="PerfCounterGroupStartResponse">
        <part element="na:PerfCounterGroupStartResult" name="results"/>
    </message>
    <message name="PerfCounterGroupStopRequest">
        <part element="na:PerfCounterGroupStop" name="parameters"/>
    </message>
    <message name="PerfCounterGroupStopResponse">
        <part element="na:PerfCounterGroupStopResult" name="results"/>
    </message>
    <message name="PerfDiagTroubleshootRequest">
        <part element="na:PerfDiagTroubleshoot" name="parameters"/>
    </message>
    <message name="PerfDiagTroubleshootResponse">
        <part element="na:PerfDiagTroubleshootResult" name="results"/>
    </message>
    <message name="PerfDisableDataCollectionRequest">
        <part element="na:PerfDisableDataCollection" name="parameters"/>
    </message>
    <message name="PerfDisableDataCollectionResponse">
        <part element="na:PerfDisableDataCollectionResult" name="results"/>
    </message>
    <message name="PerfDisableObjectUpdateRequest">
        <part element="na:PerfDisableObjectUpdate" name="parameters"/>
    </message>
    <message name="PerfDisableObjectUpdateResponse">
        <part element="na:PerfDisableObjectUpdateResult" name="results"/>
    </message>
    <message name="PerfEnableDataCollectionRequest">
        <part element="na:PerfEnableDataCollection" name="parameters"/>
    </message>
    <message name="PerfEnableDataCollectionResponse">
        <part element="na:PerfEnableDataCollectionResult" name="results"/>
    </message>
    <message name="PerfEnableObjectUpdateRequest">
        <part element="na:PerfEnableObjectUpdate" name="parameters"/>
    </message>
    <message name="PerfEnableObjectUpdateResponse">
        <part element="na:PerfEnableObjectUpdateResult" name="results"/>
    </message>
    <message name="PerfGetCounterDataRequest">
        <part element="na:PerfGetCounterData" name="parameters"/>
    </message>
    <message name="PerfGetCounterDataResponse">
        <part element="na:PerfGetCounterDataResult" name="results"/>
    </message>
    <message name="PerfGetCounterDependentsRequest">
        <part element="na:PerfGetCounterDependents" name="parameters"/>
    </message>
    <message name="PerfGetCounterDependentsResponse">
        <part element="na:PerfGetCounterDependentsResult" name="results"/>
    </message>
    <message name="PerfGetCounterListNotInViewRequest">
        <part element="na:PerfGetCounterListNotInView" name="parameters"/>
    </message>
    <message name="PerfGetCounterListNotInViewResponse">
        <part element="na:PerfGetCounterListNotInViewResult" name="results"/>
    </message>
    <message name="PerfGetDefaultViewRequest">
        <part element="na:PerfGetDefaultView" name="parameters"/>
    </message>
    <message name="PerfGetDefaultViewResponse">
        <part element="na:PerfGetDefaultViewResult" name="results"/>
    </message>
    <message name="PerfGetServerStatusRequest">
        <part element="na:PerfGetServerStatus" name="parameters"/>
    </message>
    <message name="PerfGetServerStatusResponse">
        <part element="na:PerfGetServerStatusResult" name="results"/>
    </message>
    <message name="PerfObjectCounterListInfoRequest">
        <part element="na:PerfObjectCounterListInfo" name="parameters"/>
    </message>
    <message name="PerfObjectCounterListInfoResponse">
        <part element="na:PerfObjectCounterListInfoResult" name="results"/>
    </message>
    <message name="PerfObjectDependentCounterListInfoRequest">
        <part element="na:PerfObjectDependentCounterListInfo" name="parameters"/>
    </message>
    <message name="PerfObjectDependentCounterListInfoResponse">
        <part element="na:PerfObjectDependentCounterListInfoResult" name="results"/>
    </message>
    <message name="PerfObjectInstanceListIterEndRequest">
        <part element="na:PerfObjectInstanceListIterEnd" name="parameters"/>
    </message>
    <message name="PerfObjectInstanceListIterEndResponse">
        <part element="na:PerfObjectInstanceListIterEndResult" name="results"/>
    </message>
    <message name="PerfObjectInstanceListIterNextRequest">
        <part element="na:PerfObjectInstanceListIterNext" name="parameters"/>
    </message>
    <message name="PerfObjectInstanceListIterNextResponse">
        <part element="na:PerfObjectInstanceListIterNextResult" name="results"/>
    </message>
    <message name="PerfObjectInstanceListIterStartRequest">
        <part element="na:PerfObjectInstanceListIterStart" name="parameters"/>
    </message>
    <message name="PerfObjectInstanceListIterStartResponse">
        <part element="na:PerfObjectInstanceListIterStartResult" name="results"/>
    </message>
    <message name="PerfObjectListInfoRequest">
        <part element="na:PerfObjectListInfo" name="parameters"/>
    </message>
    <message name="PerfObjectListInfoResponse">
        <part element="na:PerfObjectListInfoResult" name="results"/>
    </message>
    <message name="PerfSetDefaultViewRequest">
        <part element="na:PerfSetDefaultView" name="parameters"/>
    </message>
    <message name="PerfSetDefaultViewResponse">
        <part element="na:PerfSetDefaultViewResult" name="results"/>
    </message>
    <message name="PerfStatusGetRequest">
        <part element="na:PerfStatusGet" name="parameters"/>
    </message>
    <message name="PerfStatusGetResponse">
        <part element="na:PerfStatusGetResult" name="results"/>
    </message>
    <message name="PerfThresholdCreateRequest">
        <part element="na:PerfThresholdCreate" name="parameters"/>
    </message>
    <message name="PerfThresholdCreateResponse">
        <part element="na:PerfThresholdCreateResult" name="results"/>
    </message>
    <message name="PerfThresholdCreate2Request">
        <part element="na:PerfThresholdCreate2" name="parameters"/>
    </message>
    <message name="PerfThresholdCreate2Response">
        <part element="na:PerfThresholdCreate2Result" name="results"/>
    </message>
    <message name="PerfThresholdDeleteRequest">
        <part element="na:PerfThresholdDelete" name="parameters"/>
    </message>
    <message name="PerfThresholdDeleteResponse">
        <part element="na:PerfThresholdDeleteResult" name="results"/>
    </message>
    <message name="PerfThresholdListInfoIterEndRequest">
        <part element="na:PerfThresholdListInfoIterEnd" name="parameters"/>
    </message>
    <message name="PerfThresholdListInfoIterEndResponse">
        <part element="na:PerfThresholdListInfoIterEndResult" name="results"/>
    </message>
    <message name="PerfThresholdListInfoIterNextRequest">
        <part element="na:PerfThresholdListInfoIterNext" name="parameters"/>
    </message>
    <message name="PerfThresholdListInfoIterNextResponse">
        <part element="na:PerfThresholdListInfoIterNextResult" name="results"/>
    </message>
    <message name="PerfThresholdListInfoIterStartRequest">
        <part element="na:PerfThresholdListInfoIterStart" name="parameters"/>
    </message>
    <message name="PerfThresholdListInfoIterStartResponse">
        <part element="na:PerfThresholdListInfoIterStartResult" name="results"/>
    </message>
    <message name="PerfThresholdListInfo2IterEndRequest">
        <part element="na:PerfThresholdListInfo2IterEnd" name="parameters"/>
    </message>
    <message name="PerfThresholdListInfo2IterEndResponse">
        <part element="na:PerfThresholdListInfo2IterEndResult" name="results"/>
    </message>
    <message name="PerfThresholdListInfo2IterNextRequest">
        <part element="na:PerfThresholdListInfo2IterNext" name="parameters"/>
    </message>
    <message name="PerfThresholdListInfo2IterNextResponse">
        <part element="na:PerfThresholdListInfo2IterNextResult" name="results"/>
    </message>
    <message name="PerfThresholdListInfo2IterStartRequest">
        <part element="na:PerfThresholdListInfo2IterStart" name="parameters"/>
    </message>
    <message name="PerfThresholdListInfo2IterStartResponse">
        <part element="na:PerfThresholdListInfo2IterStartResult" name="results"/>
    </message>
    <message name="PerfThresholdModifyRequest">
        <part element="na:PerfThresholdModify" name="parameters"/>
    </message>
    <message name="PerfThresholdModifyResponse">
        <part element="na:PerfThresholdModifyResult" name="results"/>
    </message>
    <message name="PerfThresholdModify2Request">
        <part element="na:PerfThresholdModify2" name="parameters"/>
    </message>
    <message name="PerfThresholdModify2Response">
        <part element="na:PerfThresholdModify2Result" name="results"/>
    </message>
    <message name="PerfThresholdTemplateAttachObjectsRequest">
        <part element="na:PerfThresholdTemplateAttachObjects" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateAttachObjectsResponse">
        <part element="na:PerfThresholdTemplateAttachObjectsResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateCreateRequest">
        <part element="na:PerfThresholdTemplateCreate" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateCreateResponse">
        <part element="na:PerfThresholdTemplateCreateResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateDeleteRequest">
        <part element="na:PerfThresholdTemplateDelete" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateDeleteResponse">
        <part element="na:PerfThresholdTemplateDeleteResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateDetachObjectsRequest">
        <part element="na:PerfThresholdTemplateDetachObjects" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateDetachObjectsResponse">
        <part element="na:PerfThresholdTemplateDetachObjectsResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateListInfoIterEndRequest">
        <part element="na:PerfThresholdTemplateListInfoIterEnd" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateListInfoIterEndResponse">
        <part element="na:PerfThresholdTemplateListInfoIterEndResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateListInfoIterNextRequest">
        <part element="na:PerfThresholdTemplateListInfoIterNext" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateListInfoIterNextResponse">
        <part element="na:PerfThresholdTemplateListInfoIterNextResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateListInfoIterStartRequest">
        <part element="na:PerfThresholdTemplateListInfoIterStart" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateListInfoIterStartResponse">
        <part element="na:PerfThresholdTemplateListInfoIterStartResult" name="results"/>
    </message>
    <message name="PerfThresholdTemplateModifyRequest">
        <part element="na:PerfThresholdTemplateModify" name="parameters"/>
    </message>
    <message name="PerfThresholdTemplateModifyResponse">
        <part element="na:PerfThresholdTemplateModifyResult" name="results"/>
    </message>
    <message name="PerfViewAssociatedObjectsListRequest">
        <part element="na:PerfViewAssociatedObjectsList" name="parameters"/>
    </message>
    <message name="PerfViewAssociatedObjectsListResponse">
        <part element="na:PerfViewAssociatedObjectsListResult" name="results"/>
    </message>
    <message name="PerfViewCreateRequest">
        <part element="na:PerfViewCreate" name="parameters"/>
    </message>
    <message name="PerfViewCreateResponse">
        <part element="na:PerfViewCreateResult" name="results"/>
    </message>
    <message name="PerfViewDestroyRequest">
        <part element="na:PerfViewDestroy" name="parameters"/>
    </message>
    <message name="PerfViewDestroyResponse">
        <part element="na:PerfViewDestroyResult" name="results"/>
    </message>
    <message name="PerfViewGetDataRequest">
        <part element="na:PerfViewGetData" name="parameters"/>
    </message>
    <message name="PerfViewGetDataResponse">
        <part element="na:PerfViewGetDataResult" name="results"/>
    </message>
    <message name="PerfViewListIterEndRequest">
        <part element="na:PerfViewListIterEnd" name="parameters"/>
    </message>
    <message name="PerfViewListIterEndResponse">
        <part element="na:PerfViewListIterEndResult" name="results"/>
    </message>
    <message name="PerfViewListIterNextRequest">
        <part element="na:PerfViewListIterNext" name="parameters"/>
    </message>
    <message name="PerfViewListIterNextResponse">
        <part element="na:PerfViewListIterNextResult" name="results"/>
    </message>
    <message name="PerfViewListIterStartRequest">
        <part element="na:PerfViewListIterStart" name="parameters"/>
    </message>
    <message name="PerfViewListIterStartResponse">
        <part element="na:PerfViewListIterStartResult" name="results"/>
    </message>
    <message name="PerfViewModifyRequest">
        <part element="na:PerfViewModify" name="parameters"/>
    </message>
    <message name="PerfViewModifyResponse">
        <part element="na:PerfViewModifyResult" name="results"/>
    </message>
    <message name="PerfViewObjectAssociationAddRequest">
        <part element="na:PerfViewObjectAssociationAdd" name="parameters"/>
    </message>
    <message name="PerfViewObjectAssociationAddResponse">
        <part element="na:PerfViewObjectAssociationAddResult" name="results"/>
    </message>
    <message name="PerfViewObjectAssociationDeleteRequest">
        <part element="na:PerfViewObjectAssociationDelete" name="parameters"/>
    </message>
    <message name="PerfViewObjectAssociationDeleteResponse">
        <part element="na:PerfViewObjectAssociationDeleteResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyCopyRequest">
        <part element="na:ProvisioningPolicyCopy" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyCopyResponse">
        <part element="na:ProvisioningPolicyCopyResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyCreateRequest">
        <part element="na:ProvisioningPolicyCreate" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyCreateResponse">
        <part element="na:ProvisioningPolicyCreateResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyDestroyRequest">
        <part element="na:ProvisioningPolicyDestroy" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyDestroyResponse">
        <part element="na:ProvisioningPolicyDestroyResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyEditBeginRequest">
        <part element="na:ProvisioningPolicyEditBegin" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyEditBeginResponse">
        <part element="na:ProvisioningPolicyEditBeginResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyEditCommitRequest">
        <part element="na:ProvisioningPolicyEditCommit" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyEditCommitResponse">
        <part element="na:ProvisioningPolicyEditCommitResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyEditRollbackRequest">
        <part element="na:ProvisioningPolicyEditRollback" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyEditRollbackResponse">
        <part element="na:ProvisioningPolicyEditRollbackResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyListIterEndRequest">
        <part element="na:ProvisioningPolicyListIterEnd" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyListIterEndResponse">
        <part element="na:ProvisioningPolicyListIterEndResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyListIterNextRequest">
        <part element="na:ProvisioningPolicyListIterNext" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyListIterNextResponse">
        <part element="na:ProvisioningPolicyListIterNextResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyListIterStartRequest">
        <part element="na:ProvisioningPolicyListIterStart" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyListIterStartResponse">
        <part element="na:ProvisioningPolicyListIterStartResult" name="results"/>
    </message>
    <message name="ProvisioningPolicyModifyRequest">
        <part element="na:ProvisioningPolicyModify" name="parameters"/>
    </message>
    <message name="ProvisioningPolicyModifyResponse">
        <part element="na:ProvisioningPolicyModifyResult" name="results"/>
    </message>
    <message name="QtreeListInfoIterEndRequest">
        <part element="na:QtreeListInfoIterEnd" name="parameters"/>
    </message>
    <message name="QtreeListInfoIterEndResponse">
        <part element="na:QtreeListInfoIterEndResult" name="results"/>
    </message>
    <message name="QtreeListInfoIterNextRequest">
        <part element="na:QtreeListInfoIterNext" name="parameters"/>
    </message>
    <message name="QtreeListInfoIterNextResponse">
        <part element="na:QtreeListInfoIterNextResult" name="results"/>
    </message>
    <message name="QtreeListInfoIterStartRequest">
        <part element="na:QtreeListInfoIterStart" name="parameters"/>
    </message>
    <message name="QtreeListInfoIterStartResponse">
        <part element="na:QtreeListInfoIterStartResult" name="results"/>
    </message>
    <message name="QtreeModifyRequest">
        <part element="na:QtreeModify" name="parameters"/>
    </message>
    <message name="QtreeModifyResponse">
        <part element="na:QtreeModifyResult" name="results"/>
    </message>
    <message name="QtreeRenameRequest">
        <part element="na:QtreeRename" name="parameters"/>
    </message>
    <message name="QtreeRenameResponse">
        <part element="na:QtreeRenameResult" name="results"/>
    </message>
    <message name="QtreeStartMonitoringRequest">
        <part element="na:QtreeStartMonitoring" name="parameters"/>
    </message>
    <message name="QtreeStartMonitoringResponse">
        <part element="na:QtreeStartMonitoringResult" name="results"/>
    </message>
    <message name="QtreeStopMonitoringRequest">
        <part element="na:QtreeStopMonitoring" name="parameters"/>
    </message>
    <message name="QtreeStopMonitoringResponse">
        <part element="na:QtreeStopMonitoringResult" name="results"/>
    </message>
    <message name="RbacAccessCheckRequest">
        <part element="na:RbacAccessCheck" name="parameters"/>
    </message>
    <message name="RbacAccessCheckResponse">
        <part element="na:RbacAccessCheckResult" name="results"/>
    </message>
    <message name="RbacAdminListInfoIterEndRequest">
        <part element="na:RbacAdminListInfoIterEnd" name="parameters"/>
    </message>
    <message name="RbacAdminListInfoIterEndResponse">
        <part element="na:RbacAdminListInfoIterEndResult" name="results"/>
    </message>
    <message name="RbacAdminListInfoIterNextRequest">
        <part element="na:RbacAdminListInfoIterNext" name="parameters"/>
    </message>
    <message name="RbacAdminListInfoIterNextResponse">
        <part element="na:RbacAdminListInfoIterNextResult" name="results"/>
    </message>
    <message name="RbacAdminListInfoIterStartRequest">
        <part element="na:RbacAdminListInfoIterStart" name="parameters"/>
    </message>
    <message name="RbacAdminListInfoIterStartResponse">
        <part element="na:RbacAdminListInfoIterStartResult" name="results"/>
    </message>
    <message name="RbacAdminRoleAddRequest">
        <part element="na:RbacAdminRoleAdd" name="parameters"/>
    </message>
    <message name="RbacAdminRoleAddResponse">
        <part element="na:RbacAdminRoleAddResult" name="results"/>
    </message>
    <message name="RbacAdminRoleInfoListRequest">
        <part element="na:RbacAdminRoleInfoList" name="parameters"/>
    </message>
    <message name="RbacAdminRoleInfoListResponse">
        <part element="na:RbacAdminRoleInfoListResult" name="results"/>
    </message>
    <message name="RbacAdminRoleRemoveRequest">
        <part element="na:RbacAdminRoleRemove" name="parameters"/>
    </message>
    <message name="RbacAdminRoleRemoveResponse">
        <part element="na:RbacAdminRoleRemoveResult" name="results"/>
    </message>
    <message name="RbacOperationAddRequest">
        <part element="na:RbacOperationAdd" name="parameters"/>
    </message>
    <message name="RbacOperationAddResponse">
        <part element="na:RbacOperationAddResult" name="results"/>
    </message>
    <message name="RbacOperationDeleteRequest">
        <part element="na:RbacOperationDelete" name="parameters"/>
    </message>
    <message name="RbacOperationDeleteResponse">
        <part element="na:RbacOperationDeleteResult" name="results"/>
    </message>
    <message name="RbacOperationInfoListRequest">
        <part element="na:RbacOperationInfoList" name="parameters"/>
    </message>
    <message name="RbacOperationInfoListResponse">
        <part element="na:RbacOperationInfoListResult" name="results"/>
    </message>
    <message name="RbacRoleAddRequest">
        <part element="na:RbacRoleAdd" name="parameters"/>
    </message>
    <message name="RbacRoleAddResponse">
        <part element="na:RbacRoleAddResult" name="results"/>
    </message>
    <message name="RbacRoleAdminInfoListRequest">
        <part element="na:RbacRoleAdminInfoList" name="parameters"/>
    </message>
    <message name="RbacRoleAdminInfoListResponse">
        <part element="na:RbacRoleAdminInfoListResult" name="results"/>
    </message>
    <message name="RbacRoleCapabilityAddRequest">
        <part element="na:RbacRoleCapabilityAdd" name="parameters"/>
    </message>
    <message name="RbacRoleCapabilityAddResponse">
        <part element="na:RbacRoleCapabilityAddResult" name="results"/>
    </message>
    <message name="RbacRoleCapabilityRemoveRequest">
        <part element="na:RbacRoleCapabilityRemove" name="parameters"/>
    </message>
    <message name="RbacRoleCapabilityRemoveResponse">
        <part element="na:RbacRoleCapabilityRemoveResult" name="results"/>
    </message>
    <message name="RbacRoleDeleteRequest">
        <part element="na:RbacRoleDelete" name="parameters"/>
    </message>
    <message name="RbacRoleDeleteResponse">
        <part element="na:RbacRoleDeleteResult" name="results"/>
    </message>
    <message name="RbacRoleDisinheritRequest">
        <part element="na:RbacRoleDisinherit" name="parameters"/>
    </message>
    <message name="RbacRoleDisinheritResponse">
        <part element="na:RbacRoleDisinheritResult" name="results"/>
    </message>
    <message name="RbacRoleInfoListRequest">
        <part element="na:RbacRoleInfoList" name="parameters"/>
    </message>
    <message name="RbacRoleInfoListResponse">
        <part element="na:RbacRoleInfoListResult" name="results"/>
    </message>
    <message name="RbacRoleInheritRequest">
        <part element="na:RbacRoleInherit" name="parameters"/>
    </message>
    <message name="RbacRoleInheritResponse">
        <part element="na:RbacRoleInheritResult" name="results"/>
    </message>
    <message name="RbacRoleModifyRequest">
        <part element="na:RbacRoleModify" name="parameters"/>
    </message>
    <message name="RbacRoleModifyResponse">
        <part element="na:RbacRoleModifyResult" name="results"/>
    </message>
    <message name="ReportGraphListInfoIterEndRequest">
        <part element="na:ReportGraphListInfoIterEnd" name="parameters"/>
    </message>
    <message name="ReportGraphListInfoIterEndResponse">
        <part element="na:ReportGraphListInfoIterEndResult" name="results"/>
    </message>
    <message name="ReportGraphListInfoIterNextRequest">
        <part element="na:ReportGraphListInfoIterNext" name="parameters"/>
    </message>
    <message name="ReportGraphListInfoIterNextResponse">
        <part element="na:ReportGraphListInfoIterNextResult" name="results"/>
    </message>
    <message name="ReportGraphListInfoIterStartRequest">
        <part element="na:ReportGraphListInfoIterStart" name="parameters"/>
    </message>
    <message name="ReportGraphListInfoIterStartResponse">
        <part element="na:ReportGraphListInfoIterStartResult" name="results"/>
    </message>
    <message name="ReportListInfoIterEndRequest">
        <part element="na:ReportListInfoIterEnd" name="parameters"/>
    </message>
    <message name="ReportListInfoIterEndResponse">
        <part element="na:ReportListInfoIterEndResult" name="results"/>
    </message>
    <message name="ReportListInfoIterNextRequest">
        <part element="na:ReportListInfoIterNext" name="parameters"/>
    </message>
    <message name="ReportListInfoIterNextResponse">
        <part element="na:ReportListInfoIterNextResult" name="results"/>
    </message>
    <message name="ReportListInfoIterStartRequest">
        <part element="na:ReportListInfoIterStart" name="parameters"/>
    </message>
    <message name="ReportListInfoIterStartResponse">
        <part element="na:ReportListInfoIterStartResult" name="results"/>
    </message>
    <message name="ReportOutputDeleteRequest">
        <part element="na:ReportOutputDelete" name="parameters"/>
    </message>
    <message name="ReportOutputDeleteResponse">
        <part element="na:ReportOutputDeleteResult" name="results"/>
    </message>
    <message name="ReportOutputListInfoIterEndRequest">
        <part element="na:ReportOutputListInfoIterEnd" name="parameters"/>
    </message>
    <message name="ReportOutputListInfoIterEndResponse">
        <part element="na:ReportOutputListInfoIterEndResult" name="results"/>
    </message>
    <message name="ReportOutputListInfoIterNextRequest">
        <part element="na:ReportOutputListInfoIterNext" name="parameters"/>
    </message>
    <message name="ReportOutputListInfoIterNextResponse">
        <part element="na:ReportOutputListInfoIterNextResult" name="results"/>
    </message>
    <message name="ReportOutputListInfoIterStartRequest">
        <part element="na:ReportOutputListInfoIterStart" name="parameters"/>
    </message>
    <message name="ReportOutputListInfoIterStartResponse">
        <part element="na:ReportOutputListInfoIterStartResult" name="results"/>
    </message>
    <message name="ReportOutputReadRequest">
        <part element="na:ReportOutputRead" name="parameters"/>
    </message>
    <message name="ReportOutputReadResponse">
        <part element="na:ReportOutputReadResult" name="results"/>
    </message>
    <message name="ReportScheduleAddRequest">
        <part element="na:ReportScheduleAdd" name="parameters"/>
    </message>
    <message name="ReportScheduleAddResponse">
        <part element="na:ReportScheduleAddResult" name="results"/>
    </message>
    <message name="ReportScheduleDeleteRequest">
        <part element="na:ReportScheduleDelete" name="parameters"/>
    </message>
    <message name="ReportScheduleDeleteResponse">
        <part element="na:ReportScheduleDeleteResult" name="results"/>
    </message>
    <message name="ReportScheduleDisableRequest">
        <part element="na:ReportScheduleDisable" name="parameters"/>
    </message>
    <message name="ReportScheduleDisableResponse">
        <part element="na:ReportScheduleDisableResult" name="results"/>
    </message>
    <message name="ReportScheduleEnableRequest">
        <part element="na:ReportScheduleEnable" name="parameters"/>
    </message>
    <message name="ReportScheduleEnableResponse">
        <part element="na:ReportScheduleEnableResult" name="results"/>
    </message>
    <message name="ReportScheduleListInfoIterEndRequest">
        <part element="na:ReportScheduleListInfoIterEnd" name="parameters"/>
    </message>
    <message name="ReportScheduleListInfoIterEndResponse">
        <part element="na:ReportScheduleListInfoIterEndResult" name="results"/>
    </message>
    <message name="ReportScheduleListInfoIterNextRequest">
        <part element="na:ReportScheduleListInfoIterNext" name="parameters"/>
    </message>
    <message name="ReportScheduleListInfoIterNextResponse">
        <part element="na:ReportScheduleListInfoIterNextResult" name="results"/>
    </message>
    <message name="ReportScheduleListInfoIterStartRequest">
        <part element="na:ReportScheduleListInfoIterStart" name="parameters"/>
    </message>
    <message name="ReportScheduleListInfoIterStartResponse">
        <part element="na:ReportScheduleListInfoIterStartResult" name="results"/>
    </message>
    <message name="ReportScheduleModifyRequest">
        <part element="na:ReportScheduleModify" name="parameters"/>
    </message>
    <message name="ReportScheduleModifyResponse">
        <part element="na:ReportScheduleModifyResult" name="results"/>
    </message>
    <message name="ReportScheduleRunRequest">
        <part element="na:ReportScheduleRun" name="parameters"/>
    </message>
    <message name="ReportScheduleRunResponse">
        <part element="na:ReportScheduleRunResult" name="results"/>
    </message>
    <message name="ResourcepoolAddMemberRequest">
        <part element="na:ResourcepoolAddMember" name="parameters"/>
    </message>
    <message name="ResourcepoolAddMemberResponse">
        <part element="na:ResourcepoolAddMemberResult" name="results"/>
    </message>
    <message name="ResourcepoolCreateRequest">
        <part element="na:ResourcepoolCreate" name="parameters"/>
    </message>
    <message name="ResourcepoolCreateResponse">
        <part element="na:ResourcepoolCreateResult" name="results"/>
    </message>
    <message name="ResourcepoolDestroyRequest">
        <part element="na:ResourcepoolDestroy" name="parameters"/>
    </message>
    <message name="ResourcepoolDestroyResponse">
        <part element="na:ResourcepoolDestroyResult" name="results"/>
    </message>
    <message name="ResourcepoolGetDefaultsRequest">
        <part element="na:ResourcepoolGetDefaults" name="parameters"/>
    </message>
    <message name="ResourcepoolGetDefaultsResponse">
        <part element="na:ResourcepoolGetDefaultsResult" name="results"/>
    </message>
    <message name="ResourcepoolListInfoIterEndRequest">
        <part element="na:ResourcepoolListInfoIterEnd" name="parameters"/>
    </message>
    <message name="ResourcepoolListInfoIterEndResponse">
        <part element="na:ResourcepoolListInfoIterEndResult" name="results"/>
    </message>
    <message name="ResourcepoolListInfoIterNextRequest">
        <part element="na:ResourcepoolListInfoIterNext" name="parameters"/>
    </message>
    <message name="ResourcepoolListInfoIterNextResponse">
        <part element="na:ResourcepoolListInfoIterNextResult" name="results"/>
    </message>
    <message name="ResourcepoolListInfoIterStartRequest">
        <part element="na:ResourcepoolListInfoIterStart" name="parameters"/>
    </message>
    <message name="ResourcepoolListInfoIterStartResponse">
        <part element="na:ResourcepoolListInfoIterStartResult" name="results"/>
    </message>
    <message name="ResourcepoolMemberListInfoIterEndRequest">
        <part element="na:ResourcepoolMemberListInfoIterEnd" name="parameters"/>
    </message>
    <message name="ResourcepoolMemberListInfoIterEndResponse">
        <part element="na:ResourcepoolMemberListInfoIterEndResult" name="results"/>
    </message>
    <message name="ResourcepoolMemberListInfoIterNextRequest">
        <part element="na:ResourcepoolMemberListInfoIterNext" name="parameters"/>
    </message>
    <message name="ResourcepoolMemberListInfoIterNextResponse">
        <part element="na:ResourcepoolMemberListInfoIterNextResult" name="results"/>
    </message>
    <message name="ResourcepoolMemberListInfoIterStartRequest">
        <part element="na:ResourcepoolMemberListInfoIterStart" name="parameters"/>
    </message>
    <message name="ResourcepoolMemberListInfoIterStartResponse">
        <part element="na:ResourcepoolMemberListInfoIterStartResult" name="results"/>
    </message>
    <message name="ResourcepoolModifyRequest">
        <part element="na:ResourcepoolModify" name="parameters"/>
    </message>
    <message name="ResourcepoolModifyResponse">
        <part element="na:ResourcepoolModifyResult" name="results"/>
    </message>
    <message name="ResourcepoolModifyMemberRequest">
        <part element="na:ResourcepoolModifyMember" name="parameters"/>
    </message>
    <message name="ResourcepoolModifyMemberResponse">
        <part element="na:ResourcepoolModifyMemberResult" name="results"/>
    </message>
    <message name="ResourcepoolRemoveMemberRequest">
        <part element="na:ResourcepoolRemoveMember" name="parameters"/>
    </message>
    <message name="ResourcepoolRemoveMemberResponse">
        <part element="na:ResourcepoolRemoveMemberResult" name="results"/>
    </message>
    <message name="ResourcepoolUpdateFreeSpaceStatusRequest">
        <part element="na:ResourcepoolUpdateFreeSpaceStatus" name="parameters"/>
    </message>
    <message name="ResourcepoolUpdateFreeSpaceStatusResponse">
        <part element="na:ResourcepoolUpdateFreeSpaceStatusResult" name="results"/>
    </message>
    <message name="SnapshotGetReclaimableInfoRequest">
        <part element="na:SnapshotGetReclaimableInfo" name="parameters"/>
    </message>
    <message name="SnapshotGetReclaimableInfoResponse">
        <part element="na:SnapshotGetReclaimableInfoResult" name="results"/>
    </message>
    <message name="SnapshotListInfoIterEndRequest">
        <part element="na:SnapshotListInfoIterEnd" name="parameters"/>
    </message>
    <message name="SnapshotListInfoIterEndResponse">
        <part element="na:SnapshotListInfoIterEndResult" name="results"/>
    </message>
    <message name="SnapshotListInfoIterNextRequest">
        <part element="na:SnapshotListInfoIterNext" name="parameters"/>
    </message>
    <message name="SnapshotListInfoIterNextResponse">
        <part element="na:SnapshotListInfoIterNextResult" name="results"/>
    </message>
    <message name="SnapshotListInfoIterStartRequest">
        <part element="na:SnapshotListInfoIterStart" name="parameters"/>
    </message>
    <message name="SnapshotListInfoIterStartResponse">
        <part element="na:SnapshotListInfoIterStartResult" name="results"/>
    </message>
    <message name="StorageServiceCreateRequest">
        <part element="na:StorageServiceCreate" name="parameters"/>
    </message>
    <message name="StorageServiceCreateResponse">
        <part element="na:StorageServiceCreateResult" name="results"/>
    </message>
    <message name="StorageServiceDatasetListIterEndRequest">
        <part element="na:StorageServiceDatasetListIterEnd" name="parameters"/>
    </message>
    <message name="StorageServiceDatasetListIterEndResponse">
        <part element="na:StorageServiceDatasetListIterEndResult" name="results"/>
    </message>
    <message name="StorageServiceDatasetListIterNextRequest">
        <part element="na:StorageServiceDatasetListIterNext" name="parameters"/>
    </message>
    <message name="StorageServiceDatasetListIterNextResponse">
        <part element="na:StorageServiceDatasetListIterNextResult" name="results"/>
    </message>
    <message name="StorageServiceDatasetListIterStartRequest">
        <part element="na:StorageServiceDatasetListIterStart" name="parameters"/>
    </message>
    <message name="StorageServiceDatasetListIterStartResponse">
        <part element="na:StorageServiceDatasetListIterStartResult" name="results"/>
    </message>
    <message name="StorageServiceDatasetModifyRequest">
        <part element="na:StorageServiceDatasetModify" name="parameters"/>
    </message>
    <message name="StorageServiceDatasetModifyResponse">
        <part element="na:StorageServiceDatasetModifyResult" name="results"/>
    </message>
    <message name="StorageServiceDatasetProvisionRequest">
        <part element="na:StorageServiceDatasetProvision" name="parameters"/>
    </message>
    <message name="StorageServiceDatasetProvisionResponse">
        <part element="na:StorageServiceDatasetProvisionResult" name="results"/>
    </message>
    <message name="StorageServiceDestroyRequest">
        <part element="na:StorageServiceDestroy" name="parameters"/>
    </message>
    <message name="StorageServiceDestroyResponse">
        <part element="na:StorageServiceDestroyResult" name="results"/>
    </message>
    <message name="StorageServiceListInfoIterEndRequest">
        <part element="na:StorageServiceListInfoIterEnd" name="parameters"/>
    </message>
    <message name="StorageServiceListInfoIterEndResponse">
        <part element="na:StorageServiceListInfoIterEndResult" name="results"/>
    </message>
    <message name="StorageServiceListInfoIterNextRequest">
        <part element="na:StorageServiceListInfoIterNext" name="parameters"/>
    </message>
    <message name="StorageServiceListInfoIterNextResponse">
        <part element="na:StorageServiceListInfoIterNextResult" name="results"/>
    </message>
    <message name="StorageServiceListInfoIterStartRequest">
        <part element="na:StorageServiceListInfoIterStart" name="parameters"/>
    </message>
    <message name="StorageServiceListInfoIterStartResponse">
        <part element="na:StorageServiceListInfoIterStartResult" name="results"/>
    </message>
    <message name="StorageServiceModifyRequest">
        <part element="na:StorageServiceModify" name="parameters"/>
    </message>
    <message name="StorageServiceModifyResponse">
        <part element="na:StorageServiceModifyResult" name="results"/>
    </message>
    <message name="TimezoneGetDefaultsRequest">
        <part element="na:TimezoneGetDefaults" name="parameters"/>
    </message>
    <message name="TimezoneGetDefaultsResponse">
        <part element="na:TimezoneGetDefaultsResult" name="results"/>
    </message>
    <message name="TimezoneListInfoIterEndRequest">
        <part element="na:TimezoneListInfoIterEnd" name="parameters"/>
    </message>
    <message name="TimezoneListInfoIterEndResponse">
        <part element="na:TimezoneListInfoIterEndResult" name="results"/>
    </message>
    <message name="TimezoneListInfoIterNextRequest">
        <part element="na:TimezoneListInfoIterNext" name="parameters"/>
    </message>
    <message name="TimezoneListInfoIterNextResponse">
        <part element="na:TimezoneListInfoIterNextResult" name="results"/>
    </message>
    <message name="TimezoneListInfoIterStartRequest">
        <part element="na:TimezoneListInfoIterStart" name="parameters"/>
    </message>
    <message name="TimezoneListInfoIterStartResponse">
        <part element="na:TimezoneListInfoIterStartResult" name="results"/>
    </message>
    <message name="TimezoneValidateRequest">
        <part element="na:TimezoneValidate" name="parameters"/>
    </message>
    <message name="TimezoneValidateResponse">
        <part element="na:TimezoneValidateResult" name="results"/>
    </message>
    <message name="UserFavoriteReportDeleteRequest">
        <part element="na:UserFavoriteReportDelete" name="parameters"/>
    </message>
    <message name="UserFavoriteReportDeleteResponse">
        <part element="na:UserFavoriteReportDeleteResult" name="results"/>
    </message>
    <message name="UserFavoriteReportListInfoIterEndRequest">
        <part element="na:UserFavoriteReportListInfoIterEnd" name="parameters"/>
    </message>
    <message name="UserFavoriteReportListInfoIterEndResponse">
        <part element="na:UserFavoriteReportListInfoIterEndResult" name="results"/>
    </message>
    <message name="UserFavoriteReportListInfoIterNextRequest">
        <part element="na:UserFavoriteReportListInfoIterNext" name="parameters"/>
    </message>
    <message name="UserFavoriteReportListInfoIterNextResponse">
        <part element="na:UserFavoriteReportListInfoIterNextResult" name="results"/>
    </message>
    <message name="UserFavoriteReportListInfoIterStartRequest">
        <part element="na:UserFavoriteReportListInfoIterStart" name="parameters"/>
    </message>
    <message name="UserFavoriteReportListInfoIterStartResponse">
        <part element="na:UserFavoriteReportListInfoIterStartResult" name="results"/>
    </message>
    <message name="UserRecentReportDeleteRequest">
        <part element="na:UserRecentReportDelete" name="parameters"/>
    </message>
    <message name="UserRecentReportDeleteResponse">
        <part element="na:UserRecentReportDeleteResult" name="results"/>
    </message>
    <message name="UserRecentReportListInfoIterEndRequest">
        <part element="na:UserRecentReportListInfoIterEnd" name="parameters"/>
    </message>
    <message name="UserRecentReportListInfoIterEndResponse">
        <part element="na:UserRecentReportListInfoIterEndResult" name="results"/>
    </message>
    <message name="UserRecentReportListInfoIterNextRequest">
        <part element="na:UserRecentReportListInfoIterNext" name="parameters"/>
    </message>
    <message name="UserRecentReportListInfoIterNextResponse">
        <part element="na:UserRecentReportListInfoIterNextResult" name="results"/>
    </message>
    <message name="UserRecentReportListInfoIterStartRequest">
        <part element="na:UserRecentReportListInfoIterStart" name="parameters"/>
    </message>
    <message name="UserRecentReportListInfoIterStartResponse">
        <part element="na:UserRecentReportListInfoIterStartResult" name="results"/>
    </message>
    <message name="VfilerCreateRequest">
        <part element="na:VfilerCreate" name="parameters"/>
    </message>
    <message name="VfilerCreateResponse">
        <part element="na:VfilerCreateResult" name="results"/>
    </message>
    <message name="VfilerDestroyRequest">
        <part element="na:VfilerDestroy" name="parameters"/>
    </message>
    <message name="VfilerDestroyResponse">
        <part element="na:VfilerDestroyResult" name="results"/>
    </message>
    <message name="VfilerSetupRequest">
        <part element="na:VfilerSetup" name="parameters"/>
    </message>
    <message name="VfilerSetupResponse">
        <part element="na:VfilerSetupResult" name="results"/>
    </message>
    <message name="VfilerTemplateCopyRequest">
        <part element="na:VfilerTemplateCopy" name="parameters"/>
    </message>
    <message name="VfilerTemplateCopyResponse">
        <part element="na:VfilerTemplateCopyResult" name="results"/>
    </message>
    <message name="VfilerTemplateCreateRequest">
        <part element="na:VfilerTemplateCreate" name="parameters"/>
    </message>
    <message name="VfilerTemplateCreateResponse">
        <part element="na:VfilerTemplateCreateResult" name="results"/>
    </message>
    <message name="VfilerTemplateDeleteRequest">
        <part element="na:VfilerTemplateDelete" name="parameters"/>
    </message>
    <message name="VfilerTemplateDeleteResponse">
        <part element="na:VfilerTemplateDeleteResult" name="results"/>
    </message>
    <message name="VfilerTemplateListInfoIterEndRequest">
        <part element="na:VfilerTemplateListInfoIterEnd" name="parameters"/>
    </message>
    <message name="VfilerTemplateListInfoIterEndResponse">
        <part element="na:VfilerTemplateListInfoIterEndResult" name="results"/>
    </message>
    <message name="VfilerTemplateListInfoIterNextRequest">
        <part element="na:VfilerTemplateListInfoIterNext" name="parameters"/>
    </message>
    <message name="VfilerTemplateListInfoIterNextResponse">
        <part element="na:VfilerTemplateListInfoIterNextResult" name="results"/>
    </message>
    <message name="VfilerTemplateListInfoIterStartRequest">
        <part element="na:VfilerTemplateListInfoIterStart" name="parameters"/>
    </message>
    <message name="VfilerTemplateListInfoIterStartResponse">
        <part element="na:VfilerTemplateListInfoIterStartResult" name="results"/>
    </message>
    <message name="VfilerTemplateModifyRequest">
        <part element="na:VfilerTemplateModify" name="parameters"/>
    </message>
    <message name="VfilerTemplateModifyResponse">
        <part element="na:VfilerTemplateModifyResult" name="results"/>
    </message>
    <message name="VolumeListInfoIterEndRequest">
        <part element="na:VolumeListInfoIterEnd" name="parameters"/>
    </message>
    <message name="VolumeListInfoIterEndResponse">
        <part element="na:VolumeListInfoIterEndResult" name="results"/>
    </message>
    <message name="VolumeListInfoIterNextRequest">
        <part element="na:VolumeListInfoIterNext" name="parameters"/>
    </message>
    <message name="VolumeListInfoIterNextResponse">
        <part element="na:VolumeListInfoIterNextResult" name="results"/>
    </message>
    <message name="VolumeListInfoIterStartRequest">
        <part element="na:VolumeListInfoIterStart" name="parameters"/>
    </message>
    <message name="VolumeListInfoIterStartResponse">
        <part element="na:VolumeListInfoIterStartResult" name="results"/>
    </message>
    <message name="VolumeModifyRequest">
        <part element="na:VolumeModify" name="parameters"/>
    </message>
    <message name="VolumeModifyResponse">
        <part element="na:VolumeModifyResult" name="results"/>
    </message>
    <portType name="DfmInterface">
        <documentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Aggregate</na:Name>
                <na:Synopsis>Aggregate management API</na:Synopsis>
                <na:Discussion>DFM tracks all the Aggregates it discovers on storage systems it is monitoring. These APIs give the user access To the information DFM has collected about Aggregates.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Alarm</na:Name>
                <na:Synopsis>Configure and list DFM alarms.</na:Synopsis>
                <na:Discussion>When an event is generated in DFM, there is a mechanism To notify users of the event. This is configured through "alarms". When an alarm is triggered, DFM can notify the user in multiple ways: &lt;ul&gt; &lt;li&gt; An email message may be sent To either a specific email Address or the email Address associated with a DFM administrator. &lt;li&gt; A shortened email message can be sent To either a specific email Address or the email Address of a DFM administrator. &lt;li&gt; A script may be run. The script parameters describe the event so that automated actions can be performed in the background. &lt;li&gt; A SNMP trap can be sent. &lt;/ul&gt; In addition, alarms may be configured To only trigger at certain times of the Day and for particular Events, event classes, or event severities. Alarms may be configured To trigger only for certain Groups of Objects. Finally, alarms may be configured To repeat their notification on a regular basis so that they don't get forgotten.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Api</na:Name>
                <na:Synopsis>API proxy mechanism</na:Synopsis>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Audit</na:Name>
                <na:Synopsis>Audit Logging APIs</na:Synopsis>
                <na:Discussion>APIs related To audit logging. All audit entries will be logged in the audit.log file</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Cifs</na:Name>
                <na:Synopsis>cifs related APIs</na:Synopsis>
                <na:Discussion>These APIs allow the user To get cifs related information From the Hosts discovered by DFM.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Client</na:Name>
                <na:Synopsis>per-client store of name/value pairs</na:Synopsis>
                <na:Discussion>DFM Server maintains a registry of name/value pairs on behalf of client applications. Applications can use this To store persistent data about the user's configuration of the application. Examples might be View preferences or window sizes and locations. Information in the client application registry is indexed by the Name of the appliacation and the Name of the user that authenticates with DataFabric Manager. The APIs determine the Username automatically. Applications should pick an "ApplicationName" that is likely To be unique. We encourage client application developers To use the application provider's company stock ticker symbol as a prefix for the application Name To reduce the chance of Name collisions. For example, all client applications provided by Network Appliance will use application names beginning with "NTAP".</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Comment</na:Name>
                <na:Synopsis>Operations on object Comments.</na:Synopsis>
                <na:Discussion>Management of creation, modification and deletion of comment fields, setting and unsetting of comment field Values To various managed Objects. Comment fields are added at the global level using CommentFieldCreate API. Once the comment fields are created, Values can be set for these new comment fields on various managed Objects using CommentSetObjectValue API.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Dataset</na:Name>
                <na:Synopsis>Operations on Datasets.</na:Synopsis>
                <na:Discussion>At the highest level, a Dataset is a logical collection of data, optionally associated with one or more policies. This collection of data resides on storage containers which should be thought of as transient in nature. That is, the storage containers holding the data may change over time and the data should be treated independently From the storage it happens To reside on. &lt;P&gt;Datasets typically describe data that has been provisioned From Resource pools according To a Policy. A Dataset may also be created by populating it with legacy storage containers such as existing Data ONTAP Volumes or non-NetApp containers such as OSSV Directories. &lt;P&gt;In concrete terms, a Dataset is a collection of Volumes, Qtrees, Luns, or possibly Host based containers such as OSSV Directories, with the addition of policies that are associated with it. The Dataset provides virtualization of the physical storage used To hold the data. &lt;P&gt;Currently, Datasets can not contain LUNs, Datasets can be associated only with data protection policies and their primary data can be either provisioned based on a provisioning Policy or can be populated with legacy storage containers. Secondary storage can be automatically provisioned From a Resource pool or added explicitly.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Dfm</na:Name>
                <na:Synopsis>dfm operations</na:Synopsis>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DfmSchedule</na:Name>
                <na:Synopsis>Schedule APIs</na:Synopsis>
                <na:Discussion>This set of API's is being used To manage schedules. The schedule will be used by the following: - data protection Policy To provide Snapshot, SnapVault and/or SnapMirror protection. A schedule can be of Type daily, weekly or monthly. - report schedules To save Reports on a scheduled basis. All date/time ranges in the APIs are inclusive.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Disk</na:Name>
                <na:Synopsis>disk management API</na:Synopsis>
                <na:Discussion>DFM tracks all the Disks it discovers on storage systems it is monitoring. These APIs give the user access To the information DFM has collected about Disks.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpBackup</na:Name>
                <na:Synopsis>Create and list Backups, list backup contents or start an on-demand backup.</na:Synopsis>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpDashboard</na:Name>
                <na:Synopsis>Special purpose APIs for drawing the Protection Manager dashboard</na:Synopsis>
                <na:Discussion>These operations are optimized APIs designed specially To make the Protection Manager dashboard page load quickly. Every API is this category provides data which is also available From other general purpose APIs. Any data not specifically required To draw the dashboard page is intentionally omitted, in order To maximize performance.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpJob</na:Name>
                <na:Synopsis>operations on data protection and provisioning Jobs.</na:Synopsis>
                <na:Discussion>The dp-job-list-iter* API's list the History of data protection and provisioning Jobs performed on Datasets. The DpJobListIter* ZAPI's give a brief Summary of the job. A data protection job for a Dataset is the combination of tasks on each of the Members of the Dataset whereas a provisioning job is for a provisioning Operation on a member of the Dataset. The DpJobProgressEventListIterStart ZAPI's give the detailed progress of each such subtask for the job.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpOssvDirectory</na:Name>
                <na:Synopsis>List and browse OSSV Directories.</na:Synopsis>
                <na:Discussion>These operations provide a way To browse the Directories on an OSSV Host which are normally only accessible through NDMP.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpPolicy</na:Name>
                <na:Synopsis>Operations on data protection policies.</na:Synopsis>
                <na:Discussion>A data protection (DP) Policy describes how To protect a data set by creating Backups and mirrors of the data at scheduled times. A DP Policy is represented by a &lt;b&gt;directed graph&lt;/b&gt; whose topology is that of a &lt;b&gt;tree&lt;/b&gt;. The &lt;b&gt;nodes&lt;/b&gt; (vertices) of the graph represent the Dataset's storage sets. The &lt;b&gt;connections&lt;/b&gt; (edges) of the graph are of one of two types: &lt;ul&gt; &lt;li&gt; A &lt;b&gt;backup&lt;/b&gt; connection represents relationships between elements of the storage sets it connects. A backup connection points From a storage set containing primaries To a storage set containing secondaries. &lt;li&gt; A &lt;b&gt;mirror&lt;/b&gt; connection represents relationships between elements of the storage sets it connects. A mirror connection points From a storage set containing sources To a storage set containing destinations. After an update, the Source and destination are identical. &lt;/ul&gt; A Policy also has a &lt;b&gt;Name&lt;/b&gt; (which must be unique among all policies) and a &lt;b&gt;Description&lt;/b&gt;. &lt;p&gt; Precisely one node in the graph, called the &lt;b&gt;root node&lt;/b&gt;, has no incoming connections. All other nodes have precisely one incoming connection. Each node has zero or more outgoing connections. Each node is of one of these three types: &lt;ul&gt; &lt;li&gt; The &lt;b&gt;root node&lt;/b&gt;. &lt;li&gt; A &lt;b&gt;backup secondary&lt;/b&gt;, which is a node with an incoming backup connection. &lt;li&gt; A &lt;b&gt;mirror destination&lt;/b&gt;, which is a node with an incoming mirror connection. &lt;/ul&gt; Each node has a &lt;b&gt;Name&lt;/b&gt;, which may be set by the user but must be unique within the Policy (it need not be unique among all policies). Each node also has a &lt;b&gt;numeric ID&lt;/b&gt;, which is selected by the system and is guaranteed To be unique within the Policy (but not among all policies). The Type of a node is not stored explicitly in a child XML element, but must instead be inferred From its position in the Policy graph. Nodes are represented by the XML structure &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt;, as described below. &lt;p&gt; Each connection has a &lt;b&gt;numeric ID&lt;/b&gt;, which is selected by the system and is guaranteed To be unique within the Policy (but not among all policies). Each connection also has a child element that explicitly stores its Type (backup or mirror). An individual connection is represented by the XML structure &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt;, as described below. &lt;p&gt; Because the Policy graph is a tree, it is &lt;b&gt;acyclic&lt;/b&gt;. In addition, it is &lt;b&gt;connected&lt;/b&gt;: every node in the graph may be reached by starting at the root node and traversing a series of zero or more connections. &lt;p&gt; A Policy graph may contain no connections, i.e., it may consist of just the root node. &lt;p&gt; Along the Path From the root node To any &lt;b&gt;leaf node&lt;/b&gt; (that is, a node with no outgoing connections), there may be at most one backup connection. &lt;p&gt; A set of named &lt;b&gt;Properties&lt;/b&gt;, or name-value pairs, is associated with each connection or node. Properties contain configuration data such as the schedules for performing Backups, and the Length of time To retain old Backups. Each Type of connection or node has a particular set of Properties associated with it. For example, the property &lt;b&gt;BackupScheduleName&lt;/b&gt; is associated with backup connections, but is not associated with mirror connections or nodes of any Type. Properties are represented using &lt;b&gt;optional&lt;/b&gt; elements of the XML structures that represent connections and nodes. &lt;p&gt; When a property is associated with a connection or node of a particular Type, we say that its corresponding XML element is &lt;b&gt;present&lt;/b&gt; in the connection or node's XML structure, and when the property is not associated with a connection or node, we say that the property is &lt;b&gt;absent&lt;/b&gt;. If a property is present for a connection or node, then its element &lt;b&gt;may&lt;/b&gt; appear in input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, and &lt;b&gt;always&lt;/b&gt; appears in output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. If a property is absent, then its element &lt;b&gt;may not&lt;/b&gt; appear in input To &lt;b&gt;DpPolicyModify&lt;/b&gt;, and &lt;b&gt;never&lt;/b&gt; appears in output From &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. For example, in the output From a call To &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;, the element for the property &lt;b&gt;BackupScheduleName&lt;/b&gt; always appears in the &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; structure for a backup connection, but never appears for a mirror connection. &lt;p&gt; The system contains a set of sample policies that are created when the system is installed. These sample policies may not be modified and may not be deleted. &lt;p&gt; The system supports only a limited set of topologies, the user is not allowed To create new topologies. For this Reason, there is no ZAPI To create a new DP Policy by specifying its topology. Instead, the user calls &lt;b&gt;DpPolicyCopy&lt;/b&gt; To create a new Policy by copying the content of an existing Policy, including its topology.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpRelationship</na:Name>
                <na:Synopsis>List and manage SnapVault and SnapMirror relationships.</na:Synopsis>
                <na:Discussion>&lt;P&gt; These APIs list ONTAP data protection relationships as viewed by the DFM database. The API is intentionally generic so that it represents all forms of data protection: SnapVault, Qtree SnapMirror and Volume SnapMirror. Future data protection protocols will be added To this API as they are developed. Making this API generic shields client applications From some of the syntactic differences between protocols. &lt;P&gt; For the most part, the APIs are straightforward, outputting a blob of information for each relationship. However, three orthogonal concepts arise: &lt;ul&gt; &lt;li&gt; being managed by Protection Manager, &lt;li&gt; being in a Dataset, and &lt;li&gt; being ignored. &lt;/ul&gt; &lt;P&gt; SnapVault and SnapMirror have existed for years, and for years, the DFM Backup Manager and Disaster Recovery Manager have managed SnapVault and SnapMirror relationships. DFM is now implementing Protection Manager, which provides unified SnapVault and SnapMirror management. Protection Manager creates, deletes, updates and modifies relationships, but we expect mixed environments and do not want Protection Manager To automatically modify existing SnapVault and SnapMirror relationships. Thus, relationships may be marked as &lt;B&gt;IsDpManaged&lt;/B&gt;, meaning Protection Manager has full authority To modify or delete the relationship as needed by the Datasets and protection policies. Relationships not marked as &lt;B&gt;IsDpManaged&lt;/B&gt; will not be modified, updated or deleted by Protection Manager. &lt;P&gt; Protection Manager organizes storage Objects (OSSV Directories, Volumes and Qtrees) into Datasets, which consists of sets of storage Objects linked by a protection Policy (which is a tree structure). It is possible To create Datasets using storage Objects which have pre-existing protection relationships. If a relationship connects two storage Objects in a way which matches the Dataset and Policy configuration, that relationship is considered To be in the Dataset. Note that this only talks about topology and configuration. A relationship might Match a Dataset yet not be managed by Protection Manager. The API user can combine the &lt;B&gt;IsDpManaged&lt;/B&gt; and &lt;B&gt;IsInDataset&lt;/B&gt; filter flags To find such relationships. &lt;P&gt; Storage Objects can be marked as &lt;B&gt;IsDpIgnored&lt;/B&gt; by Protection Manager. This allows a Protection Manager user To reduce UI clutter by marking certain Objects as uninteresting. These Objects still exist in the DFM database but do not show up in the Protection Manager UI. A relationship may be ignored and managed, not managed and not ignored, or any other combination. &lt;P&gt; Relationships that have been imported into a Dataset at an earlier time will be marked as &lt;B&gt;IsDpImported&lt;/B&gt; so that Protection Manager can distinguish them From relationships that were formed by Protection Manager. Imported relationships will also be marked as &lt;B&gt;IsDpManaged&lt;/B&gt; because some operations of Protection Manager require that relationships no longer in a Dataset remain managed. &lt;P&gt; Should a relationship be relinquished From Protection Manager management it will have both the &lt;B&gt;IsDpManaged&lt;/B&gt; as well as the &lt;B&gt;IsDpImported&lt;/B&gt; states both set To false.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpRestore</na:Name>
                <na:Synopsis>Operations To restore data From a backup (Data Protection).</na:Synopsis>
                <na:Discussion>These operations are used by Freya To restore data From a backed-up Dataset.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpSchedule</na:Name>
                <na:Synopsis>Data Protection Schedule APIs</na:Synopsis>
                <na:Discussion>This set of API's is being used To manage data protection schedules. A data protection schedule can be of Type daily, weekly or monthly. The data protection schedule will be used by the data protection Policy To provide Snapshot, snap vault and/or snap mirror protection. All date/time ranges in the APIs are inclusive.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>DpThrottle</na:Name>
                <na:Synopsis>Schedule Throttling APIs</na:Synopsis>
                <na:Discussion>This set of API's is used To manage and retrieve throttle schedule Values. dp-throttle is To be used by the scheduler in conjunction with dp-schedule To determine the time and Throughput of a specific backup. Throttle Value can be changed throughout the day/week. Hence, each throttle schedule may contain multiple entries To indicate different time ranges and throughputs. The scheduler will also utilize the information To adjust the throughputs of the running tasks accordingly.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Event</na:Name>
                <na:Synopsis>event operations</na:Synopsis>
                <na:Discussion>Category of APIs related To event generation and listing.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Eventclass</na:Name>
                <na:Synopsis>DFM event class operations.</na:Synopsis>
                <na:Discussion>APIs related To adding, editing and deleting custom or user-defined event classes and listing all event classes in the management station.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>FcpTarget</na:Name>
                <na:Synopsis>Target operations.</na:Synopsis>
                <na:Discussion>List FCP Target information stored in DFM Server database.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Graph</na:Name>
                <na:Synopsis>graph operations API</na:Synopsis>
                <na:Discussion>These APIs allow the user To get information and data of all the Graphs present in DFM. The GraphListInfoIter* API can be used presentation and GraphDataListInfo API is used for retrieving data of the Graphs. Some of the Key terms are as follows: &lt;ul&gt; &lt;li&gt; A &lt;b&gt;graph line&lt;/b&gt; is a line obtained on the graph when a graph sample is plotted against the Timestamp.&lt;/li&gt; &lt;li&gt; A &lt;b&gt;graph line Value&lt;/b&gt; is the sample Value at an Instance of time.&lt;/li&gt; &lt;li&gt;&lt;b&gt;Graph Period&lt;/b&gt; is the Period for which the graph data has To be returned. The graph data can be obtained for a Period of 1 Day (1d), 1 week (1w), 1 Month (1m), 3 Months (3m) and 1 year (1y). It may also contain some extrapolated Values which can be used for trending.&lt;/li&gt; &lt;/ul&gt;</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Group</na:Name>
                <na:Synopsis>Operations To manage DFM Groups.</na:Synopsis>
                <na:Discussion>These operations include everything necessary To manage DFM Groups.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>GroupMember</na:Name>
                <na:Synopsis>group_member operations</na:Synopsis>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Host</na:Name>
                <na:Synopsis>Host operations</na:Synopsis>
                <na:Discussion>Host operations include display and modification of configuration retrieved From the Hosts or provided when the Hosts are added To the DFM, as well as Status information obtained by monitoring. Modifications To the Host Attributes are stored in the DFM database only, except for Licenses, which are added on the physical Host as well as the database.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Ifc</na:Name>
                <na:Synopsis>Network Interface operations.</na:Synopsis>
                <na:Discussion>List network Interface information stored in DFM Server database.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Lun</na:Name>
                <na:Synopsis>Lun management API</na:Synopsis>
                <na:Discussion>DFM tracks all the Luns it discovers on storage systems it is monitoring. These APIs give the user access To the information DFM has collected about Luns.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Migrate</na:Name>
                <na:Synopsis>Migration related operations.</na:Synopsis>
                <na:Discussion>A set of APIs To MigrateStart Datasets and vFiler units. Migration APIs can be used To start migration, update migration relationships, complete migration, cancel migration and To cleanup stale storage after migration. In a typical migration sequence, MigrateStart would be issued To initiate baseline transfers To the destination. Subsequently, after a few MigrateUpdate calls, the user can select a suitable time and cutover To the new destination using MigrateComplete API. Once the MigrateComplete job finishes, data is served From the new destination. If in between, there is a need To cancel the migration, it can be done using MigrateCancel API. Once the migration is completed, the stale storage can be cleaned up From the Source storage system using MigrateCleanup API.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Netif</na:Name>
                <na:Synopsis>Network Interface listing APIs</na:Synopsis>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Perf</na:Name>
                <na:Synopsis>performance management APIs</na:Synopsis>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>ProvisioningPolicy</na:Name>
                <na:Synopsis>Provisioning Policy Operations.</na:Synopsis>
                <na:Discussion>Provisioning Policy is a set of Attributes that describe how To provision storage space for a Dataset. A Provisioning Policy can be associated with primary node, as well as non primary nodes in case the the Dataset is protected. There are 3 types of provisioning policies &lt;UL&gt; &lt;LI&gt; nas - used To provision and export storage over NFS/CIFS/both protocols. &lt;LI&gt; san - used To provision and export storage over FCP/iSCSI protocols. &lt;LI&gt; secondary - used To provision storage for Back up or Mirror destinations. &lt;/UL&gt; "san" and "nas" Type of provisioning policies can be applied only To primary node or dr node of a Dataset. The exact export Protocol and export settings can be configured at Dataset node level after this Policy is applied To the Dataset node using DatasetModifyNode zapi. &lt;BR&gt;&lt;BR&gt; "secondary" Type of provisioning Policy can be applied To non primary (Back up/Mirror) nodes of a Dataset. The storage provisioned using this Type of Policy can be exported. Once the provisioning Policy is associated with the Dataset node the storage in the node is periodically monitored for conformance with the Policy.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Qtree</na:Name>
                <na:Synopsis>DFM Qtree operations</na:Synopsis>
                <na:Discussion>DFM tracks all the Qtrees it discovers on storage systems it is monitoring. These APIs give the user access To the information DFM has collected. In addition, this API family gives users the ability To stop and start monitoring of Qtrees From the DFM database. It also provides the ability To rename Qtrees on storage systems.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Rbac</na:Name>
                <na:Synopsis>Role-Based Access Control (RBAC) management APIs</na:Synopsis>
                <na:Discussion>This set of API's can be used To manage an RBAC infrastructure as well as for making applications RBAC aware. Applications can become a Policy Enforcement Point (PEP) by utilizing these API's. There are Interfaces for populating as well as administering RBAC data. The data lives in the DFM database. Applications can add access control To resources by calling RbacAccessCheck (defined below). By making this call, they effectively become RBAC aware. Some APIs depend on a Resource. The specifics of a Resource are defined by the definition, ResourceIdentifier.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Report</na:Name>
                <na:Synopsis>report schedule operations API</na:Synopsis>
                <na:Discussion>These APIs allow the user To manage report schedules, report outputs, listing Reports and their corresponding Graphs.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Resourcepool</na:Name>
                <na:Synopsis>Resource pool operations</na:Synopsis>
                <na:Discussion>A Resource pool typically describes physical resources such as spare Disks, Aggregates or storage systems which are used for provisioning. &lt;p&gt; When a Resource pools contains a storage system, all Aggregates and spare Disks on the storage system are available for provisioning.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Snapshot</na:Name>
                <na:Synopsis>APIs To list Snapshot copies of Volumes and other operations on Snapshot copies.</na:Synopsis>
                <na:Discussion>DataFabric Manager discovers all the Snapshot copies of all Volumes of filers it is monitoring. This set of APIs supports listing the Snapshot copies and also To compute space that could be reclaimed by deleting these Snapshot copies.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>StorageService</na:Name>
                <na:Synopsis>Operations on storage services.</na:Synopsis>
                <na:Discussion>A storage Service is a set of policies, Resource pools and vFiler templates that define a storage Service level, usually corresponding To a service-level objective. A Dataset may be provisioned by specifying a desired storage Service. The Resource pool used To provision the storage and the policies governing the Dataset are determined by the storage Service specified. A storage provider controls the services being delivered To a set of Datasets by controlling the Service definitions and the Service attachments. If the storage provider modifies a storage Service definition, all Datasets with the Service attached will be affected. If the storage provider changes the storage Service attached To a Dataset From one Service To another, only the Dataset is affected. Affected Datasets may go out of conformance, possibly resulting in automated actions. In an environment where the storage provider is responsible for translating enterprise service-level agreements into NetApp-specific Policy configuration or subscribers lack expertise in NetApp technology, storage services should be used for provisioning instead of creating Datasets with explicitly assigned policies and Resource pools. This model is particularly well-suited To integration of orchestration tools and scripts with APIs.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Timezone</na:Name>
                <na:Synopsis>operations on time zones</na:Synopsis>
                <na:Discussion>The DataFabric Manager server allows administrators To specify the time zone where portions of Datasets are physically located. This allows the internal scheduling processes To adjust backup times appropriately for storage in different locations. &lt;p&gt; The time zone specifications here are the same as in Data ONTAP. Timezone specifications can be in one of several formats: &lt;ul&gt; &lt;li&gt; Using a location string specified in Arthur David Olsen's public domain time zone database. This format identifies locations by continent or ocean and then by the Name of the location, which is typically the largest city within the region. For example, "America/New_York" represents most of the eastern time zone; "America/Phoenix" represents most of Arizona, which uses mountain time without daylight savings time. &lt;li&gt; A traditional time zone abbreviation incorporating default rules for daylight savings time. For example, "EST5EDT" for the US eastern zone, or "PST8PDT" for the pacific zone, or "GMT-2" for two hours east of GMT. &lt;li&gt; A full POSIX time zone specification, specifying names for the standard and daylight times, and the rules for switching between them. For example, Brian's Time might be "BST8BDT,M4.1.0,M10.5.0". &lt;/ul&gt; &lt;p&gt; This family of APIs provides Interfaces for listing the time zones in the server's database, and for validating that a user-supplied time zone specification is valid. Note that there are many ways of forming a valid time zone specification, so the output of the timezone-list-info iterators is not a complete list of valid time zones.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>UserReportProfile</na:Name>
                <na:Synopsis>Manage a user's report profile.</na:Synopsis>
                <na:Discussion>These APIs facilitate the management of Favorites and recently viewed Reports of a user.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Vfiler</na:Name>
                <na:Synopsis>vFiler related operations.</na:Synopsis>
                <na:Discussion>A set of APIs To manage vFilers and vFiler templates. vFiler template APIs are used To create, modify, Destroy and list vFiler template Objects. They contain information that is used To setup a vFiler. vFiler APIs can be used To create a vFiler on a particular Filer or From a Resource pool, To set up the vFiler with appropriate configuration From a vFiler template and also To Destroy a vFiler.</na:Discussion>
            </CategoryDocumentation>
            <CategoryDocumentation xsi:type="na:CategoryDocumentation">
                <na:Name>Volume</na:Name>
                <na:Synopsis>DFM Volume operations</na:Synopsis>
                <na:Discussion>DFM tracks all the Volumes it discovers on storage systems it is monitoring. These APIs give the user access To the information DFM has collected. In addition, this API family will eventually give users the ability To create, modify and Destroy Volumes on storage systems.</na:Discussion>
            </CategoryDocumentation>
        </documentation>
        <operation name="AggregateListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The AggregateListInfoIter* set of APIs are used To retrieve the list of Aggregates. AggregateListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the AggregateListInfoIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateListInfoIterEndRequest"/>
            <output message="na:AggregateListInfoIterEndResponse"/>
        </operation>
        <operation name="AggregateListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check AggregateListInfoIterStart. The AggregateListInfoIterNext API is used To iterate over the Members of the Aggregates stored in the temporary store created by the AggregateListInfoIterStart API.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateListInfoIterNextRequest"/>
            <output message="na:AggregateListInfoIterNextResponse"/>
        </operation>
        <operation name="AggregateListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The AggregateListInfoIter* set of APIs are used To retrieve the list of Aggregates in DFM. The AggregateListInfoIterStart API is used To load the list of Aggregates into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Aggregates in the temporary store. If AggregateListInfoIterStart is invoked twice, then two distinct temporary stores are created. If neither AggregateNameOrId or aggr-group-name-or-id are provided, all Aggregates will be listed. If either, but not both are provided, the Aggregate or all Aggregates in the Group will be listed respectively. If AggregateNameOrId and aggr-group-name-or-id are provided, the Aggregate will be listed only if it is under the specified Group.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateListInfoIterStartRequest"/>
            <output message="na:AggregateListInfoIterStartResponse"/>
        </operation>
        <operation name="AggregateModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an Aggregate's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Aggregate. &lt;li&gt; EINVALIDINPUT - When invalid input specified. &lt;li&gt; EOBJECTNOTFOUND - When the AggregateNameOrId does not correspond To an Aggregate. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateModifyRequest"/>
            <output message="na:AggregateModifyResponse"/>
        </operation>
        <operation name="AggregateSpaceManagementAddOperation">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a space management Operation as part of this space management session. The actual Operation is not carried out unless AggregateSpaceManagementCommit is called. If this Operation cannot be carried out, then ESPACEMGMTCONFLICTOP will be returned The following rules apply when adding an Operation To the session. &lt;ul&gt; &lt;li&gt; A session cannot have 2 operations of same Type for a give Volume. For example two Volume resize operations cannot be added for the same Volume To a session. If this check fails the api will return ESPACEMGMTCONFLICTOP Error. &lt;li&gt; If a Volume migration Operation is added To a session then other session management operations cannot be added To the session. Similarly a Volume migration cannot be added To a session if other Type of Operation is already added To session. If this check fails the api will return ESPACEMGMTCONFLICTOP Error. &lt;/ul&gt; If this Operation leads To Errors in DryRunResults that are returned, then this Operation is not added To the session.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23336</na:Code>
                            <na:Name>EINVALIDOBJECTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23803</na:Code>
                            <na:Name>ESPACEMGMTCONFLICTOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23802</na:Code>
                            <na:Name>ESPACEMGMTSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateSpaceManagementAddOperationRequest"/>
            <output message="na:AggregateSpaceManagementAddOperationResponse"/>
        </operation>
        <operation name="AggregateSpaceManagementBegin">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Open a space management session To run space management operations on an Aggregate.&lt;P&gt; This allows adding a set of space management operations in a session, getting the difference in space consumption due To these set of operations and then committing all the operations. A space management session must be started before invoking the following ZAPIs: &lt;UL&gt; &lt;LI&gt;AggregateSpaceManagementAddOperation &lt;LI&gt;AggregateSpaceManagementRemoveOperation &lt;LI&gt;AggregateSpaceManagementCommit &lt;LI&gt;AggregateSpaceManagementRollback &lt;/UL&gt; Use AggregateSpaceManagementCommit To commit the changes and To start Jobs which will carry out the space management operations. &lt;P&gt; Use AggregateSpaceManagementRollback To rollback the session. This will not submit any Jobs for space management operations. &lt;P&gt; After 24 hours, a session can be opened on the same Aggregate by another client without the Force Option. This will cause any space management operations that were part of the session To be discarded.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23801</na:Code>
                            <na:Name>ESPACEMGMTSESSIONINPROGRESS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateSpaceManagementBeginRequest"/>
            <output message="na:AggregateSpaceManagementBeginResponse"/>
        </operation>
        <operation name="AggregateSpaceManagementCommit">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Commit the space management operations added as part of this space management session. &lt;P&gt; The session that was opened on the Aggregate will be released once all the space management Jobs that were part of the session are queued To be executed eventually.&lt;P&gt; This will not wait for the Jobs To be executed.&lt;P&gt; Use the &lt;b&gt;DryRun&lt;/b&gt; Option To test the commit. It returns a set of DryRun Results for each space management Operation that was added as part of this session. &lt;p&gt; DryRunResults is a set of steps that the server will take To carry out the space management Operation &lt;p&gt;When DryRun is true, it also returns the projected used and committed space of the Aggregate on which the space management session was opened and other dependent Aggregates in case of migration operations. &lt;p&gt; If &lt;b&gt;DryRun&lt;/b&gt; is false, then before the call returns, the system submits Jobs To the provisioning engine To execute.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23802</na:Code>
                            <na:Name>ESPACEMGMTSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateSpaceManagementCommitRequest"/>
            <output message="na:AggregateSpaceManagementCommitResponse"/>
        </operation>
        <operation name="AggregateSpaceManagementRemoveOperation">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove a space management Operation that was added as part of this space management session.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23802</na:Code>
                            <na:Name>ESPACEMGMTSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23804</na:Code>
                            <na:Name>ESPCMGMTNOSUCHOP</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateSpaceManagementRemoveOperationRequest"/>
            <output message="na:AggregateSpaceManagementRemoveOperationResponse"/>
        </operation>
        <operation name="AggregateSpaceManagementRollback">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Release the session opened for space management on an Aggregate. All the space management operations that were submitted as part of the space management session would be discarded.</na:Description>
                    <na:Category>Aggregate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23802</na:Code>
                            <na:Name>ESPACEMGMTSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AggregateSpaceManagementRollbackRequest"/>
            <output message="na:AggregateSpaceManagementRollbackResponse"/>
        </operation>
        <operation name="AlarmCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a DFM alarm. The AlarmInfo element specifies all the parameters of the new alarm. &lt;P&gt; Note that it is possible To specify a combination of the EventName, EventSeverity and EventClass such that this alarm will never be triggered. It is the user's responsibility To verify these settings are useful. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EINVALIDEMAILADDR - If the email Address has spaces, semi-colons or unprintable characters. &lt;li&gt; EINVALIDEVENTSEVERITY - If the EventSeverity specified is not one of 'normal', 'information', 'unknown', 'warning', 'Error', 'critical', 'emergency'. &lt;li&gt; EINVALIDEVENTCLASSEXP - If the regular expression specified for the EventClass is not a valid POSIX.1 regular expression. &lt;li&gt; EINVALIDALARMTIME - If the time-specified for TimeFrom or TimeTo is greater than 86399 ((24 * 60 * 60) - 1) seconds or if only one of TimeFrom and TimeTo Values are specified. &lt;li&gt; EINVALIDTRAPADDR - If the trap Host specified is not reachable or when the port is greater than 65535 (2^15 - 1) &lt;li&gt; ENOSUCHEVENT - If the event Name specified is not a valid EventName of DFM. &lt;li&gt; EGROUPDOESNOTEXIST - If the Group specified in the alarm parameters is not a DFM Resource Group. &lt;li&gt; ENOTFOUNDUSER - If the administrator Name specified in the alarm parameters is not a DFM administrator. &lt;li&gt; ERUNASUNSUPPORTED - If script-runas parameter is specified on a Windows DFM platform. &lt;li&gt; EINVALIDINPUT - If the EventSeverity Value is less than the Severity of the EventName event. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm is being configured. It is also set when the user sets script-runas parameter for the alarm and he does not have global DFM.Database.Write Capability. &lt;/ul&gt;</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22231</na:Code>
                            <na:Name>EINVALIDALARMTIME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22227</na:Code>
                            <na:Name>EINVALIDEMAILADDR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22232</na:Code>
                            <na:Name>EINVALIDEVENTCLASSEXP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22260</na:Code>
                            <na:Name>EINVALIDEVENTSEVERITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22230</na:Code>
                            <na:Name>EINVALIDTRAPADDR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22257</na:Code>
                            <na:Name>ENOSUCHEVENT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22229</na:Code>
                            <na:Name>ERUNASUNSUPPORTED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmCreateRequest"/>
            <output message="na:AlarmCreateResponse"/>
        </operation>
        <operation name="AlarmDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete an alarm. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EALARMDOESNOTEXIST - If an alarm by the specified Id does not exist. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm being destroyed is configured. &lt;/ul&gt;</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22233</na:Code>
                            <na:Name>EALARMDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmDestroyRequest"/>
            <output message="na:AlarmDestroyResponse"/>
        </operation>
        <operation name="AlarmGetDefaults">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the default Values of Attributes defined by this ZAPI set.</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmGetDefaultsRequest"/>
            <output message="na:AlarmGetDefaultsResponse"/>
        </operation>
        <operation name="AlarmListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends listing of alarms.</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmListInfoIterEndRequest"/>
            <output message="na:AlarmListInfoIterEndResponse"/>
        </operation>
        <operation name="AlarmListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From list generated by AlarmListInfoIterStart.</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmListInfoIterNextRequest"/>
            <output message="na:AlarmListInfoIterNextResponse"/>
        </operation>
        <operation name="AlarmListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List all configured alarms.</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22233</na:Code>
                            <na:Name>EALARMDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmListInfoIterStartRequest"/>
            <output message="na:AlarmListInfoIterStartResponse"/>
        </operation>
        <operation name="AlarmModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify settings of a DFM alarm. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EALARMDOESNOTEXIST - If an alarm by the specified Id does not exist. &lt;li&gt; EINVALIDEMAILADDR - If the email Address has spaces, semi-colons or unprintable characters. &lt;li&gt; EINVALIDEVENTSEVERITY - If the EventSeverity specified is not one of 'normal', 'information', 'unknown', 'warning', 'Error', 'critical', 'emergency'. &lt;li&gt; EINVALIDEVENTCLASSEXP - If the regular expression specified for the EventClass is not a valid POSIX.1 regular expression. &lt;li&gt; EINVALIDALARMTIME - If the time-specified for TimeFrom or TimeTo is greater than 86399 ((24 * 60 * 60) - 1) seconds or if only one of TimeFrom and TimeTo Values are specified. &lt;li&gt; EINVALIDTRAPADDR - If the trap Host specified is not reachable or when the port is greater than 65535 (2^15 - 1) &lt;li&gt; ENOSUCHEVENT - If the event Name specified is not a valid EventName of DFM. &lt;li&gt; EGROUPDOESNOTEXIST - If the Group specified in the alarm parameters is not a DFM Resource Group. &lt;li&gt; ENOTFOUNDUSER - If the administrator Name specified in the alarm parameters is not a DFM administrator. &lt;li&gt; ERUNASUNSUPPORTED - If script-runas parameter is specified on a Windows DFM platform. &lt;li&gt; EINVALIDINPUT - If the EventSeverity Value is less than the Severity of the EventName event. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm is being configured. It is also set when the user sets script-runas parameter for the alarm and he does not have DFM.Database.Write Capability at global level. &lt;/ul&gt;</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22233</na:Code>
                            <na:Name>EALARMDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13006</na:Code>
                            <na:Name>EAPIMISSINGARGUMENT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22231</na:Code>
                            <na:Name>EINVALIDALARMTIME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22227</na:Code>
                            <na:Name>EINVALIDEMAILADDR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22232</na:Code>
                            <na:Name>EINVALIDEVENTCLASSEXP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22260</na:Code>
                            <na:Name>EINVALIDEVENTSEVERITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22230</na:Code>
                            <na:Name>EINVALIDTRAPADDR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22257</na:Code>
                            <na:Name>ENOSUCHEVENT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22229</na:Code>
                            <na:Name>ERUNASUNSUPPORTED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmModifyRequest"/>
            <output message="na:AlarmModifyResponse"/>
        </operation>
        <operation name="AlarmTest">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Test an alarm by performing it's trigger actions. The test will be performed irrespective of whether the alarm is enabled or disabled. &lt;P&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EALARMDOESNOTEXIST - If an alarm by the specified Id does not exist. &lt;li&gt; EALARMTESTFAILED - If there is an Error sending the test alarm event To DataFabric Manager Event Service. &lt;li&gt; EDATABASEERROR - A database Error occured during processing. &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Event.Write Capability on the Resource Group on which the alarm is configured. &lt;/ul&gt;</na:Description>
                    <na:Category>Alarm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22233</na:Code>
                            <na:Name>EALARMDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22280</na:Code>
                            <na:Name>EALARMTESTFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AlarmTestRequest"/>
            <output message="na:AlarmTestResponse"/>
        </operation>
        <operation name="ApiProxy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Proxy an API Request To a third party and return the API Response.</na:Description>
                    <na:Category>Api</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13010</na:Code>
                            <na:Name>EAPIUNSUPPORTEDVERSION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ApiProxyRequest"/>
            <output message="na:ApiProxyResponse"/>
        </operation>
        <operation name="AuditLogAddEntry">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Log an entry in the audit log file of DataFabric Manager</na:Description>
                    <na:Category>Audit</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:AuditLogAddEntryRequest"/>
            <output message="na:AuditLogAddEntryResponse"/>
        </operation>
        <operation name="CifsDomainListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a View list iteration and clean up any saved info.</na:Description>
                    <na:Category>Cifs</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CifsDomainListInfoIterEndRequest"/>
            <output message="na:CifsDomainListInfoIterEndResponse"/>
        </operation>
        <operation name="CifsDomainListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To CifsDomainListInfoIterStart</na:Description>
                    <na:Category>Cifs</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CifsDomainListInfoIterNextRequest"/>
            <output message="na:CifsDomainListInfoIterNextResponse"/>
        </operation>
        <operation name="CifsDomainListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of cifs domains on Hosts discovered by DFM.</na:Description>
                    <na:Category>Cifs</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CifsDomainListInfoIterStartRequest"/>
            <output message="na:CifsDomainListInfoIterStartResponse"/>
        </operation>
        <operation name="ClientRegistryDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove one or all name/value pairs From the persistent store.</na:Description>
                    <na:Category>Client</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21003</na:Code>
                            <na:Name>ENAMENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ClientRegistryDestroyRequest"/>
            <output message="na:ClientRegistryDestroyResponse"/>
        </operation>
        <operation name="ClientRegistryGet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve one or all name/value string pairs.</na:Description>
                    <na:Category>Client</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21003</na:Code>
                            <na:Name>ENAMENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ClientRegistryGetRequest"/>
            <output message="na:ClientRegistryGetResponse"/>
        </operation>
        <operation name="ClientRegistrySet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Store one or more name/value string pairs.</na:Description>
                    <na:Category>Client</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:ClientRegistrySetRequest"/>
            <output message="na:ClientRegistrySetResponse"/>
        </operation>
        <operation name="CommentFieldCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a comment field. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDALREADYEXISTS - A comment field by the same Name already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EINVALIDINPUT - Invalid input was provided. &lt;/UL&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>23301</na:Code>
                            <na:Name>ECOMMENTFIELDALREADYEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldCreateRequest"/>
            <output message="na:CommentFieldCreateResponse"/>
        </operation>
        <operation name="CommentFieldDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a comment field. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id does not exist. &lt;LI&gt; ESYSTEMCOMMENTFIELD - An attempt was made To Destroy a system comment field. &lt;LI&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>23302</na:Code>
                            <na:Name>ECOMMENTFIELDDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23303</na:Code>
                            <na:Name>ESYSTEMCOMMENTFIELD</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldDestroyRequest"/>
            <output message="na:CommentFieldDestroyResponse"/>
        </operation>
        <operation name="CommentFieldListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a list iteration that had been started by a call To CommentFieldListInfoIterStart. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/ul&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldListInfoIterEndRequest"/>
            <output message="na:CommentFieldListInfoIterEndResponse"/>
        </operation>
        <operation name="CommentFieldListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the next set of comment fields in the iteration started by CommentFieldListInfoIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldListInfoIterNextRequest"/>
            <output message="na:CommentFieldListInfoIterNextResponse"/>
        </operation>
        <operation name="CommentFieldListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list all comment fields. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id or Name does not exist. &lt;LI&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>23302</na:Code>
                            <na:Name>ECOMMENTFIELDDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldListInfoIterStartRequest"/>
            <output message="na:CommentFieldListInfoIterStartResponse"/>
        </operation>
        <operation name="CommentFieldModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a comment field. Currently only the Name of the comment field can be modified. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id does not exist. &lt;LI&gt; ECOMMENTFIELDALREADYEXISTS - A comment field by the same Name already exists. &lt;LI&gt; ESYSTEMCOMMENTFIELD - An attempt was made To modify a system comment field. &lt;LI&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;LI&gt; EINVALIDINPUT - Invalid input was provided. &lt;/UL&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>23301</na:Code>
                            <na:Name>ECOMMENTFIELDALREADYEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23302</na:Code>
                            <na:Name>ECOMMENTFIELDDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23303</na:Code>
                            <na:Name>ESYSTEMCOMMENTFIELD</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldModifyRequest"/>
            <output message="na:CommentFieldModifyResponse"/>
        </operation>
        <operation name="CommentFieldValuesListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a list iteration that had been started by a call To CommentFieldValuesListInfoIterStart. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/ul&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldValuesListInfoIterEndRequest"/>
            <output message="na:CommentFieldValuesListInfoIterEndResponse"/>
        </operation>
        <operation name="CommentFieldValuesListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the next set of comment field Values in the iteration started by comment-field-values-list-iter-start &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldValuesListInfoIterNextRequest"/>
            <output message="na:CommentFieldValuesListInfoIterNextResponse"/>
        </operation>
        <operation name="CommentFieldValuesListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start iteration on listing comment field Values for Objects. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id or Name does not exist. &lt;li&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;li&gt; EACCESSDENIED - The user does not have DFM.Database.Read Capability on the specified object. If the object is a Dataset, then the user does not have DFM.Dataset.Read on the Dataset. &lt;li&gt; EOBJECTNOTFOUND - The specified object was not found. &lt;li&gt; EOBJECTAMBIGUOUS - The specified object Name could refer To more than a single object. Use object identifiers To disambiguate. &lt;/ul&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23302</na:Code>
                            <na:Name>ECOMMENTFIELDDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentFieldValuesListInfoIterStartRequest"/>
            <output message="na:CommentFieldValuesListInfoIterStartResponse"/>
        </operation>
        <operation name="CommentSetObjectValue">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Set the Value of a comment field for a specified managed object. &lt;HR&gt; Error conditions: &lt;ul&gt; &lt;li&gt; ECOMMENTFIELDDOESNOTEXIST - A comment field by the specified Id or Name does not exist. &lt;li&gt; EDATABASEERROR - A database Error occured while processing the Request. &lt;li&gt; EACCESSDENIED - The user does not have DFM.Database.Write Capability on the specified object. &lt;li&gt; EINVALIDINPUT - The specified comment Value is invalid. &lt;li&gt; EOBJECTNOTFOUND - The specified object was not found or the managed object was not a supported Type for setting Comments. &lt;li&gt; EOBJECTAMBIGUOUS - The specified object Name could refer To more than a single object. Use object identifiers To disambiguate. &lt;/ul&gt;</na:Description>
                    <na:Category>Comment</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23302</na:Code>
                            <na:Name>ECOMMENTFIELDDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:CommentSetObjectValueRequest"/>
            <output message="na:CommentSetObjectValueResponse"/>
        </operation>
        <operation name="DatasetAddMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add Members To an existing Dataset.&lt;P&gt; This API is for adding direct member Objects To one or more storage sets in the Dataset. Each storage set is identified by the data protection Policy node associated with it. &lt;P&gt;The types of storage Objects allowed To be added vary: &lt;UL&gt; &lt;LI&gt; Volumes, Qtrees and OSSV Directories are allowed in the storage set attached To a primary Policy node. &lt;/LI&gt; &lt;LI&gt; Only Volumes are allowed in a storage sets attached To secondary/destination nodes. &lt;/LI&gt; &lt;/UL&gt; It is legal To add storage Objects To multiple storage sets in a single call.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22241</na:Code>
                            <na:Name>EALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22295</na:Code>
                            <na:Name>EDSCONFLICTCANTMIRROROSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22296</na:Code>
                            <na:Name>EDSCONFLICTCANTSNAPSHOTOSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22334</na:Code>
                            <na:Name>EDSCONFLICTINCOMPATIBLEPOLICY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23346</na:Code>
                            <na:Name>EDSCONFLICTMEMBERVFILERMISMATCH</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22297</na:Code>
                            <na:Name>EDSCONFLICTNOSMLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22298</na:Code>
                            <na:Name>EDSCONFLICTNOSMSVLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22301</na:Code>
                            <na:Name>EDSCONFLICTNOTLEAFNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22300</na:Code>
                            <na:Name>EDSCONFLICTNOTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22335</na:Code>
                            <na:Name>EDSCONFLICTOSSVNOTALLOWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22299</na:Code>
                            <na:Name>EDSCONFLICTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23418</na:Code>
                            <na:Name>EDSCONFLICTWITHANOTHERDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23336</na:Code>
                            <na:Name>EINVALIDOBJECTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetAddMemberRequest"/>
            <output message="na:DatasetAddMemberResponse"/>
        </operation>
        <operation name="DatasetAddMemberByDynamicReference">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add dynamic reference To an existing Dataset.&lt;P&gt; By adding a dynamic reference, the Volumes, Qtrees, and ossv Directories referred To by the dynamic reference become implicit (indirect) Members of the Dataset. A dynamic reference can be added To a particular storage set in the Dataset by specifying the data protection Policy node associated with it. If necessary a new storage set is first created automatically before adding storage Objects To it.&lt;P&gt; The types of storage Objects allowed To be added vary: &lt;UL&gt; &lt;LI&gt; Storage systems, vFiler units, Aggregates and OSSV Hosts can be attached To a primary Policy node. &lt;/LI&gt; &lt;LI&gt; Storage systems, vFiler units and Aggregates are allowed in storage sets attached To secondary/destination nodes. &lt;/LI&gt; &lt;/UL&gt; It is legal To add storage Objects To multiple storage sets in a single call.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22241</na:Code>
                            <na:Name>EALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22295</na:Code>
                            <na:Name>EDSCONFLICTCANTMIRROROSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22296</na:Code>
                            <na:Name>EDSCONFLICTCANTSNAPSHOTOSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22334</na:Code>
                            <na:Name>EDSCONFLICTINCOMPATIBLEPOLICY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23346</na:Code>
                            <na:Name>EDSCONFLICTMEMBERVFILERMISMATCH</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22297</na:Code>
                            <na:Name>EDSCONFLICTNOSMLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22298</na:Code>
                            <na:Name>EDSCONFLICTNOSMSVLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22301</na:Code>
                            <na:Name>EDSCONFLICTNOTLEAFNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22300</na:Code>
                            <na:Name>EDSCONFLICTNOTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22335</na:Code>
                            <na:Name>EDSCONFLICTOSSVNOTALLOWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22299</na:Code>
                            <na:Name>EDSCONFLICTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23336</na:Code>
                            <na:Name>EINVALIDOBJECTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetAddMemberByDynamicReferenceRequest"/>
            <output message="na:DatasetAddMemberByDynamicReferenceResponse"/>
        </operation>
        <operation name="DatasetAddResourcepool">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add Resource pool To a single storage set that is part of a Dataset. The storage set is specified implicitly by the Name of the Policy node that maps To it.&lt;P&gt; Within the same edit session in which you call &lt;b&gt;DatasetAddResourcepool&lt;/b&gt;, you may also add or remove Members or dynamic references, or change the Dataset's Name, Description, &lt;b&gt;IsDpIgnored&lt;/b&gt;, &lt;b&gt;IsDpSuspended&lt;/b&gt;, or &lt;b&gt;IsSuspended&lt;/b&gt;. You may not change the data set's protection Policy or storage sets within the same edit session. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To modify the storage set or does not have DFM.ResourcePool.Provision on the specified Resource pool. &lt;LI&gt; EOBJECTAMBIGUOUS - The Name given for the storage set or Resource pool matches multiple storage sets or Resource pools. &lt;LI&gt; EOBJECTNOTFOUND - No storage set or Resource pool was found that has the given Name or identifier. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; ESTORAGESETNOTINDATASET - The specified storage set is not a part of the Dataset being edited. &lt;LI&gt; EDPPOLICYNODENOTFOUND - No DP Policy node was found that has the given Name. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EDSCONFLICTALREADYINDATASET - Object, its ancestor or descendent is already in Dataset. &lt;LI&gt; EDSCONFLICTSRCDESTINSAMEAGGR - Source data and destination data are in the same Aggregate. &lt;LI&gt; EDSCONFLICTALREADYINRESPOOL - Object, its ancestor or descendent is already in Resource pool. &lt;/UL&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23517</na:Code>
                            <na:Name>ESERVICEISATTACHED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22283</na:Code>
                            <na:Name>ESTORAGESETNOTINDATASET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetAddResourcepoolRequest"/>
            <output message="na:DatasetAddResourcepoolResponse"/>
        </operation>
        <operation name="DatasetBeginFailover">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Begin failover of a Dataset. &lt;P&gt;This API begins the process of failing over a Dataset To its disaster recovery storage. The failover process will break any mirror relationships between the primary and DR storage Objects and make the secondary storage available for use. &lt;P&gt;This API may only be invoked if the DR state of the data set is "ready". &lt;P&gt;Specifically, when the ZAPI runs, the following actions will take place: &lt;ol&gt; &lt;li&gt;The DR state of the Dataset will immediately change To "failing_over". &lt;li&gt;Any pending conformance tasks will be cancelled. &lt;li&gt;Any Jobs running against this Dataset will be aborted. &lt;li&gt;A failover job will be started To break any mirrors between the primary storage set and the DR storage set &lt;li&gt;Finally, the DR state of the Dataset will be updated To either "failed_over" or "failover_error" based on whether the failover job succeeded or not. &lt;/ol&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23401</na:Code>
                            <na:Name>EDATASETDRSTATEUNCHANGED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23402</na:Code>
                            <na:Name>EDATASETFAILOVERNOTREADY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23400</na:Code>
                            <na:Name>EDATASETWRONGDRSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetBeginFailoverRequest"/>
            <output message="na:DatasetBeginFailoverResponse"/>
        </operation>
        <operation name="DatasetBeginFailoverScriptTest">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Begin test failover of a Dataset that only runs the the failover scripts and does not dequeue tasks, abort Jobs or change the DrState.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23402</na:Code>
                            <na:Name>EDATASETFAILOVERNOTREADY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23400</na:Code>
                            <na:Name>EDATASETWRONGDRSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetBeginFailoverScriptTestRequest"/>
            <output message="na:DatasetBeginFailoverScriptTestResponse"/>
        </operation>
        <operation name="DatasetChangeDrState">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change the disaster recovery state of a Dataset. &lt;P&gt;This API sets the DR state of a Dataset To a new Value. Users may perform the following DR state transitions using this ZAPI: &lt;ul&gt; &lt;li&gt; From "failover_error" To "failed_over". &lt;li&gt; From "failover_error" To "ready". &lt;li&gt; From "failed_over" To "ready". &lt;/ul&gt; &lt;P&gt;If the "AllowInternalTransitions" element is present and true, the caller may make additional state transitions: &lt;ul&gt; &lt;li&gt; From "ready" To "failing_over" &lt;li&gt; From "failing_over" To "failed_over" &lt;li&gt; From "failing_over" To "failover_error" &lt;/ul&gt; These state transitions are intended To be used by Protection Manager server processes as part of a failover or failback sequence. Any attempt To perform other state transition will fail with an Error code of EDATASETWRONGDRSTATE. &lt;P&gt;The DR state of a Dataset will also change in one special case: &lt;ul&gt; &lt;li&gt;The Dataset is in a "failed_over" DR state &lt;li&gt;The caller changes the data protection Policy &lt;li&gt;The caller maps the storage set for the DR node of the old Policy To the root node of the new Policy (using DatasetSetStorageset) &lt;/ul&gt; When the edit session with these modifications is committed, the DR state will be set back To "ready".</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13002</na:Code>
                            <na:Name>EAPIAUTHENTICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23400</na:Code>
                            <na:Name>EDATASETWRONGDRSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetChangeDrStateRequest"/>
            <output message="na:DatasetChangeDrStateResponse"/>
        </operation>
        <operation name="DatasetConformBegin">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Begin a conformance run on a Dataset, To attempt To bring it into conformance with its data protection Policy and provisioning Policy. A conformance run consists of two main steps: &lt;UL&gt; &lt;LI&gt; Perform a &lt;b&gt;conformance check&lt;/b&gt; To determine both the Dataset's current conformance Status, and the set of actions needed To bring the Dataset into conformance. &lt;LI&gt; Perform the &lt;b&gt;conformance actions&lt;/b&gt; needed To bring the Dataset into conformance. &lt;/UL&gt; In addition, the Dataset's conformance Status is updated at various points during the conformance run. Whenever the conformance Status is updated, an event of Type "Dataset.conformance" is generated. &lt;P&gt; Successful completion of this ZAPI indicates that: the conformance check has completed successfully, the Dataset's conformance Status has been updated based on the Results of the conformance check, and the system has begun To take any needed conformance actions. &lt;P&gt; After the ZAPI returns, the system continues To perform conformance actions in the background, until all actions complete. Once all actions have completed, the Dataset's conformance Status is again updated. Note that at present, there is no ZAPI Interface for determining when all actions have completed. &lt;P&gt; If no Policy has been assigned To the Dataset, the conformance run completes immediately and performs no conformance actions. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To access the Dataset. &lt;LI&gt; EOBJECTNOTFOUND - No Dataset was found that has the given Name or ID. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23510</na:Code>
                            <na:Name>EDATASETMIGRATING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetConformBeginRequest"/>
            <output message="na:DatasetConformBeginResponse"/>
        </operation>
        <operation name="DatasetCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new, empty Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22212</na:Code>
                            <na:Name>EDATASETEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23406</na:Code>
                            <na:Name>EDSCONFLICTNDRESTORE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22270</na:Code>
                            <na:Name>EINVALIDMEMBER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>14517</na:Code>
                            <na:Name>EINVALIDTIMEZONE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22269</na:Code>
                            <na:Name>EMEMBERALREADYINGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetCreateRequest"/>
            <output message="na:DatasetCreateResponse"/>
        </operation>
        <operation name="DatasetDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a Dataset. The Dataset must be empty unless the "Force" Option is used.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23416</na:Code>
                            <na:Name>EDATASETFAILINGOVER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23510</na:Code>
                            <na:Name>EDATASETMIGRATING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22239</na:Code>
                            <na:Name>EDATASETNOTEMPTY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22243</na:Code>
                            <na:Name>EEDITSESSIONINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetDestroyRequest"/>
            <output message="na:DatasetDestroyResponse"/>
        </operation>
        <operation name="DatasetDynamicReferenceListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of the dynamic references in the Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetDynamicReferenceListInfoIterEndRequest"/>
            <output message="na:DatasetDynamicReferenceListInfoIterEndResponse"/>
        </operation>
        <operation name="DatasetDynamicReferenceListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next Records in the iteration started by DatasetDynamicReferenceListInfoIterStart</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetDynamicReferenceListInfoIterNextRequest"/>
            <output message="na:DatasetDynamicReferenceListInfoIterNextResponse"/>
        </operation>
        <operation name="DatasetDynamicReferenceListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list the dynamic references in the Dataset. Volumes are not considered dynamic references because they are Members. (even though they can contain Qtrees)</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22283</na:Code>
                            <na:Name>ESTORAGESETNOTINDATASET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetDynamicReferenceListInfoIterStartRequest"/>
            <output message="na:DatasetDynamicReferenceListInfoIterStartResponse"/>
        </operation>
        <operation name="DatasetEditBegin">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Obtain an edit lock To start modifying a Dataset. &lt;P&gt;Besides locking the Dataset itself, all storage sets in the Dataset are locked, as well as the data protection Policy if one is assigned. &lt;P&gt;An edit lock must be obtained before invoking the following ZAPIs: &lt;UL&gt; &lt;LI&gt;DatasetAddMember &lt;LI&gt;DatasetRemoveMember &lt;LI&gt;DatasetAddMemberByDynamicReference &lt;LI&gt;DatasetRemoveMemberByDynamicReference &lt;LI&gt;DatasetSetStorageset &lt;LI&gt;DatasetModify &lt;LI&gt;DatasetModifyNode &lt;LI&gt;DatasetAddResourcepool &lt;LI&gt;DatasetRemoveResourcepool &lt;LI&gt;DatasetProvisionMember &lt;LI&gt;DatasetResizeMember &lt;LI&gt;DatasetMemberDeleteSnapshots &lt;/UL&gt; Use DatasetEditCommit To commit the changes To the database. &lt;P&gt;Use DatasetEditRollback To undo the changes made To the Dataset. &lt;P&gt;After 24 hours, the lock can be taken by another client without the Force Option. This will cause any edits pending on the aborted session To be lost.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23416</na:Code>
                            <na:Name>EDATASETFAILINGOVER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23510</na:Code>
                            <na:Name>EDATASETMIGRATING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22243</na:Code>
                            <na:Name>EEDITSESSIONINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetEditBeginRequest"/>
            <output message="na:DatasetEditBeginResponse"/>
        </operation>
        <operation name="DatasetEditCommit">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Commit changes made To a Dataset into the database.&lt;P&gt; The edit lock on the Dataset will be released after the changes have been successfully committed.&lt;P&gt; Use the &lt;b&gt;DryRun&lt;/b&gt; Option To test the commit. It invokes the conformance checker To return a list of actions that would be taken should the changes be actually committed. The &lt;b&gt;DryRun&lt;/b&gt; Option also returns a list of high level alerts To notify the user of rebaseline operations or system level issues related To successful conformance. &lt;P&gt; If &lt;b&gt;DryRun&lt;/b&gt; is false, then before the call returns, the system begins a &lt;b&gt;conformance run&lt;/b&gt; on the Dataset. (See &lt;b&gt;DatasetConformBegin&lt;/b&gt; for a Description of conformance runs.) If the system is To perform a &lt;b&gt;conformance run&lt;/b&gt; on the Dataset it will be done with the current Dataset edit session Value for AssumeConfirmation. The default Value for AssumeConfirmation is initially true when the edit session begins, but may be altered by certain changes To the Dataset made through the use of &lt;b&gt;DatasetModify&lt;/b&gt;. The optional &lt;b&gt;AssumeConfirmation&lt;/b&gt; Option may be used To specify if user confirmation is To be assumed or not for this &lt;b&gt;DatasetEditCommit&lt;/b&gt;. One Key, and sometimes undesirable, resolvable Action that requires user confirmation is the possible re-baseline of a relationship.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23416</na:Code>
                            <na:Name>EDATASETFAILINGOVER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23510</na:Code>
                            <na:Name>EDATASETMIGRATING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22295</na:Code>
                            <na:Name>EDSCONFLICTCANTMIRROROSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22296</na:Code>
                            <na:Name>EDSCONFLICTCANTSNAPSHOTOSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22334</na:Code>
                            <na:Name>EDSCONFLICTINCOMPATIBLEPOLICY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22297</na:Code>
                            <na:Name>EDSCONFLICTNOSMLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22298</na:Code>
                            <na:Name>EDSCONFLICTNOSMSVLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22301</na:Code>
                            <na:Name>EDSCONFLICTNOTLEAFNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22300</na:Code>
                            <na:Name>EDSCONFLICTNOTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22335</na:Code>
                            <na:Name>EDSCONFLICTOSSVNOTALLOWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22299</na:Code>
                            <na:Name>EDSCONFLICTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetEditCommitRequest"/>
            <output message="na:DatasetEditCommitResponse"/>
        </operation>
        <operation name="DatasetEditRollback">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Roll back changes made To a Dataset. The edit lock on the Dataset will be released after the rollback.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetEditRollbackRequest"/>
            <output message="na:DatasetEditRollbackResponse"/>
        </operation>
        <operation name="DatasetListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list Datasets.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetListInfoIterEndRequest"/>
            <output message="na:DatasetListInfoIterEndResponse"/>
        </operation>
        <operation name="DatasetListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DatasetListInfoIterStart. &lt;p&gt; If a Dataset has a data protection Policy assigned To it, the HasProtectionPolicy field will be true. If the client has suspended the Dataset, HasProtectionPolicy is still true, but IsDpSuspended and IsSuspended fields are also set To true To reflect this. When the client sets IsDpIgnored To true, nothing changes, except that, when the client requests the list of Datasets which are not ignored, the ignored Datasets will not be returned.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetListInfoIterNextRequest"/>
            <output message="na:DatasetListInfoIterNextResponse"/>
        </operation>
        <operation name="DatasetListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Datasets.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetListInfoIterStartRequest"/>
            <output message="na:DatasetListInfoIterStartResponse"/>
        </operation>
        <operation name="DatasetMemberDedupeAbort">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Abort in-progress dedupe Operation on the given Volume member of the Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23503</na:Code>
                            <na:Name>EDEDUPEABORTNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23506</na:Code>
                            <na:Name>EDEDUPENOTRUNNING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22219</na:Code>
                            <na:Name>EJOBALREADYABORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22218</na:Code>
                            <na:Name>EJOBALREADYCOMPLETED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberDedupeAbortRequest"/>
            <output message="na:DatasetMemberDedupeAbortResponse"/>
        </operation>
        <operation name="DatasetMemberDedupeStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start deduplication Operation on specified Volume member of the given Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23505</na:Code>
                            <na:Name>EDEDUPEALREADYRUNNING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23501</na:Code>
                            <na:Name>EDEDUPENOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22242</na:Code>
                            <na:Name>ENOTINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberDedupeStartRequest"/>
            <output message="na:DatasetMemberDedupeStartResponse"/>
        </operation>
        <operation name="DatasetMemberDeleteSnapshots">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete Snapshot copies of a Volume which is a member of the effective primary node of the Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the root node of the Dataset. The effective primary of a disaster recovery Dataset in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;The deletion of Snapshot copies happens in the background. &lt;P&gt;A provisioning job Id is returned in DatasetEditCommit zapi that represents the job which will delete the specified Snapshot copies. The Status of the job can be checked using DpJobListIterStart ZAPIs with the given JobId. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To delete Snapshot copies of the member. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EOBJECTNOTFOUND - No Volume by the given Name or identifier was found. &lt;LI&gt; ENOTINDATASET - Member is not in the primary node of the specified Dataset. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified member Name could refer To two or more Objects. Try again with the object identifier or object full Name. &lt;LI&gt; EINVALIDINPUT - No Snapshot copies are specified for deletion or both VolumeId and VolumeName are not given in input or at least one of the Snapshot copies specified for deletion is marked busy. &lt;LI&gt; ESNAPSHOTNOTFOUND - At least one of the Snapshot copy specified is not found on the Volume. &lt;LI&gt; EEDITSESSIONNOTFOUND - If the edit session specified in input is not found &lt;LI&gt; EEDITSESSIONOBJECTALREADYLOCKED - If the object being tried To lock in this Operation is already locked by some other edit session &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - If this Snapshot deletion Operation is conflicting with some other edit Operation in the same edit session &lt;LI&gt; EDATASETNOTINSTABLEDRSTATE - The Dataset is not in a stable disaster recovery state. &lt;/UL&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23412</na:Code>
                            <na:Name>EDATASETNOTINSTABLEDRSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22263</na:Code>
                            <na:Name>EEDITSESSIONOBJECTALREADYLOCKED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22242</na:Code>
                            <na:Name>ENOTINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberDeleteSnapshotsRequest"/>
            <output message="na:DatasetMemberDeleteSnapshotsResponse"/>
        </operation>
        <operation name="DatasetMemberListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of Dataset Members.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberListInfoIterEndRequest"/>
            <output message="na:DatasetMemberListInfoIterEndResponse"/>
        </operation>
        <operation name="DatasetMemberListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next Records in the iteration started by DatasetMemberListInfoIterStart</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberListInfoIterNextRequest"/>
            <output message="na:DatasetMemberListInfoIterNextResponse"/>
        </operation>
        <operation name="DatasetMemberListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Members of the Dataset. Dynamic references are not returned by this API, nor are Objects only associated with the Dataset by their inclusion in a dynamic reference.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22283</na:Code>
                            <na:Name>ESTORAGESETNOTINDATASET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberListInfoIterStartRequest"/>
            <output message="na:DatasetMemberListInfoIterStartResponse"/>
        </operation>
        <operation name="DatasetMemberUndedupeStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start undeduplication Operation on specified Volume member of the given Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22242</na:Code>
                            <na:Name>ENOTINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23502</na:Code>
                            <na:Name>EUNDEDUPENOTSUPPORTED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMemberUndedupeStartRequest"/>
            <output message="na:DatasetMemberUndedupeStartResponse"/>
        </operation>
        <operation name="DatasetMissingMemberListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of missing Dataset Members.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMissingMemberListInfoIterEndRequest"/>
            <output message="na:DatasetMissingMemberListInfoIterEndResponse"/>
        </operation>
        <operation name="DatasetMissingMemberListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next Records in the iteration started by DatasetMemberListInfoIterStart</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMissingMemberListInfoIterNextRequest"/>
            <output message="na:DatasetMissingMemberListInfoIterNextResponse"/>
        </operation>
        <operation name="DatasetMissingMemberListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Members of the Dataset that have gone missing. The way the server determines if an object was not intentionally removed From the Dataset is: &lt;ol&gt; &lt;li&gt;The object is still a Dataset member. &lt;li&gt;The object's objDeleted flag is set. &lt;/ol&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetMissingMemberListInfoIterStartRequest"/>
            <output message="na:DatasetMissingMemberListInfoIterStartResponse"/>
        </operation>
        <operation name="DatasetModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify Attributes for a Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22212</na:Code>
                            <na:Name>EDATASETEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22295</na:Code>
                            <na:Name>EDSCONFLICTCANTMIRROROSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22296</na:Code>
                            <na:Name>EDSCONFLICTCANTSNAPSHOTOSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22334</na:Code>
                            <na:Name>EDSCONFLICTINCOMPATIBLEPOLICY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23406</na:Code>
                            <na:Name>EDSCONFLICTNDRESTORE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22297</na:Code>
                            <na:Name>EDSCONFLICTNOSMLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22298</na:Code>
                            <na:Name>EDSCONFLICTNOSMSVLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22301</na:Code>
                            <na:Name>EDSCONFLICTNOTLEAFNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22300</na:Code>
                            <na:Name>EDSCONFLICTNOTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22335</na:Code>
                            <na:Name>EDSCONFLICTOSSVNOTALLOWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22299</na:Code>
                            <na:Name>EDSCONFLICTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22263</na:Code>
                            <na:Name>EEDITSESSIONOBJECTALREADYLOCKED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23517</na:Code>
                            <na:Name>ESERVICEISATTACHED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetModifyRequest"/>
            <output message="na:DatasetModifyResponse"/>
        </operation>
        <operation name="DatasetModifyNode">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify Attributes of a single storage set that is part of a Dataset. The storage set is specified implicitly by the Name of the data protection Policy node that maps To it. You may change the storage set's Resource pool and Timezone using this call, but not its Name or Description.&lt;P&gt; Within the same edit session in which you call &lt;b&gt;DatasetModifyNode&lt;/b&gt;, you may also add or remove Members or dynamic references, or change the Dataset's Name, Description, &lt;b&gt;IsDpIgnored&lt;/b&gt;, &lt;b&gt;IsDpSuspended&lt;/b&gt;, or &lt;b&gt;IsSuspended&lt;/b&gt;. You may not change the data set's Policy or storage sets within the same edit session. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was foundthat has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To modify the storage set. &lt;LI&gt; EOBJECTAMBIGUOUS - The Name given for the storage set or Resource pool matches multiple storage sets or Resource pools. &lt;LI&gt; EOBJECTNOTFOUND - No storage set or Resource pool was found that has the given Name or identifier. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; ESTORAGESETNOTINDATASET - The specified storage set is not a part of the Dataset being edited. &lt;LI&gt; EDPPOLICYNODENOTFOUND - No DP Policy node was found that has the given Name. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EINVALIDTIMEZONE - The given Timezone Name is not valid. &lt;LI&gt; EDSCONFLICTALREADYINDATASET - Object, its ancestor or descendent is already in Dataset. &lt;LI&gt; EDSCONFLICTSRCDESTINSAMEAGGR - Source data and destination data are in the same Aggregate. &lt;LI&gt; EDSCONFLICTALREADYINRESPOOL - Object, its ancestor or descendent is already in Resource pool. &lt;LI&gt; EDSCONFLICTCANTMIRROROSSV - OSSV is not allowed in mirror Source node. &lt;LI&gt; EDSCONFLICTCANTSNAPSHOTOSSV - Cannot apply Snapshot schedule To OSSV. &lt;LI&gt; EDSCONFLICTINCOMPATIBLEPOLICY - Policy is not compatible with application Dataset. &lt;LI&gt; EDSCONFLICTOSSVNOTALLOWED - OSSV is not allowed in the Dataset. &lt;LI&gt; EDSCONFLICTNOSMLICENSE - There is no SnapMirror License installed. &lt;LI&gt; EDSCONFLICTNOSMSVLICENSE - There is no SnapMirror or SnapVault License installed. Need To have at least one of them installed. &lt;LI&gt; EDSCONFLICTROOTNODE - Operation cannot be performed on root node of Dataset. &lt;LI&gt; EDSCONFLICTNOTROOTNODE - Operation cannot be performed on non-root node of Dataset. &lt;LI&gt; EDSCONFLICTNOTLEAFNODE - Operation cannot be performed on non-leaf node of Dataset. &lt;LI&gt; EDSCONFLICTINVALIDVFILER - Dataset node has Members that do not belong To the vFiler being attached. &lt;LI&gt;EDSCONFLICTDEDUPLICATION - A deduplication schedule enabled provisioning Policy cannot be associated with SnapVault destinations. &lt;/UL&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22295</na:Code>
                            <na:Name>EDSCONFLICTCANTMIRROROSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22296</na:Code>
                            <na:Name>EDSCONFLICTCANTSNAPSHOTOSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22334</na:Code>
                            <na:Name>EDSCONFLICTINCOMPATIBLEPOLICY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23342</na:Code>
                            <na:Name>EDSCONFLICTINVALIDVFILER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22297</na:Code>
                            <na:Name>EDSCONFLICTNOSMLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22298</na:Code>
                            <na:Name>EDSCONFLICTNOSMSVLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22301</na:Code>
                            <na:Name>EDSCONFLICTNOTLEAFNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22300</na:Code>
                            <na:Name>EDSCONFLICTNOTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22335</na:Code>
                            <na:Name>EDSCONFLICTOSSVNOTALLOWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22299</na:Code>
                            <na:Name>EDSCONFLICTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>14517</na:Code>
                            <na:Name>EINVALIDTIMEZONE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23413</na:Code>
                            <na:Name>ENODENOTDRCAPABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23517</na:Code>
                            <na:Name>ESERVICEISATTACHED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22283</na:Code>
                            <na:Name>ESTORAGESETNOTINDATASET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetModifyNodeRequest"/>
            <output message="na:DatasetModifyNodeResponse"/>
        </operation>
        <operation name="DatasetProvisionMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Provision a new member into the effective primary node of a Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the Dataset root node. The effective primary node of a disaster recovery Dataset in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;Error conditions: &lt;ul&gt; &lt;LI&gt; EINVALIDINPUT - If the inputs specified are not valid. &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To provision a member. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EDATASETNOTINSTABLEDRSTATE - The Dataset is not in a stable disaster recovery state. &lt;/ul&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23412</na:Code>
                            <na:Name>EDATASETNOTINSTABLEDRSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22283</na:Code>
                            <na:Name>ESTORAGESETNOTINDATASET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetProvisionMemberRequest"/>
            <output message="na:DatasetProvisionMemberResponse"/>
        </operation>
        <operation name="DatasetRemoveMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove member From a Dataset. Only Members explicitly added To the Dataset (direct Members) can be removed. &lt;P&gt; If "Destroy" is true, even indirect Members can be destroyed on the storage system and removed From the Dataset. &lt;P&gt; If "Destroy" is true, then it is applicable only on Members of the effective primary node of the Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the Dataset root node. The effective primary node of a disaster recovery Dataset in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;The Destroy Operation happens in the background. &lt;P&gt;A provisioning job Id is returned in DatasetEditCommit api that represents the job which will resize the member as specified. The Status of the job can be checked using DpJobListIterStart ZAPIs with the given JobId.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23345</na:Code>
                            <na:Name>ECANNOTDESTROYSTORAGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23336</na:Code>
                            <na:Name>EINVALIDOBJECTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22242</na:Code>
                            <na:Name>ENOTINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetRemoveMemberRequest"/>
            <output message="na:DatasetRemoveMemberResponse"/>
        </operation>
        <operation name="DatasetRemoveMemberByDynamicReference">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove dynamic references From a Dataset. Only dynamic_references explicitly added To the Dataset can be removed.&lt;P&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22242</na:Code>
                            <na:Name>ENOTINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetRemoveMemberByDynamicReferenceRequest"/>
            <output message="na:DatasetRemoveMemberByDynamicReferenceResponse"/>
        </operation>
        <operation name="DatasetRemoveResourcepool">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove Resource pool From a single storage set that is part of a Dataset. The storage set is specified implicitly by the Name of the Policy node that maps To it.&lt;P&gt; Within the same edit session in which you call &lt;b&gt;DatasetRemoveResourcepool&lt;/b&gt;, you may also add or remove Members or dynamic references, or change the Dataset's Name, Description, &lt;b&gt;IsDpIgnored&lt;/b&gt;, &lt;b&gt;IsDpSuspended&lt;/b&gt;, or &lt;b&gt;IsSuspended&lt;/b&gt;. You may not change the data set's protection Policy or storage sets within the same edit session. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given identifier. &lt;LI&gt; EACCESSDENIED - User does not have Permission To modify the storage set. &lt;LI&gt; EOBJECTAMBIGUOUS - The Name given for the storage set or Resource pool matches multiple storage sets or Resource pools. &lt;LI&gt; EOBJECTNOTFOUND - No storage set or Resource pool was found that has the given Name or identifier. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; ESTORAGESETNOTINDATASET - The specified storage set is not a part of the Dataset being edited. &lt;LI&gt; EDPPOLICYNODENOTFOUND - No DP Policy node was found that has the given Name. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - The requested modification conflicts with other changes performed during the edit session. &lt;LI&gt; EDSCONFLICTALREADYINDATASET - Object, its ancestor or descendent is already in Dataset. &lt;LI&gt; EDSCONFLICTSRCDESTINSAMEAGGR - Source data and destination data are in the same Aggregate. &lt;LI&gt; EDSCONFLICTALREADYINRESPOOL - Object, its ancestor or descendent is already in Resource pool. &lt;/UL&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23517</na:Code>
                            <na:Name>ESERVICEISATTACHED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22283</na:Code>
                            <na:Name>ESTORAGESETNOTINDATASET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetRemoveResourcepoolRequest"/>
            <output message="na:DatasetRemoveResourcepoolResponse"/>
        </operation>
        <operation name="DatasetReplacePrimaryMembers">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Replace primary Members and relationships after a failover. &lt;P&gt;If a secondary Volume or Qtree is specified, it replaces the primary member for just that secondary Volume or Qtree. If neither are specified, it replaces all primary Members that need To be replaced. &lt;P&gt;If DryRun is specified, it returns the Results of the Operation that would be taken should the Operation be committed.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23416</na:Code>
                            <na:Name>EDATASETFAILINGOVER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23408</na:Code>
                            <na:Name>EDATASETNOTDRCAPABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23409</na:Code>
                            <na:Name>EDATASETNOTINFAILEDOVERSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22243</na:Code>
                            <na:Name>EEDITSESSIONINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetReplacePrimaryMembersRequest"/>
            <output message="na:DatasetReplacePrimaryMembersResponse"/>
        </operation>
        <operation name="DatasetResizeMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Resize, change Maximum capacity and change snap reserve for a Dataset member on the effective primary node of the Dataset. &lt;P&gt;The effective primary node for a non disaster recovery capable Dataset or a disaster recovery capable Dataset not in the DR state of "failed_over" is the Dataset root node. The effective primary of a disaster recovery data set in the DR state of "failed_over" is the disaster recovery capable node of the Dataset. &lt;P&gt;The resize Operation happens in the background. &lt;P&gt;A provisioning job Id is returned in DatasetEditCommit zapi that represents the job which will resize the member as specified. The Status of the job can be checked using DpJobListIterStart ZAPIs with the given JobId. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have the Capability DFM.ResourcePool.Provision on the containing Resource pool for a Volume that is being resized. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EOBJECTNOTFOUND - No Volume or Qtree member by the given Name or identifier was found. &lt;LI&gt; ENOTINDATASET - Member is not in the primary node of the specified Dataset. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified member Name could refer To two or more Objects. Try again with the object identifier or object full Name. &lt;LI&gt; EINVALIDINPUT - Both MemberId and MemberName are not specified, inputs other than NewSize are specified for a Qtree member, Size parameters are being changed for traditional Volumes. &lt;LI&gt; EEDITSESSIONNOTFOUND - If the edit session specified in input is not found &lt;LI&gt; EEDITSESSIONOBJECTALREADYLOCKED - If the object being tried To lock in this Operation is already locked by some other edit session &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - If this resize Operation is conflicting with some other edit Operation in the same edit session &lt;LI&gt; EDATASETNOTINSTABLEDRSTATE - The Dataset is not in a stable disaster recovery state. &lt;/UL&gt;</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23412</na:Code>
                            <na:Name>EDATASETNOTINSTABLEDRSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22263</na:Code>
                            <na:Name>EEDITSESSIONOBJECTALREADYLOCKED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22242</na:Code>
                            <na:Name>ENOTINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetResizeMemberRequest"/>
            <output message="na:DatasetResizeMemberResponse"/>
        </operation>
        <operation name="DatasetSet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Set Dataset Options.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetSetRequest"/>
            <output message="na:DatasetSetResponse"/>
        </operation>
        <operation name="DatasetSetStorageset">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change the storage sets associated with Policy nodes. It is legal To change many storage set/node mappings in an edit session.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22293</na:Code>
                            <na:Name>EDSCONFLICTALREADYINDATASET</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22294</na:Code>
                            <na:Name>EDSCONFLICTALREADYINRESPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22295</na:Code>
                            <na:Name>EDSCONFLICTCANTMIRROROSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22296</na:Code>
                            <na:Name>EDSCONFLICTCANTSNAPSHOTOSSV</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22334</na:Code>
                            <na:Name>EDSCONFLICTINCOMPATIBLEPOLICY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22297</na:Code>
                            <na:Name>EDSCONFLICTNOSMLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22298</na:Code>
                            <na:Name>EDSCONFLICTNOSMSVLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22301</na:Code>
                            <na:Name>EDSCONFLICTNOTLEAFNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22300</na:Code>
                            <na:Name>EDSCONFLICTNOTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22335</na:Code>
                            <na:Name>EDSCONFLICTOSSVNOTALLOWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22299</na:Code>
                            <na:Name>EDSCONFLICTROOTNODE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23514</na:Code>
                            <na:Name>EDSCONFLICTSRCDESTINSAMEAGGR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22263</na:Code>
                            <na:Name>EEDITSESSIONOBJECTALREADYLOCKED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23517</na:Code>
                            <na:Name>ESERVICEISATTACHED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetSetStoragesetRequest"/>
            <output message="na:DatasetSetStoragesetResponse"/>
        </operation>
        <operation name="DatasetUpdateDrStatus">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Update disaster recovery Status for a Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetUpdateDrStatusRequest"/>
            <output message="na:DatasetUpdateDrStatusResponse"/>
        </operation>
        <operation name="DatasetUpdateProtectionStatus">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Update protection Status for a Dataset.</na:Description>
                    <na:Category>Dataset</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DatasetUpdateProtectionStatusRequest"/>
            <output message="na:DatasetUpdateProtectionStatusResponse"/>
        </operation>
        <operation name="DfmAbout">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve information currently provided by the 'dfm about' command.</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmAboutRequest"/>
            <output message="na:DfmAboutResponse"/>
        </operation>
        <operation name="DfmGetApiStatistics">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve information about the API call frequencies on the DFM server</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmGetApiStatisticsRequest"/>
            <output message="na:DfmGetApiStatisticsResponse"/>
        </operation>
        <operation name="DfmGetResourcePropertyValues">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Gets the list of Resource Properties and the Values that can be set as filters for Thresholds. The list of Resource Properties are pre-defined, but the Values are obtained From the current set of Values in the database</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmGetResourcePropertyValuesRequest"/>
            <output message="na:DfmGetResourcePropertyValuesResponse"/>
        </operation>
        <operation name="DfmObjectRefresh">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Request monitors be scheduled To run To refresh the information of the object specified. The monitors To be scheduled To run can be specified implicitly using ChildType or explicitly by providing MonitorNames. If both ChildType and MonitorNames are specified, it will be treated as an Error.</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmObjectRefreshRequest"/>
            <output message="na:DfmObjectRefreshResponse"/>
        </operation>
        <operation name="DfmObjectsGetStatus">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get Status for DFM Objects This api always returns true. It returns the Status for all the Objects that are passed in. A ObjectNameOrId of "0" indicates the "global Group" Privelege required is read</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmObjectsGetStatusRequest"/>
            <output message="na:DfmObjectsGetStatusResponse"/>
        </operation>
        <operation name="DfmRelatedObjectsListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve information about Objects related To a DFM object. This api takes an object as input and returns the information about parent Objects of that object, Resource Groups, Datasets and Resource pools the object belongs To and Objects that belong To the specified object. Privilege required is DFM.Database.Read on the specified object. Parent output Objects are returned only if the authenticated user has DFM.Database.Read Privilege on that parent object. For e.g. Group To which an object belongs is returned only if the authenticated user has DFM.Database.Read Privilege on that Group.</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmRelatedObjectsListInfoRequest"/>
            <output message="na:DfmRelatedObjectsListInfoResponse"/>
        </operation>
        <operation name="DfmScheduleContentGet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the content of a given schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleContentGetRequest"/>
            <output message="na:DfmScheduleContentGetResponse"/>
        </operation>
        <operation name="DfmScheduleCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new schedule with the given Name. The schedule Type may be daily, weekly, or monthly.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22202</na:Code>
                            <na:Name>ESCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleCreateRequest"/>
            <output message="na:DfmScheduleCreateResponse"/>
        </operation>
        <operation name="DfmScheduleDailyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a single schedule within a daily schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleDailyAddRequest"/>
            <output message="na:DfmScheduleDailyAddResponse"/>
        </operation>
        <operation name="DfmScheduleDailyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a single schedule within a daily schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleDailyDeleteRequest"/>
            <output message="na:DfmScheduleDailyDeleteResponse"/>
        </operation>
        <operation name="DfmScheduleDailyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a single schedule within a daily schedule. Sample schedules cannot be modified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleDailyModifyRequest"/>
            <output message="na:DfmScheduleDailyModifyResponse"/>
        </operation>
        <operation name="DfmScheduleDependency">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Return a list of other DP policies, report schedule and schedules using the specified schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleDependencyRequest"/>
            <output message="na:DfmScheduleDependencyResponse"/>
        </operation>
        <operation name="DfmScheduleDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a schedule with the given Name or ID. A schedule that is used by another schedule(s) may not be deleted and an Error will be returned. Sample schedules cannot be destroyed.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22203</na:Code>
                            <na:Name>ESCHEDULEINUSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleDestroyRequest"/>
            <output message="na:DfmScheduleDestroyResponse"/>
        </operation>
        <operation name="DfmScheduleHourlyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create an hourly schedule within a daily schedule. An hourly schedule specifies the Frequency of schedules To be run within the start time and end time.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleHourlyAddRequest"/>
            <output message="na:DfmScheduleHourlyAddResponse"/>
        </operation>
        <operation name="DfmScheduleHourlyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete an hourly schedule within a daily schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleHourlyDeleteRequest"/>
            <output message="na:DfmScheduleHourlyDeleteResponse"/>
        </operation>
        <operation name="DfmScheduleHourlyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an hourly schedule within a daily schedule. Sample schedules cannot be modified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleHourlyModifyRequest"/>
            <output message="na:DfmScheduleHourlyModifyResponse"/>
        </operation>
        <operation name="DfmScheduleList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List all existing schedule IDs and types.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleListRequest"/>
            <output message="na:DfmScheduleListResponse"/>
        </operation>
        <operation name="DfmScheduleListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Tell the DFM station that the temporary store associated with the specified Tag is no longer necessary</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleListInfoIterEndRequest"/>
            <output message="na:DfmScheduleListInfoIterEndResponse"/>
        </operation>
        <operation name="DfmScheduleListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Iterate over the list of schedules stored in the temporary store. The DFM internally maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleListInfoIterNextRequest"/>
            <output message="na:DfmScheduleListInfoIterNextResponse"/>
        </operation>
        <operation name="DfmScheduleListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The DfmScheduleListInfoIter* set of APIs are used To retrieve a list of schedule contents</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleListInfoIterStartRequest"/>
            <output message="na:DfmScheduleListInfoIterStartResponse"/>
        </operation>
        <operation name="DfmScheduleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a schedule's details in the database. When the zapi is called, all details within the schedule will be removed and replace by the new details specified in schedule-content. Sample schedules cannot be modified. ScheduleId and ScheduleType cannot be modified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22202</na:Code>
                            <na:Name>ESCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleModifyRequest"/>
            <output message="na:DfmScheduleModifyResponse"/>
        </operation>
        <operation name="DfmScheduleMonthlyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify a single schedule within a monthly schedule. Either DayOfMonth, or both WeekOfMonth and DayOfWeek must be specified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleMonthlyAddRequest"/>
            <output message="na:DfmScheduleMonthlyAddResponse"/>
        </operation>
        <operation name="DfmScheduleMonthlyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a single schedule within a monthly schedule</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleMonthlyDeleteRequest"/>
            <output message="na:DfmScheduleMonthlyDeleteResponse"/>
        </operation>
        <operation name="DfmScheduleMonthlyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a single schedule within a monthly schedule. Sample schedules cannot be modified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleMonthlyModifyRequest"/>
            <output message="na:DfmScheduleMonthlyModifyResponse"/>
        </operation>
        <operation name="DfmScheduleMonthlySubscheduleSet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify a sub-schedule To be used by a monthly schedule. On top of the individual monthly Events, a monthly schedule may only have 1 daily subschedule OR 1 weekly schedule. If this monthly schedule already has a daily or weekly schedule, this command replaces the old one.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleMonthlySubscheduleSetRequest"/>
            <output message="na:DfmScheduleMonthlySubscheduleSetResponse"/>
        </operation>
        <operation name="DfmScheduleMonthlySubscheduleUnset">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Unset a sub-schedule used by a monthly schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleMonthlySubscheduleUnsetRequest"/>
            <output message="na:DfmScheduleMonthlySubscheduleUnsetResponse"/>
        </operation>
        <operation name="DfmScheduleRename">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Rename a schedule. Sample schedules cannot be renamed.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22202</na:Code>
                            <na:Name>ESCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleRenameRequest"/>
            <output message="na:DfmScheduleRenameResponse"/>
        </operation>
        <operation name="DfmScheduleWeeklyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify a single schedule within a weekly schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleWeeklyAddRequest"/>
            <output message="na:DfmScheduleWeeklyAddResponse"/>
        </operation>
        <operation name="DfmScheduleWeeklyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a single schedule within a weekly schedule.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleWeeklyDeleteRequest"/>
            <output message="na:DfmScheduleWeeklyDeleteResponse"/>
        </operation>
        <operation name="DfmScheduleWeeklyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a single schedule within a weekly schedule. Sample schedules canot be modified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleWeeklyModifyRequest"/>
            <output message="na:DfmScheduleWeeklyModifyResponse"/>
        </operation>
        <operation name="DfmScheduleWeeklySubscheduleAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify which daily schedule will be used on a certain range of Days within a weekly schedule</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleWeeklySubscheduleAddRequest"/>
            <output message="na:DfmScheduleWeeklySubscheduleAddResponse"/>
        </operation>
        <operation name="DfmScheduleWeeklySubscheduleDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify which daily schedule To be deleted within a weekly schedule</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleWeeklySubscheduleDeleteRequest"/>
            <output message="na:DfmScheduleWeeklySubscheduleDeleteResponse"/>
        </operation>
        <operation name="DfmScheduleWeeklySubscheduleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify which daily schedule will be used on a certain range of Days within a weekly schedule. Permenent of sample schedules cannot be modified.</na:Description>
                    <na:Category>DfmSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmScheduleWeeklySubscheduleModifyRequest"/>
            <output message="na:DfmScheduleWeeklySubscheduleModifyResponse"/>
        </operation>
        <operation name="DfmServerListDiagnosticInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve server diagnostic information</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmServerListDiagnosticInfoRequest"/>
            <output message="na:DfmServerListDiagnosticInfoResponse"/>
        </operation>
        <operation name="DfmUserPrivGet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve current user's global Privilege. This api is no longer the preferred way To getting user privileges. Use RbacAccessCheck.</na:Description>
                    <na:Category>Dfm</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21003</na:Code>
                            <na:Name>ENAMENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DfmUserPrivGetRequest"/>
            <output message="na:DfmUserPrivGetResponse"/>
        </operation>
        <operation name="DiskListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The DiskListInfoIter* set of APIs are used To retrieve the list of Disks. DiskListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the DiskListInfoIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Disk</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DiskListInfoIterEndRequest"/>
            <output message="na:DiskListInfoIterEndResponse"/>
        </operation>
        <operation name="DiskListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check DiskListInfoIterStart. The DiskListInfoIterNext API is used To iterate over the Members of the Disks stored in the temporary store created by the DiskListInfoIterStart API.</na:Description>
                    <na:Category>Disk</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DiskListInfoIterNextRequest"/>
            <output message="na:DiskListInfoIterNextResponse"/>
        </operation>
        <operation name="DiskListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The DiskListInfoIter* set of APIs are used To retrieve the list of Disks in DFM. DiskListInfoIterStart returns the disk belonging To Objects specified. It loads the list of Disks into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Disks in the temporary store. If DiskListInfoIterStart is invoked twice, then two distinct temporary stores are created.</na:Description>
                    <na:Category>Disk</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DiskListInfoIterStartRequest"/>
            <output message="na:DiskListInfoIterStartResponse"/>
        </operation>
        <operation name="DpBackupContentListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list file contents of a backup.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupContentListIterEndRequest"/>
            <output message="na:DpBackupContentListIterEndResponse"/>
        </operation>
        <operation name="DpBackupContentListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpBackupContentListIterStart.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupContentListIterNextRequest"/>
            <output message="na:DpBackupContentListIterNextResponse"/>
        </operation>
        <operation name="DpBackupContentListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list contents of a backup. Files and Directories directly under specified Path are listed. In order To list all files recursively, multiple invocations of this API are necessary.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22281</na:Code>
                            <na:Name>EBACKUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22290</na:Code>
                            <na:Name>EBACKUPLOCATIONDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22291</na:Code>
                            <na:Name>EPATHDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupContentListIterStartRequest"/>
            <output message="na:DpBackupContentListIterStartResponse"/>
        </operation>
        <operation name="DpBackupGetLocation">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Given a BackupId or the BackupVersion and a list of member-ids or member-names, returns the Snapshot Name, Volume that it exists on as well as the secondary Qtree associated with the member Id. If more than one Snapshots Match the BackupId or BackupVersion, only one, the first item in the resulting list, is returned. Multiple matches occur when the same backup Version exists on multiple nodes. In case of mutiple matches which Snapshot gets picked is unspecified.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupGetLocationRequest"/>
            <output message="na:DpBackupGetLocationResponse"/>
        </operation>
        <operation name="DpBackupListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list Backups.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupListIterEndRequest"/>
            <output message="na:DpBackupListIterEndResponse"/>
        </operation>
        <operation name="DpBackupListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpBackupListIterStart.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupListIterNextRequest"/>
            <output message="na:DpBackupListIterNextResponse"/>
        </operation>
        <operation name="DpBackupListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Backups of a Dataset or a Path within Dataset.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22281</na:Code>
                            <na:Name>EBACKUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22291</na:Code>
                            <na:Name>EPATHDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupListIterStartRequest"/>
            <output message="na:DpBackupListIterStartResponse"/>
        </operation>
        <operation name="DpBackupStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start an unscheduled backup of a Dataset. All Members of the Dataset will be backed up. A background job will be spawned To backup the Dataset.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupStartRequest"/>
            <output message="na:DpBackupStartResponse"/>
        </operation>
        <operation name="DpBackupVersionCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a backup Version. Backup Version is collection of Volume Snapshots and denotes a single backed up image of a Dataset. The management station keeps track of actual Volumes that hold the Dataset backup using backup versions.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupVersionCreateRequest"/>
            <output message="na:DpBackupVersionCreateResponse"/>
        </operation>
        <operation name="DpBackupVersionDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete an existing backup Version From the database and delete the Snapshots From the storage systems for this backup Version. The backup Version must currently exist. This API does not provide transaction semantics. When API returns an Error, the backup Version may have been partially deleted. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EBACKUPDOESNOTEXIST - The backup Version was not found. &lt;LI&gt; EBACKUPBUSY - The backup Version is busy. This can happen if one of the Snapshots in the backup is needed for future transfers or if transfer From the backup is in progress. &lt;LI&gt; EINVALIDINPUT - Not enough inputs To determine Version properly. This can happen if less than three of Dataset, BackupVersion, and NodeName are used in the case where BackupId is not supplied. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested backup Version. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EOBJECTNOTFOUND - Dataset not found. &lt;/UL&gt;</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23410</na:Code>
                            <na:Name>EBACKUPBUSY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22281</na:Code>
                            <na:Name>EBACKUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupVersionDeleteRequest"/>
            <output message="na:DpBackupVersionDeleteResponse"/>
        </operation>
        <operation name="DpBackupVersionListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list backup versions.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupVersionListIterEndRequest"/>
            <output message="na:DpBackupVersionListIterEndResponse"/>
        </operation>
        <operation name="DpBackupVersionListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpBackupVersionListIterStart.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupVersionListIterNextRequest"/>
            <output message="na:DpBackupVersionListIterNextResponse"/>
        </operation>
        <operation name="DpBackupVersionListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list all backup versions for a given Dataset. Information returned includes the IDs of each Instance, the propagation Status for each Version, and job Id responsible for the backup. Clients should use this API if they want a list of backup versions rather than backup Instances.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22281</na:Code>
                            <na:Name>EBACKUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22291</na:Code>
                            <na:Name>EPATHDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupVersionListIterStartRequest"/>
            <output message="na:DpBackupVersionListIterStartResponse"/>
        </operation>
        <operation name="DpBackupVersionModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modifies a backup Version. Either the BackupId or some combination of the DatasetNameOrId, NodeNameOrId and BackupVersion are used To specify an individual backup Instance or a set of backup Instances which represent the same backup Version. Certain inputs, such as IsAddingMembers, DpBackupTransferInfo and VersionMembers, can only be applied To a single backup Instance. When a backup Instance is transferred From one node To another, the Attributes of the backup Instance, BackupDescription and BackupMetadata, are copied at the beginning of the transfer. Any changes To these fields made after a backup Instance has been copied will not be propagated automatically. Specify only the DatasetNameOrId and BackupVersion To update the fields of all the backup Instances with the same BackupVersion.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22281</na:Code>
                            <na:Name>EBACKUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpBackupVersionModifyRequest"/>
            <output message="na:DpBackupVersionModifyResponse"/>
        </operation>
        <operation name="DpDashboardGetDrDatasetCounts">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Return number of disaster recovery enabled Datasets in all DrState and DrStatus combinations. The number of Datasets in each distinct dr-state/dr-status combination is returned. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</na:Description>
                    <na:Category>DpDashboard</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpDashboardGetDrDatasetCountsRequest"/>
            <output message="na:DpDashboardGetDrDatasetCountsResponse"/>
        </operation>
        <operation name="DpDashboardGetLaggedDatasets">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get a list of the most lagged Datasets. This API returns a list of some or all Datasets, sorted by Lag time. Only the Datasets Name, ID, and worst relationship Lag time are returned. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</na:Description>
                    <na:Category>DpDashboard</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpDashboardGetLaggedDatasetsRequest"/>
            <output message="na:DpDashboardGetLaggedDatasetsResponse"/>
        </operation>
        <operation name="DpDashboardGetLaggedRelationships">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get a list of the most lagged relationships. This API returns a list of some or all relationships, sorted by Lag time. Only the relationship Name, ID, and Lag time are returned. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</na:Description>
                    <na:Category>DpDashboard</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpDashboardGetLaggedRelationshipsRequest"/>
            <output message="na:DpDashboardGetLaggedRelationshipsResponse"/>
        </operation>
        <operation name="DpDashboardGetProtectedDataCounts">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>This zapi call has been deprecated in Juno (4.0) release, because the definitions for "protected" and "unprotected" Objects changed. Please use DpDashboardGetProtectedDataCounts2 instead. Get counts for certain types of Objects for displaying on the Protection Manager Dashboard. The types of Objects are: Datasets, Volumes, Qtrees, and OSSV Directories. For each object Type, the number of protected Objects, unprotected Objects, and ignored Objects is returned. And object is considered To be protected if it is a member of a Dataset, and a Dataset is considered To be protected if it has a protection Policy. Objects are unprotected if they are both not protected and not ignored. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</na:Description>
                    <na:Category>DpDashboard</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpDashboardGetProtectedDataCountsRequest"/>
            <output message="na:DpDashboardGetProtectedDataCountsResponse"/>
        </operation>
        <operation name="DpDashboardGetProtectedDataCounts2">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get counts for certain types of Objects for displaying on the Protection Manager Dashboard. The types of Objects are: Datasets, Volumes, Qtrees, and OSSV Directories. For each object Type, the number of protected, unprotected and ignored Objects are returned.&lt;BR&gt; An object is considered To be protected if it is: &lt;ul&gt; &lt;li&gt;1. A Dataset with a protection Policy assigned, and has conformed at least once. &lt;li&gt;2. Any Volume or Qtree in a Protection Manager managed relationship. &lt;li&gt;3. Any Host or Aggregate in a Dataset with protection Policy assigned. &lt;li&gt;4. Any Host in any Resource pool (does not have To be associated with any Dataset). &lt;li&gt;5. Any Aggregate that is either in any Resource pool themselves, or is a child of a Host that is a member of any Resource pool. &lt;/ul&gt; &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDATABASEERROR - A database-related Error occurred while processing the Request. Try again later. &lt;/UL&gt;</na:Description>
                    <na:Category>DpDashboard</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpDashboardGetProtectedDataCounts2Request"/>
            <output message="na:DpDashboardGetProtectedDataCounts2Response"/>
        </operation>
        <operation name="DpGetDatasetBackupJobsData">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns a set of Jobs To be spawned To backup the Dataset. This zapi is used To obtain data that is later used To start an on-demand backup of Dataset.</na:Description>
                    <na:Category>DpBackup</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpGetDatasetBackupJobsDataRequest"/>
            <output message="na:DpGetDatasetBackupJobsDataResponse"/>
        </operation>
        <operation name="DpJobAbort">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Abort a job. A Request is sent To abort the job. The job will go into an aborting state and will get aborted after sometime.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22219</na:Code>
                            <na:Name>EJOBALREADYABORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22218</na:Code>
                            <na:Name>EJOBALREADYCOMPLETED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22220</na:Code>
                            <na:Name>EJOBCANNOTBEABORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22217</na:Code>
                            <na:Name>EJOBDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobAbortRequest"/>
            <output message="na:DpJobAbortResponse"/>
        </operation>
        <operation name="DpJobListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list Jobs.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobListIterEndRequest"/>
            <output message="na:DpJobListIterEndResponse"/>
        </operation>
        <operation name="DpJobListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpJobListIterStart.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobListIterNextRequest"/>
            <output message="na:DpJobListIterNextResponse"/>
        </operation>
        <operation name="DpJobListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Jobs. The Jobs that Match all the specified filters will be returned.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23512</na:Code>
                            <na:Name>EINVALIDJOBSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23511</na:Code>
                            <na:Name>EINVALIDJOBTYPE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobListIterStartRequest"/>
            <output message="na:DpJobListIterStartResponse"/>
        </operation>
        <operation name="DpJobProgressEventListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list progress of job.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobProgressEventListIterEndRequest"/>
            <output message="na:DpJobProgressEventListIterEndResponse"/>
        </operation>
        <operation name="DpJobProgressEventListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpJobProgressEventListIterStart.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobProgressEventListIterNextRequest"/>
            <output message="na:DpJobProgressEventListIterNextResponse"/>
        </operation>
        <operation name="DpJobProgressEventListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list job progress Events. The event could be one of the following Type. &lt;ul&gt; &lt;li&gt; 'job-start' &lt;li&gt; 'JobProgress' &lt;li&gt; 'job-abort' &lt;li&gt; 'job-end' &lt;li&gt; 'job-retry' &lt;li&gt; 'rel-create-start' &lt;li&gt; 'rel-create-progress' &lt;li&gt; 'rel-create-end' &lt;li&gt; 'rel-destroy-start' &lt;li&gt; 'rel-destroy-progress' &lt;li&gt; 'rel-destroy-end' &lt;li&gt; 'snapshot-create' &lt;li&gt; 'snapshot-delete' &lt;li&gt; 'backup-create' &lt;li&gt; 'backup-delete' &lt;li&gt; 'snapvault-start' &lt;li&gt; 'snapvault-progress' &lt;li&gt; 'snapvault-end' &lt;li&gt; 'snapmirror-start' &lt;li&gt; 'snapmirror-progress' &lt;li&gt; 'snapmirror-end' &lt;li&gt; 'restore-start' &lt;li&gt; 'restore-progress' &lt;li&gt; 'restore-end' &lt;li&gt; 'MigrateStart' &lt;li&gt; 'migrate-progress' &lt;li&gt; 'migrate-end' &lt;li&gt; 'mirror-break-script-start' &lt;li&gt; 'mirror-break-script-end' &lt;li&gt; 'mirror-break-quiesce-start' &lt;li&gt; 'mirror-break-quiesce-end' &lt;li&gt; 'mirror-break-start' &lt;li&gt; 'mirror-break-end' &lt;li&gt; 'volume-create' &lt;li&gt; 'volume-resize' &lt;li&gt; 'volume-option-set' &lt;li&gt; 'snapshot-reserve-resize' &lt;li&gt; 'volume-autosize' &lt;li&gt; 'snapshot-autodelete' &lt;li&gt; 'lun-create' &lt;li&gt; 'lun-destroy' &lt;li&gt; 'lun-map' &lt;li&gt; 'lun-unmap' &lt;li&gt; 'igroup-create' &lt;li&gt; 'igroup-destroy' &lt;li&gt; 'igroup-add' &lt;li&gt; 'igroup-remove' &lt;li&gt; 'qtree-create' &lt;li&gt; 'quota-set' &lt;li&gt; 'nfsexport-create' &lt;li&gt; 'cifs-share-create' &lt;li&gt; 'cifs-share-modify' &lt;li&gt; 'cifs-share-delete' &lt;li&gt; 'volume-destroy' &lt;li&gt; 'qtree-destroy' &lt;li&gt; 'vfiler-storage-add' &lt;li&gt; 'script-run' &lt;li&gt; 'volume-dedupe' &lt;li&gt; 'volume-dedupe-enable' &lt;li&gt; 'volume-dedupe-schedule-set' &lt;li&gt; 'VfilerCreate' &lt;li&gt; 'VfilerSetup' &lt;li&gt; 'aggregate-space' &lt;/ul&gt;</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23512</na:Code>
                            <na:Name>EINVALIDJOBSTATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23511</na:Code>
                            <na:Name>EINVALIDJOBTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22217</na:Code>
                            <na:Name>EJOBDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobProgressEventListIterStartRequest"/>
            <output message="na:DpJobProgressEventListIterStartResponse"/>
        </operation>
        <operation name="DpJobPurge">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Purge all completed Jobs From the database. Purged Jobs are removed From the database, all information is lost.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22217</na:Code>
                            <na:Name>EJOBDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobPurgeRequest"/>
            <output message="na:DpJobPurgeResponse"/>
        </operation>
        <operation name="DpJobScheduleGetLastChanged">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Gets time when job schedule last changed. This is used by the scheduler Service To reload list of Jobs that need To run in future. Jobs that are already running are not affected.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobScheduleGetLastChangedRequest"/>
            <output message="na:DpJobScheduleGetLastChangedResponse"/>
        </operation>
        <operation name="DpJobScheduleListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list scheduled Jobs.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobScheduleListIterEndRequest"/>
            <output message="na:DpJobScheduleListIterEndResponse"/>
        </operation>
        <operation name="DpJobScheduleListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpJobScheduleListIterStart.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobScheduleListIterNextRequest"/>
            <output message="na:DpJobScheduleListIterNextResponse"/>
        </operation>
        <operation name="DpJobScheduleListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Jobs that need To be started by scheduler in specified time range. Scheduler Service periodically requests a list of scheduled data protection Jobs that will need To start within next few hours. Each item in this list is a Description of what needs To be done and time when it needs To be done. &lt;BR&gt; For example, a scheduled job might be: take a local Snapshot on node 1 of Dataset ds1 at 05/10/2006 9:00 AM UTC using "hourly" Retention. &lt;BR&gt; Scheduler Service is responsible for storing job into the database and starting the job at its start time.</na:Description>
                    <na:Category>DpJob</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpJobScheduleListIterStartRequest"/>
            <output message="na:DpJobScheduleListIterStartResponse"/>
        </operation>
        <operation name="DpOssvApplicationListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate an iteration started by DpOssvApplicationListInfoIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt;EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt;EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvApplicationListInfoIterEndRequest"/>
            <output message="na:DpOssvApplicationListInfoIterEndResponse"/>
        </operation>
        <operation name="DpOssvApplicationListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To DpOssvApplicationListInfoIterStart.</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvApplicationListInfoIterNextRequest"/>
            <output message="na:DpOssvApplicationListInfoIterNextResponse"/>
        </operation>
        <operation name="DpOssvApplicationListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Browse the application components supported by an OSSV Host.</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21020</na:Code>
                            <na:Name>EDIRDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvApplicationListInfoIterStartRequest"/>
            <output message="na:DpOssvApplicationListInfoIterStartResponse"/>
        </operation>
        <operation name="DpOssvApplicationRestoreDestinationListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate an iteration started by DpOssvApplicationRestoreDestinationListInfoIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt;EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt;EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvApplicationRestoreDestinationListInfoIterEndRequest"/>
            <output message="na:DpOssvApplicationRestoreDestinationListInfoIterEndResponse"/>
        </operation>
        <operation name="DpOssvApplicationRestoreDestinationListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To DpOssvApplicationRestoreDestinationListInfoIterStart</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvApplicationRestoreDestinationListInfoIterNextRequest"/>
            <output message="na:DpOssvApplicationRestoreDestinationListInfoIterNextResponse"/>
        </operation>
        <operation name="DpOssvApplicationRestoreDestinationListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List all the OSSV Hosts through which a restore To the original location is possible for a given application.</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvApplicationRestoreDestinationListInfoIterStartRequest"/>
            <output message="na:DpOssvApplicationRestoreDestinationListInfoIterStartResponse"/>
        </operation>
        <operation name="DpOssvDirectoryAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a new OSSV Directory To the list of discovered Directories. If the Directory already exists, return its object ID. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. There can be two applications with the same Name. Try specifying the application Path. &lt;LI&gt; EOBJECTNOTFOUND - The Host Name, IP Address, or Host ID was not found. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Host(s). &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDIRDOESNOTEXIST - The specified Directory was not found. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21020</na:Code>
                            <na:Name>EDIRDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22284</na:Code>
                            <na:Name>EOBJECTEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryAddRequest"/>
            <output message="na:DpOssvDirectoryAddResponse"/>
        </operation>
        <operation name="DpOssvDirectoryBrowseIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate an iteration started by DpOssvDirectoryBrowseIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryBrowseIterEndRequest"/>
            <output message="na:DpOssvDirectoryBrowseIterEndResponse"/>
        </operation>
        <operation name="DpOssvDirectoryBrowseIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To DpOssvDirectoryBrowseIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryBrowseIterNextRequest"/>
            <output message="na:DpOssvDirectoryBrowseIterNextResponse"/>
        </operation>
        <operation name="DpOssvDirectoryBrowseIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the list of Subdirectories beneath a given Directory on an OSSV Host. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. &lt;LI&gt; EOBJECTNOTFOUND - The Host Name, IP Address, or Host ID was not found. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Host(s). &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EDIRDOESNOTEXIST - The specified Directory was not found. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21020</na:Code>
                            <na:Name>EDIRDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryBrowseIterStartRequest"/>
            <output message="na:DpOssvDirectoryBrowseIterStartResponse"/>
        </operation>
        <operation name="DpOssvDirectoryDiscoveredIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate an iteration started by DpOssvDirectoryDiscoveredIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryDiscoveredIterEndRequest"/>
            <output message="na:DpOssvDirectoryDiscoveredIterEndResponse"/>
        </operation>
        <operation name="DpOssvDirectoryDiscoveredIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To DpOssvDirectoryDiscoveredIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryDiscoveredIterNextRequest"/>
            <output message="na:DpOssvDirectoryDiscoveredIterNextResponse"/>
        </operation>
        <operation name="DpOssvDirectoryDiscoveredIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List the OSSV Directories which have been discovered by the monitor. This list includes OSSV Roots, and siblings of Directories in backup relationships. The list can be filtered To exclude Directories which are marked as "ignored" and To exclude Directories which are protected. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. There can be two applications with the same Name. Try specifying the ID of the application. &lt;LI&gt; EOBJECTNOTFOUND - The lookup object was not found. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Directory object(s). &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryDiscoveredIterStartRequest"/>
            <output message="na:DpOssvDirectoryDiscoveredIterStartResponse"/>
        </operation>
        <operation name="DpOssvDirectoryModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a Directory's information. If modifying of one property fails, nothing will be changed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Directory. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EOBJECTNOTFOUND - When the DpOssvDirectoryNameOrId does not correspond To an ossv Directory. &lt;LI&gt; EDATABASEERROR - On database Error. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryModifyRequest"/>
            <output message="na:DpOssvDirectoryModifyResponse"/>
        </operation>
        <operation name="DpOssvDirectoryRootsIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate an iteration started by DpOssvDirectoryRootsIterStart and clean up any saved info. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryRootsIterEndRequest"/>
            <output message="na:DpOssvDirectoryRootsIterEndResponse"/>
        </operation>
        <operation name="DpOssvDirectoryRootsIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To DpOssvDirectoryRootsIterStart. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryRootsIterNextRequest"/>
            <output message="na:DpOssvDirectoryRootsIterNextResponse"/>
        </operation>
        <operation name="DpOssvDirectoryRootsIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the list of filesystem Roots From one or more OSSV Hosts. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Host Name could refer To 2 or more Hosts. Try again with a Host ID or a fully qualified Host Name or IP Address. &lt;LI&gt; EOBJECTNOTFOUND - The Host Name, IP Address, or Host ID was not found. &lt;LI&gt; EACCESSDENIED - Access was denied on the requested Host(s). &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;/UL&gt;</na:Description>
                    <na:Category>DpOssvDirectory</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpOssvDirectoryRootsIterStartRequest"/>
            <output message="na:DpOssvDirectoryRootsIterStartResponse"/>
        </operation>
        <operation name="DpPolicyCopy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new DP Policy by copying From an existing "template" Policy. &lt;P&gt; The new Policy created using this ZAPI has the same set of nodes and connections as the template Policy, and the same property Values for each node and connection. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the template Policy From the database, or create a new Policy, or both. &lt;LI&gt; EOBJECTNOTFOUND - No template Policy was found that has the given Name or ID. &lt;LI&gt; EPOLICYEXISTS - A Policy with the given &lt;b&gt;DpPolicyName&lt;/b&gt; already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EAPIMISSINGARGUMENT - No template Policy Name or Id was supplied as an input. &lt;LI&gt; EINVALIDINPUTERROR - Policy Description string was too long. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13006</na:Code>
                            <na:Name>EAPIMISSINGARGUMENT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22261</na:Code>
                            <na:Name>EPOLICYEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyCopyRequest"/>
            <output message="na:DpPolicyCopyResponse"/>
        </operation>
        <operation name="DpPolicyDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a DP Policy. This removes it From the database. &lt;P&gt; If the Policy has been applied To any Datasets, then the Destroy Operation fails; you must first un-map the Policy From any Datasets To which it had been applied before you may Destroy the Policy. &lt;P&gt; If this ZAPI fails for any Reason, the DP Policy edit of which it was a part is not rolled back. Instead, the edit is restored To the state it was in prior To invoking this ZAPI. &lt;P&gt; After this ZAPI successfully completes, any subsequent calls in the same edit session To &lt;b&gt;DpPolicyDestroy&lt;/b&gt; or &lt;b&gt;DpPolicyModify&lt;/b&gt; fail with Error code EOBJECTNOTFOUND. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EOBJECTNOTFOUND - The Policy was already destroyed during this edit session. &lt;LI&gt; EPOLICYNOTMODIFIABLE - The Policy is one of the samples created during installation, and therefore cannot be deleted. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22251</na:Code>
                            <na:Name>EPOLICYNOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyDestroyRequest"/>
            <output message="na:DpPolicyDestroyResponse"/>
        </operation>
        <operation name="DpPolicyEditBegin">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create an edit session and obtain an edit lock on a DP Policy To begin modifying the Policy. &lt;P&gt; An edit lock must be obtained before invoking the following APIs: &lt;UL&gt; &lt;LI&gt;&lt;b&gt;DpPolicyModify&lt;/b&gt; &lt;LI&gt;&lt;b&gt;DpPolicyDestroy&lt;/b&gt; &lt;/UL&gt; Use &lt;b&gt;DpPolicyEditCommit&lt;/b&gt; To end the edit session and commit the changes To the database. &lt;P&gt; Use &lt;b&gt;DpPolicyEditRollback&lt;/b&gt; To end the edit session and discard any changes made To the Policy. &lt;P&gt; 24 hours after an edit session on a Policy begins, any subsequent call To &lt;b&gt;DpPolicyEditBegin&lt;/b&gt; for that same Policy automatically rolls back the existing edit session and begins a new edit session, just as if the call had used the &lt;b&gt;Force&lt;/b&gt; Option. If there is no such call, the existing edit session simply continues and retains the edit lock. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITINPROGRESS - Another edit session already has an edit lock on the specified Policy. &lt;LI&gt; EOBJECTNOTFOUND - No Policy was found that has the given Name or ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22221</na:Code>
                            <na:Name>EEDITINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyEditBeginRequest"/>
            <output message="na:DpPolicyEditBeginResponse"/>
        </operation>
        <operation name="DpPolicyEditCommit">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Commit changes made To a DP Policy during an edit session into the database.&lt;P&gt; If all the changes To the Policy are performed successfully, the entire edit is committed and the edit lock on the Policy is released.&lt;P&gt; If any of the changes To the Policy are not performed successfully, then the edit is rolled back (none of the changes are committed) and the edit lock on the Policy is released.&lt;P&gt; Use the &lt;b&gt;DryRun&lt;/b&gt; Option To test the commit. Using this Option, the changes To the Policy are not committed To the database. Instead, a &lt;b&gt;conformance check&lt;/b&gt; is performed To return a list of actions that the system would take if the changes were committed by calling this ZAPI without the &lt;b&gt;DryRun&lt;/b&gt; Option.&lt;P&gt; If &lt;b&gt;DryRun&lt;/b&gt; is false, and all changes are successfully committed, then before the call returns, the system begins a &lt;b&gt;conformance run&lt;/b&gt; on all Datasets To which the Policy has been applied. (See &lt;b&gt;DatasetConformBegin&lt;/b&gt; for a Description of conformance runs.) If any needed conformance actions require user confirmation, it is assumed that such confirmation &lt;b&gt;has&lt;/b&gt; been given, and the actions &lt;b&gt;are&lt;/b&gt; performed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EPOLICYEXISTS - The Policy's Name is being changed, and a Policy with the new Name already exists. &lt;LI&gt; EDPPOLICYINUSE - The Policy is being deleted, but deletion has failed because the Policy is in use by one or more Datasets. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22282</na:Code>
                            <na:Name>EDPPOLICYINUSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22223</na:Code>
                            <na:Name>EDPPOLICYNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22261</na:Code>
                            <na:Name>EPOLICYEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyEditCommitRequest"/>
            <output message="na:DpPolicyEditCommitResponse"/>
        </operation>
        <operation name="DpPolicyEditRollback">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Roll back changes made To a DP Policy. The edit lock on the Policy will be released after the rollback. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyEditRollbackRequest"/>
            <output message="na:DpPolicyEditRollbackResponse"/>
        </operation>
        <operation name="DpPolicyGetDefaultPropertyValues">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns default Values for node and connection Properties. These default Values are used in calls To &lt;b&gt;DpPolicyModify&lt;/b&gt;, in cases where the property is present for a node or connection, but the corresponding optional XML element does not appear in the &lt;b&gt;DpPolicyNodeInfo&lt;/b&gt; or &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; structure. &lt;p&gt; Note that default Values may change From release To release. This ZAPI provides a convenient way To determine the default Values for the current release. &lt;HR&gt; Error conditions: None.</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyGetDefaultPropertyValuesRequest"/>
            <output message="na:DpPolicyGetDefaultPropertyValuesResponse"/>
        </operation>
        <operation name="DpPolicyListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a list iteration that had been started by a call To &lt;b&gt;DpPolicyListIterStart&lt;/b&gt;. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyListIterEndRequest"/>
            <output message="na:DpPolicyListIterEndResponse"/>
        </operation>
        <operation name="DpPolicyListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve the next series of policies that are present in a list iteration created by a call To &lt;b&gt;DpPolicyListIterStart&lt;/b&gt;. The server maintains an internal cursor pointing To the last record returned. Subsequent calls To &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; return the next &lt;b&gt;Maximum&lt;/b&gt; Records after the cursor, or all the remaining Records, whichever is fewer. &lt;p&gt; If a property is &lt;b&gt;present&lt;/b&gt; for a particular node or connection (the presence or absence of each property is defined in its Description), then it always appears in the output element for that node or connection From a call To &lt;b&gt;DpPolicyListIterNext&lt;/b&gt;. For example, the output &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; element for a backup connection always contains a &lt;b&gt;BackupScheduleName&lt;/b&gt;. &lt;p&gt; If a property is &lt;b&gt;absent&lt;/b&gt; for a particular node or connection, then it never appears in the output element for that node or connection. For example, the output &lt;b&gt;DpPolicyConnectionInfo&lt;/b&gt; element for a mirror connection never contains a &lt;b&gt;BackupScheduleName&lt;/b&gt;. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;LI&gt; EOBJECTNOTFOUND - A schedule or throttle referenced by the Policy could not be found. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyListIterNextRequest"/>
            <output message="na:DpPolicyListIterNextResponse"/>
        </operation>
        <operation name="DpPolicyListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Begin a list iteration over all content in all DP policies in the system. Optionally, you may iterate over the content of just a single Policy. &lt;p&gt; After calling &lt;b&gt;DpPolicyListIterStart&lt;/b&gt;, you continue the iteration by calling &lt;b&gt;DpPolicyListIterNext&lt;/b&gt; zero or more times, followed by a call To &lt;b&gt;DpPolicyListIterEnd&lt;/b&gt; To terminate the iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the specified Policy. &lt;LI&gt; EOBJECTNOTFOUND - No Policy was found that has the given Name or ID. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyListIterStartRequest"/>
            <output message="na:DpPolicyListIterStartResponse"/>
        </operation>
        <operation name="DpPolicyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>This ZAPI modifies a DP Policy by completely replacing the Policy's old content with new content specified by input element &lt;b&gt;DpPolicyContent&lt;/b&gt;. This ZAPI can only change a Policy's Name, Description, and the Properties of its nodes and most of the Properties of it's connections. The connection property of IsDrCapable cannot be changed once a Policy is created. This ZAPI also cannot change the topology (set of nodes and connections between nodes) of a Policy; instead, the topology specified in &lt;b&gt;DpPolicyContent&lt;/b&gt; must Match the Policy's current topology. At present, there is no way To change the topology of a Policy. &lt;p&gt; If a property is &lt;b&gt;absent&lt;/b&gt; for a particular node or connection (the presence or absence of each property is defined in its Description), then it is &lt;b&gt;illegal&lt;/b&gt; for that property To appear in the input element for that node or connection in a call To &lt;b&gt;DpPolicyModify&lt;/b&gt;. For example, it is illegal To specify a &lt;b&gt;BackupScheduleName&lt;/b&gt; in a &lt;b&gt;dp-policy-connection&lt;/b&gt; element for a mirror connection. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EOBJECTNOTFOUND - The Policy was already destroyed during this edit session. &lt;LI&gt; EPOLICYNOTMODIFIABLE - The Policy is one of the samples created during installation, and therefore cannot be modified. &lt;LI&gt; EPOLICYTOPOLOGYCHANGED - The requested modification changes the topology of the Policy. &lt;LI&gt; EINVALIDPOLICYPROPERTY - The requested modification would set a node or connection property To an invalid Value. This includes the case when a property Value was specified, but the property is not present for that node or connection. &lt;LI&gt; EOSSVCANTTAKESNAPSHOTS - A Snapshot schedule is being set for the Policy's root node, but the Policy has been applied To a Dataset whose root storage set contains OSSV Directories. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>DpPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22253</na:Code>
                            <na:Name>EINVALIDPOLICYPROPERTY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22288</na:Code>
                            <na:Name>EOSSVCANTTAKESNAPSHOTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22251</na:Code>
                            <na:Name>EPOLICYNOTMODIFIABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22252</na:Code>
                            <na:Name>EPOLICYTOPOLOGYCHANGED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpPolicyModifyRequest"/>
            <output message="na:DpPolicyModifyResponse"/>
        </operation>
        <operation name="DpRelationshipListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list data protection relationships.</na:Description>
                    <na:Category>DpRelationship</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpRelationshipListInfoIterEndRequest"/>
            <output message="na:DpRelationshipListInfoIterEndResponse"/>
        </operation>
        <operation name="DpRelationshipListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by DpRelationshipListInfoIterStart.</na:Description>
                    <na:Category>DpRelationship</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpRelationshipListInfoIterNextRequest"/>
            <output message="na:DpRelationshipListInfoIterNextResponse"/>
        </operation>
        <operation name="DpRelationshipListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list data protection relationships. These are SnapVault or SnapMirror relationships formed in order To implement data protection Policy for a Dataset. You can list relationships for a single Policy connection or for a particular Source or destination storage server.</na:Description>
                    <na:Category>DpRelationship</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpRelationshipListInfoIterStartRequest"/>
            <output message="na:DpRelationshipListInfoIterStartResponse"/>
        </operation>
        <operation name="DpRelationshipModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify settings of a SnapVault, Qtree SnapMirror or Volume SnapMirror relationship.</na:Description>
                    <na:Category>DpRelationship</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpRelationshipModifyRequest"/>
            <output message="na:DpRelationshipModifyResponse"/>
        </operation>
        <operation name="DpRestoreToNewPath">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start a restore Operation on part of a Dataset. This Operation copies whole Members or its sub-paths of the Dataset From a specific backup Version To a new location. The Operation is performed in the background by a job. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTNOTFOUND - The Dataset Name or ID or one of the member Name or ID was not found. &lt;LI&gt; EACCESSDENIED - The Dataset exists, but the user invoking the API has no DFM.BackupManager.Restore Permission on the Dataset. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDINPUT - The number of Paths To restore was either 0 or more than 1000 or neither BackupId nor BackupVersion was specified. &lt;LI&gt; EINVALIDHOST - One of the specified destination Hosts was not a valid restore destination. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>DpRestore</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22290</na:Code>
                            <na:Name>EBACKUPLOCATIONDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13211</na:Code>
                            <na:Name>EINVALIDHOST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23513</na:Code>
                            <na:Name>EOPERATIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpRestoreToNewPathRequest"/>
            <output message="na:DpRestoreToNewPathResponse"/>
        </operation>
        <operation name="DpRestoreToPrimary">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start a restore Operation on part of a Dataset. This Operation copies files and/or Directories From a specific backup Version back To the primary location. The Operation is performed in the background by a job. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EOBJECTNOTFOUND - The Dataset Name or ID or one of the member Name or ID was not found. &lt;LI&gt; EACCESSDENIED - The Dataset exists, but the user invoking the API has no DFM.BackupManager.Restore Permission on the Dataset or on any of the Members. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDINPUT - The number of Paths To restore was either 0 or more than 1000 or neither BackupId nor BackupVersion was specified. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;LI&gt; ENDRESTORENOTPOSSIBLE - A partial Qtree restore is requested for a Dataset which requires a non disruptive restore. &lt;/UL&gt;</na:Description>
                    <na:Category>DpRestore</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22290</na:Code>
                            <na:Name>EBACKUPLOCATIONDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23407</na:Code>
                            <na:Name>ENDRESTORENOTPOSSIBLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23513</na:Code>
                            <na:Name>EOPERATIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpRestoreToPrimaryRequest"/>
            <output message="na:DpRestoreToPrimaryResponse"/>
        </operation>
        <operation name="DpScheduleContentGet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the content of a given schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleContentGetRequest"/>
            <output message="na:DpScheduleContentGetResponse"/>
        </operation>
        <operation name="DpScheduleCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new schedule with the given Name. The schedule Type may be daily, weekly, or monthly.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22202</na:Code>
                            <na:Name>ESCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleCreateRequest"/>
            <output message="na:DpScheduleCreateResponse"/>
        </operation>
        <operation name="DpScheduleDailyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a single Snapshot within a daily schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleDailyAddRequest"/>
            <output message="na:DpScheduleDailyAddResponse"/>
        </operation>
        <operation name="DpScheduleDailyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a single Snapshot within a daily schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleDailyDeleteRequest"/>
            <output message="na:DpScheduleDailyDeleteResponse"/>
        </operation>
        <operation name="DpScheduleDailyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a single Snapshot within a daily schedule. Sample schedules cannot be modified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleDailyModifyRequest"/>
            <output message="na:DpScheduleDailyModifyResponse"/>
        </operation>
        <operation name="DpScheduleDependency">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Return a list of other DP policies and DP schedules using the specified DP schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleDependencyRequest"/>
            <output message="na:DpScheduleDependencyResponse"/>
        </operation>
        <operation name="DpScheduleDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a schedule with the given Name or ID. A schedule that is used by another schedule(s) may not be deleted and an Error will be returned. Sample schedules cannot be destroyed.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22203</na:Code>
                            <na:Name>ESCHEDULEINUSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleDestroyRequest"/>
            <output message="na:DpScheduleDestroyResponse"/>
        </operation>
        <operation name="DpScheduleHourlyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create an hourly schedule within a daily schedule. An hourly schedule specifies the Frequency of Snapshots To be run within the start time and end time.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleHourlyAddRequest"/>
            <output message="na:DpScheduleHourlyAddResponse"/>
        </operation>
        <operation name="DpScheduleHourlyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete an hourly schedule within a daily schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleHourlyDeleteRequest"/>
            <output message="na:DpScheduleHourlyDeleteResponse"/>
        </operation>
        <operation name="DpScheduleHourlyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an hourly schedule within a daily schedule. Sample schedules cannot be modified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleHourlyModifyRequest"/>
            <output message="na:DpScheduleHourlyModifyResponse"/>
        </operation>
        <operation name="DpScheduleList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List all existing schedule IDs and types.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleListRequest"/>
            <output message="na:DpScheduleListResponse"/>
        </operation>
        <operation name="DpScheduleListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Tell the DFM station that the temporary store associated with the specified Tag is no longer necessary</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleListInfoIterEndRequest"/>
            <output message="na:DpScheduleListInfoIterEndResponse"/>
        </operation>
        <operation name="DpScheduleListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Iterate over the list of schedules stored in the temporary store. The DFM internally maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleListInfoIterNextRequest"/>
            <output message="na:DpScheduleListInfoIterNextResponse"/>
        </operation>
        <operation name="DpScheduleListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The dp-dpschedule-list-info-iter-* set of APIs are used To retrieve a list of schedule contents</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleListInfoIterStartRequest"/>
            <output message="na:DpScheduleListInfoIterStartResponse"/>
        </operation>
        <operation name="DpScheduleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a schedule's details in the database. When the zapi is called, all details within the schedule will be removed and replace by the new details specified in schedule-content. Sample schedules cannot be modified. ScheduleId and ScheduleType cannot be modified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22202</na:Code>
                            <na:Name>ESCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleModifyRequest"/>
            <output message="na:DpScheduleModifyResponse"/>
        </operation>
        <operation name="DpScheduleMonthlyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify a single Snapshot within a monthly schedule. Either DayOfMonth, or both WeekOfMonth and DayOfWeek must be specified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleMonthlyAddRequest"/>
            <output message="na:DpScheduleMonthlyAddResponse"/>
        </operation>
        <operation name="DpScheduleMonthlyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a single Snapshot within a monthly schedule</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleMonthlyDeleteRequest"/>
            <output message="na:DpScheduleMonthlyDeleteResponse"/>
        </operation>
        <operation name="DpScheduleMonthlyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a single Snapshot within a monthly schedule. Sample schedules cannot be modified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleMonthlyModifyRequest"/>
            <output message="na:DpScheduleMonthlyModifyResponse"/>
        </operation>
        <operation name="DpScheduleMonthlySubscheduleSet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify a sub-schedule To be used by a monthly schedule. On top of the individual monthly Events, a monthly schedule may only have 1 daily subschedule OR 1 weekly schedule. If this monthly schedule already has a daily or weekly schedule, this command replaces the old one.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleMonthlySubscheduleSetRequest"/>
            <output message="na:DpScheduleMonthlySubscheduleSetResponse"/>
        </operation>
        <operation name="DpScheduleMonthlySubscheduleUnset">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Unset a sub-schedule used by a monthly schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleMonthlySubscheduleUnsetRequest"/>
            <output message="na:DpScheduleMonthlySubscheduleUnsetResponse"/>
        </operation>
        <operation name="DpScheduleRename">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Rename a schedule. Sample schedules cannot be renamed.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22202</na:Code>
                            <na:Name>ESCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleRenameRequest"/>
            <output message="na:DpScheduleRenameResponse"/>
        </operation>
        <operation name="DpScheduleWeeklyAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify a single Snapshot within a weekly schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleWeeklyAddRequest"/>
            <output message="na:DpScheduleWeeklyAddResponse"/>
        </operation>
        <operation name="DpScheduleWeeklyDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a single Snapshot within a weekly schedule.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleWeeklyDeleteRequest"/>
            <output message="na:DpScheduleWeeklyDeleteResponse"/>
        </operation>
        <operation name="DpScheduleWeeklyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a single Snapshot within a weekly schedule. Sample schedules canot be modified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleWeeklyModifyRequest"/>
            <output message="na:DpScheduleWeeklyModifyResponse"/>
        </operation>
        <operation name="DpScheduleWeeklySubscheduleAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify which daily schedule will be used on a certain range of Days within a weekly schedule</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleWeeklySubscheduleAddRequest"/>
            <output message="na:DpScheduleWeeklySubscheduleAddResponse"/>
        </operation>
        <operation name="DpScheduleWeeklySubscheduleDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify which daily schedule To be deleted within a weekly schedule</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleWeeklySubscheduleDeleteRequest"/>
            <output message="na:DpScheduleWeeklySubscheduleDeleteResponse"/>
        </operation>
        <operation name="DpScheduleWeeklySubscheduleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Specify which daily schedule will be used on a certain range of Days within a weekly schedule. Permenent of sample schedules cannot be modified.</na:Description>
                    <na:Category>DpSchedule</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22200</na:Code>
                            <na:Name>ESCHEDULEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22201</na:Code>
                            <na:Name>ESCHEDULENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22286</na:Code>
                            <na:Name>ESCHEDULENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpScheduleWeeklySubscheduleModifyRequest"/>
            <output message="na:DpScheduleWeeklySubscheduleModifyResponse"/>
        </operation>
        <operation name="DpThrottleCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a throttle schedule</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22214</na:Code>
                            <na:Name>ETHROTTLEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleCreateRequest"/>
            <output message="na:DpThrottleCreateResponse"/>
        </operation>
        <operation name="DpThrottleDependency">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Return a list of DP policies using the specified DP throttle.</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleDependencyRequest"/>
            <output message="na:DpThrottleDependencyResponse"/>
        </operation>
        <operation name="DpThrottleDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a throttle item. Sample throttle schedules cannot be destroyed.</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22215</na:Code>
                            <na:Name>ETHROTTLEINUSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22287</na:Code>
                            <na:Name>ETHROTTLENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleDestroyRequest"/>
            <output message="na:DpThrottleDestroyResponse"/>
        </operation>
        <operation name="DpThrottleItemAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a new throttle item To the throttle schedule</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22287</na:Code>
                            <na:Name>ETHROTTLENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleItemAddRequest"/>
            <output message="na:DpThrottleItemAddResponse"/>
        </operation>
        <operation name="DpThrottleItemDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete a throttle item From a throttle schedule</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22287</na:Code>
                            <na:Name>ETHROTTLENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleItemDeleteRequest"/>
            <output message="na:DpThrottleItemDeleteResponse"/>
        </operation>
        <operation name="DpThrottleListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Tell the DFM station that the temporary store associated with the specified Tag is no longer necessary</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleListInfoIterEndRequest"/>
            <output message="na:DpThrottleListInfoIterEndResponse"/>
        </operation>
        <operation name="DpThrottleListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Iterate over the list of throttle items stored in the temporary store. The DFM internally maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleListInfoIterNextRequest"/>
            <output message="na:DpThrottleListInfoIterNextResponse"/>
        </operation>
        <operation name="DpThrottleListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The DpThrottleListInfoIter* set of APIs are used To retrieve a list of throttle items</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleListInfoIterStartRequest"/>
            <output message="na:DpThrottleListInfoIterStartResponse"/>
        </operation>
        <operation name="DpThrottleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Update a throttle item. When the zapi is called, all details within the throttle schedule will be removed and replace by the new details specified in ThrottleContent. Sample throttle schedules cannot be modified.</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22214</na:Code>
                            <na:Name>ETHROTTLEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22287</na:Code>
                            <na:Name>ETHROTTLENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleModifyRequest"/>
            <output message="na:DpThrottleModifyResponse"/>
        </operation>
        <operation name="DpThrottleRename">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Rename a throttle schedule. Sample throttle schedules cannot be renamed.</na:Description>
                    <na:Category>DpThrottle</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22214</na:Code>
                            <na:Name>ETHROTTLEDUPLICATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22216</na:Code>
                            <na:Name>ETHROTTLEINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22213</na:Code>
                            <na:Name>ETHROTTLENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22287</na:Code>
                            <na:Name>ETHROTTLENOTMODIFIABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:DpThrottleRenameRequest"/>
            <output message="na:DpThrottleRenameResponse"/>
        </operation>
        <operation name="EventAcknowledge">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Acknowledge Events. This terminates repeated notifications due To that event.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22258</na:Code>
                            <na:Name>EALREADYACKWED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22257</na:Code>
                            <na:Name>ENOSUCHEVENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventAcknowledgeRequest"/>
            <output message="na:EventAcknowledgeResponse"/>
        </operation>
        <operation name="EventDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete Events. Terminates repeated notifications due To the event.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22257</na:Code>
                            <na:Name>ENOSUCHEVENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventDeleteRequest"/>
            <output message="na:EventDeleteResponse"/>
        </operation>
        <operation name="EventGenerate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The EventGenerate API helps clients To generate Events in the DFM system</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21011</na:Code>
                            <na:Name>EEVENTGENERATEFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21010</na:Code>
                            <na:Name>ENOTCUSTOMEVENTCLASS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventGenerateRequest"/>
            <output message="na:EventGenerateResponse"/>
        </operation>
        <operation name="EventListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>EventListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the EventListIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventListIterEndRequest"/>
            <output message="na:EventListIterEndResponse"/>
        </operation>
        <operation name="EventListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The EventListIterNext API is used To iterate over the list of Events stored in the temporary store created by the EventListIterStart API. The DFM station, internally, maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventListIterNextRequest"/>
            <output message="na:EventListIterNextResponse"/>
        </operation>
        <operation name="EventListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List Events. The EventListIter* set of APIs are used To retrieve the list of Events. &lt;P&gt; The EventListIterStart API is used To load the list of Events into a temporary store. The API returns a Tag To temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. &lt;P&gt; Note that, depending on the input parameters, this API may take up To "Timeout" seconds To return. Subsequent calls To EventListIterNext() will return immediately.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22260</na:Code>
                            <na:Name>EINVALIDEVENTSEVERITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22257</na:Code>
                            <na:Name>ENOSUCHEVENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventListIterStartRequest"/>
            <output message="na:EventListIterStartResponse"/>
        </operation>
        <operation name="EventStatusChangeListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>EventStatusChangeListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the EventStatusChangeListIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventStatusChangeListIterEndRequest"/>
            <output message="na:EventStatusChangeListIterEndResponse"/>
        </operation>
        <operation name="EventStatusChangeListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The EventStatusChangeListIterNext API is used To iterate over the list of Events stored in the temporary store created by the EventStatusChangeListIterStart API. The DFM station, internally, maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventStatusChangeListIterNextRequest"/>
            <output message="na:EventStatusChangeListIterNextResponse"/>
        </operation>
        <operation name="EventStatusChangeListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List Events that had Status changes (acknowledged or deleted) within the specified time range. &lt;P&gt; The EventStatusChangeListIter* set of APIs are used To retrieve the list of Events that had Status changes. &lt;P&gt; The EventStatusChangeListIterStart API is used To load the list of Events into a temporary store. The API returns a Tag To temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. &lt;P&gt; The returned list of Events will be sorted according To when they had their Status changed (either eventAcked Timestamp or eventDeleted Timestamp). An event that's both acked and deleted within the requested timeframe would appear twice in the returned list of Events, because those would Count as 2 Status changes, and appear in the returned list based on acked Timestamp and deleted Timestamp respectively. &lt;P&gt; Note that, depending on the input parameters, this API may take up To "Timeout" seconds To return. Subsequent calls To EventStatusChangeListIterNext() will return immediately.</na:Description>
                    <na:Category>Event</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22260</na:Code>
                            <na:Name>EINVALIDEVENTSEVERITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22257</na:Code>
                            <na:Name>ENOSUCHEVENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventStatusChangeListIterStartRequest"/>
            <output message="na:EventStatusChangeListIterStartResponse"/>
        </operation>
        <operation name="EventclassAddCustom">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Supports adding custom event classes.</na:Description>
                    <na:Category>Eventclass</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21013</na:Code>
                            <na:Name>EEVENTCLASSEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventclassAddCustomRequest"/>
            <output message="na:EventclassAddCustomResponse"/>
        </operation>
        <operation name="EventclassDeleteCustom">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Supports deletion of custom event classes.</na:Description>
                    <na:Category>Eventclass</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21014</na:Code>
                            <na:Name>ENOSUCHEVENTCLASS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventclassDeleteCustomRequest"/>
            <output message="na:EventclassDeleteCustomResponse"/>
        </operation>
        <operation name="EventclassList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Lists all or a sub-set of the custom event classes.</na:Description>
                    <na:Category>Eventclass</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21014</na:Code>
                            <na:Name>ENOSUCHEVENTCLASS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventclassListRequest"/>
            <output message="na:EventclassListResponse"/>
        </operation>
        <operation name="EventclassListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The EventclassListIter* set of APIs are used To retrieve the list of event classes. EventclassListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the EventclassListIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Eventclass</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventclassListIterEndRequest"/>
            <output message="na:EventclassListIterEndResponse"/>
        </operation>
        <operation name="EventclassListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check EventclassListIterStart. The EventclassListIterNext API is used To iterate over the Members of the event classes stored in the temporary store created by the EventclassListIterStart API.</na:Description>
                    <na:Category>Eventclass</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventclassListIterNextRequest"/>
            <output message="na:EventclassListIterNextResponse"/>
        </operation>
        <operation name="EventclassListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The EventclassListIter* set of APIs are used To retrieve the list of event classes in DFM. The EventclassListIterStart API is used To load the list of event classes into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the event classes in the temporary store. If EventclassListIterStart is invoked twice, then two distinct temporary stores are created.</na:Description>
                    <na:Category>Eventclass</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:EventclassListIterStartRequest"/>
            <output message="na:EventclassListIterStartResponse"/>
        </operation>
        <operation name="FcpTargetListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of Targets.</na:Description>
                    <na:Category>FcpTarget</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:FcpTargetListInfoIterEndRequest"/>
            <output message="na:FcpTargetListInfoIterEndResponse"/>
        </operation>
        <operation name="FcpTargetListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next set of Records in the iteration started by call To FcpTargetListInfoIterStart. This zapi will fetch the fcp Target info Records. The input param 'Maximum' specifies the number of Records it will show at a time.</na:Description>
                    <na:Category>FcpTarget</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:FcpTargetListInfoIterNextRequest"/>
            <output message="na:FcpTargetListInfoIterNextResponse"/>
        </operation>
        <operation name="FcpTargetListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start iteration of Targets.Depending on the input it will return a Tag and the number of Records To be retrieved.</na:Description>
                    <na:Category>FcpTarget</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:FcpTargetListInfoIterStartRequest"/>
            <output message="na:FcpTargetListInfoIterStartResponse"/>
        </operation>
        <operation name="GraphDataListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve data of all the graph Lines of a graph.</na:Description>
                    <na:Category>Graph</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GraphDataListInfoRequest"/>
            <output message="na:GraphDataListInfoResponse"/>
        </operation>
        <operation name="GraphListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Graph</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GraphListInfoIterEndRequest"/>
            <output message="na:GraphListInfoIterEndResponse"/>
        </operation>
        <operation name="GraphListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To GraphListInfoIterStart</na:Description>
                    <na:Category>Graph</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GraphListInfoIterNextRequest"/>
            <output message="na:GraphListInfoIterNextResponse"/>
        </operation>
        <operation name="GraphListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of Graphs and its metadata like graph Lines and sample information.</na:Description>
                    <na:Category>Graph</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23339</na:Code>
                            <na:Name>EGRAPHNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GraphListInfoIterStartRequest"/>
            <output message="na:GraphListInfoIterStartResponse"/>
        </operation>
        <operation name="GroupAddMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a member To a Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDMEMBER - The proposed member object is not a groupable object Type. The Error message indicates which object. &lt;LI&gt; EMEMBERALREADYINGROUP - The proposed new member is already in the Group. &lt;LI&gt; EMEMBERNAMEAMBIGUOUS - The proposed member Name could refer To 2 or more Objects. &lt;LI&gt; EOBJECTNOTFOUND - The proposed member Name or ID was not found. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To add Members To the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22270</na:Code>
                            <na:Name>EINVALIDMEMBER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22269</na:Code>
                            <na:Name>EMEMBERALREADYINGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22271</na:Code>
                            <na:Name>EMEMBERNAMEAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupAddMemberRequest"/>
            <output message="na:GroupAddMemberResponse"/>
        </operation>
        <operation name="GroupCopy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Copy the Group and all of its subgroups under a new parent Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI EGROUPCOPYERROR - An attempt was made To copy a Group under itself, or under one of its sub-group or some other configuration Error occured. &lt;LI&gt; EPARENTGROUPDOESNOTEXIST - The parent Group Name or ID was not found. &lt;LI&gt; EPARENTGROUPNAMEAMBIGUOUS - The specified parent Group Name could refer To 2 or more Groups. Try again with a parent Group ID or a fully qualified parent Group Name. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To copy the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22272</na:Code>
                            <na:Name>EGROUPCOPYERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22274</na:Code>
                            <na:Name>EGROUPEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22275</na:Code>
                            <na:Name>EINVALIDGROUPNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22276</na:Code>
                            <na:Name>EPARENTGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22267</na:Code>
                            <na:Name>EPARENTGROUPNAMEAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupCopyRequest"/>
            <output message="na:GroupCopyResponse"/>
        </operation>
        <operation name="GroupCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EPARENTGROUPDOESNOTEXIST - The parent Group Name or ID was not found. &lt;LI&gt; EPARENTGROUPNAMEAMBIGUOUS - The specified parent Group Name could refer To 2 or more Groups. Try again with a parent Group ID or a fully qualified parent Group Name. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To create the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22274</na:Code>
                            <na:Name>EGROUPEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22275</na:Code>
                            <na:Name>EINVALIDGROUPNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22276</na:Code>
                            <na:Name>EPARENTGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22267</na:Code>
                            <na:Name>EPARENTGROUPNAMEAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupCreateRequest"/>
            <output message="na:GroupCreateResponse"/>
        </operation>
        <operation name="GroupDeleteMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove one member From a Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EMEMBERNOTINGROUP - The object specified is not a member in the Group. &lt;LI&gt; EOBJECTNOTFOUND - The object specified was not found. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To delete Members From the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22268</na:Code>
                            <na:Name>EMEMBERNOTINGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupDeleteMemberRequest"/>
            <output message="na:GroupDeleteMemberResponse"/>
        </operation>
        <operation name="GroupDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy an existing Group. Child Groups are destroyed recursively. If there is any Error, then no Groups are destroyed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To Destroy the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupDestroyRequest"/>
            <output message="na:GroupDestroyResponse"/>
        </operation>
        <operation name="GroupGetOptions">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the Options for a Group. Option Values that are not present indicate that the Option is using the global default. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To read Options of the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupGetOptionsRequest"/>
            <output message="na:GroupGetOptionsResponse"/>
        </operation>
        <operation name="GroupGetStatus">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the Status of the Group &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To get the Status of the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupGetStatusRequest"/>
            <output message="na:GroupGetStatusResponse"/>
        </operation>
        <operation name="GroupIsMemberOf">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Checks if the object associated with the ObjectId input is a member of the Group. This includes both direct and indirect membership. If a Group Id of 0 is passed, this will always return true as long as the object is a valid object. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EMEMBERNAMEAMBIGUOUS - The proposed member Name could refer To 2 or more Objects. &lt;LI&gt; EOBJECTNOTFOUND - The object specified was not found. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To read From the database. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22271</na:Code>
                            <na:Name>EMEMBERNAMEAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupIsMemberOfRequest"/>
            <output message="na:GroupIsMemberOfResponse"/>
        </operation>
        <operation name="GroupListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The GroupListIter* set of APIs are used To retrieve the Members of the DFM global Group. GroupListIterEnd is used To tell the DFM station that the temporary store used by DFM To support the GroupListIterNext API for the particular Tag is no longer necessary. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupListIterEndRequest"/>
            <output message="na:GroupListIterEndResponse"/>
        </operation>
        <operation name="GroupListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check GroupListIterStart. The GroupListIterNext API is used To iterate over the Members of the Group stored in the temporary store created by the GroupListIterStart API. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDTAG - The iterator Tag specified is not valid. Restart the iteration Operation To obtain a new valid Tag. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupListIterNextRequest"/>
            <output message="na:GroupListIterNextResponse"/>
        </operation>
        <operation name="GroupListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The GroupListIter* set of APIs are used To retrieve the list of DFM Groups. By default, a Group is listed if the user has DFM.Database.Read Capability on the Group or if the user has DFM.Database.Read Capability on any subgroup of the Group. &lt;BR&gt; If RbacOperation is present in the input, then a Group is listed, if the authenticated user has the requested Capability on that Group or if the user has the required Capability on any of its sub-groups. In that case, HasPrivilege output will be false for the parent Group and true for the sub-group. &lt;BR&gt; The GroupListIterStart API is used To load the list of Groups into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Groups in the temporary store. &lt;BR&gt; If GroupListIterStart is invoked twice, then two distinct temporary stores are created. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - Specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EACCESSDENIED - The user does not have DFM.Database.Read or if RbacOperation is specified, the user does nat have the requested Capability on the specified Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;LI&gt; ENOTFOUNDOPERATION - If the input element RbacOperation is not a valid RBAC Operation Name. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21040</na:Code>
                            <na:Name>ENOTFOUNDOPERATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupListIterStartRequest"/>
            <output message="na:GroupListIterStartResponse"/>
        </operation>
        <operation name="GroupMemberListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>See GroupMemberListIterStart for more information. Frees up the resources used by previous call To GroupMemberListIterStart.</na:Description>
                    <na:Category>GroupMember</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupMemberListIterEndRequest"/>
            <output message="na:GroupMemberListIterEndResponse"/>
        </operation>
        <operation name="GroupMemberListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>See GroupMemberListIterStart for more information. The GroupListIterNext API is used To iterate over the Members of the Group stored in the temporary store created by the GroupListIterStart API. The DFM station, internally, maintains a cursor pointing To the last record returned. Subsequent calls To this API will return the Records after the cursor up To the specified "Maximum" or number of actual Records left.</na:Description>
                    <na:Category>GroupMember</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13200</na:Code>
                            <na:Name>ESVCDISABLED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13201</na:Code>
                            <na:Name>ESVCNOTAVAIL</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupMemberListIterNextRequest"/>
            <output message="na:GroupMemberListIterNextResponse"/>
        </operation>
        <operation name="GroupMemberListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>DFM has an object that is known as the "Group" that contains other DFM Objects. Group may also have subgroups. The group-member-list-* APIs are used To retrieve the Members of particular Groups. These APIs can be used To retrieve either all Members or particular Type of Members of Groups. These APIs don't return the subgroups. Use GroupListIterStart To get a list of subgroups. The GroupMemberListIterStart API is used To load the Group Members into a temporary store. Subsequent GroupMemberListIterNext invocations iterate over the Records in the temporary store. The GroupMemberListIterEnd API is used To release the temporary store. If GroupMemberListIterStart is invoked twice, then the DFM station will create two different temporary stores that can be accessed using the different tags. When this API is invoked without specifying any Groups, Type parameter must be specified. In that case, API lists all the Objects of specified Type that are known To DFM. Those Objects may or may not be Members of any Group. If you specify Groups when invoking this API, Type parameter is optional. API lists all the Objects (optionally, of the specified Type) that have been directly added To the specified Groups.</na:Description>
                    <na:Category>GroupMember</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupMemberListIterStartRequest"/>
            <output message="na:GroupMemberListIterStartResponse"/>
        </operation>
        <operation name="GroupMove">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Move the Group under a new parent Group. The Id of the Group does not change after the move. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI EGROUPMOVEERROR - An attempt was made To copy a Group under itself, or under one of its sub-group or some other configuration Error occured. &lt;LI&gt; EPARENTGROUPDOESNOTEXIST - The parent Group Name or ID was not found. &lt;LI&gt; EPARENTGROUPNAMEAMBIGUOUS - The specified parent Group Name could refer To 2 or more Groups. Try again with a parent Group ID or a fully qualified parent Group Name. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To move the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22274</na:Code>
                            <na:Name>EGROUPEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22273</na:Code>
                            <na:Name>EGROUPMOVEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22275</na:Code>
                            <na:Name>EINVALIDGROUPNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22276</na:Code>
                            <na:Name>EPARENTGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22267</na:Code>
                            <na:Name>EPARENTGROUPNAMEAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupMoveRequest"/>
            <output message="na:GroupMoveResponse"/>
        </operation>
        <operation name="GroupRename">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change the Name of a Group. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EGROUPEXISTS - An attempt was made To create a new Group with the same Name as an already existing Group. Try again with a different Name. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDGROUPNAME - The proposed Group Name was not valid. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To rename the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22274</na:Code>
                            <na:Name>EGROUPEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22275</na:Code>
                            <na:Name>EINVALIDGROUPNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupRenameRequest"/>
            <output message="na:GroupRenameResponse"/>
        </operation>
        <operation name="GroupSetOptions">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change one or more Options for a Group. Only Options that are specified will be updated. The remaining Options will retain their current Values. If there is any Error, then no Options are changed. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EGROUPDOESNOTEXIST - The Group Name or ID was not found. &lt;LI&gt; EOBJECTAMBIGUOUS - The specified Group Name could refer To 2 or more Groups. Try again with a Group ID or a fully qualified Group Name. &lt;LI&gt; EINTERNALERROR - An Error occurred while processing the Request. Try again later. &lt;LI&gt; EINVALIDINPUT - Invalid Value for one of the Options was specified. &lt;LI&gt; EACCESSDENIED - The user does not have the Capability To set Options for the Group. &lt;LI&gt; EDATABASEERROR - A database Error occured. &lt;/UL&gt;</na:Description>
                    <na:Category>Group</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:GroupSetOptionsRequest"/>
            <output message="na:GroupSetOptionsResponse"/>
        </operation>
        <operation name="HostAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add new managed Host To the DataFabric Manager. The Host being added must be a storage system or an Host agent. DFM figures out what Type of Host we're adding. If it's a storage system or NetCache or FC Switch, we add it To the database and set the ApplianceId. If it's a Host agent, we add the agent To the database and set the AgentId. On return, only one of the ApplianceId or AgentId will be set.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22314</na:Code>
                            <na:Name>EHOSTADDDUPPRODID</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22312</na:Code>
                            <na:Name>EHOSTADDNOCONTACT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22322</na:Code>
                            <na:Name>EHOSTADDNOLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22324</na:Code>
                            <na:Name>EHOSTADDNONODES</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22313</na:Code>
                            <na:Name>EHOSTADDNOTRESOLVED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22315</na:Code>
                            <na:Name>EHOSTADDTAKENOVER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22317</na:Code>
                            <na:Name>EHOSTADDVFILERPARENTDELETED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22311</na:Code>
                            <na:Name>EHOSTEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22319</na:Code>
                            <na:Name>EHOSTRUNMONFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostAddRequest"/>
            <output message="na:HostAddResponse"/>
        </operation>
        <operation name="HostAddLicense">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a License To a Host. Host must be a storage system. Host must already be present in DFM's database and root login and Password for the Host must be set in DFM. The DFM will check the list of Licenses on the Host and update the database when the following types of Licenses are changed: &lt;ul&gt; &lt;li&gt; Snapvault primary (sv_ontap_pri) &lt;li&gt; Snapvault secondary (sv_ontap_sec) &lt;li&gt; Unix primary (sv_unix_pri) &lt;li&gt; Linux primary (sv_linux_pri) &lt;li&gt; Windows primary (sv_windows_pri) &lt;li&gt; Snapmirror (snapmirror) &lt;li&gt; Synchronous snapmirror (snapmirror_sync) &lt;li&gt; Windows OFM primary (sv_windows_ofm_pri) &lt;li&gt; Nearstore (nearstore_option) &lt;li&gt; NFS (nfs) &lt;li&gt; CIFS (cifs) &lt;li&gt; iSCSI (iscsi) &lt;li&gt; MultiStore (Vfiler) &lt;li&gt; FCP (fcp) &lt;li&gt; ASIS (a_sis) &lt;/ul&gt; If the License is already in use by another Host and is not a site License, then the ZAPI will apply the License To the Host, and then return with Error code ELICENSEINUSE. The ELICENSEINUSE Error will not be returned if the optional parameter SuppressInuseError is true. The ELICENSEINUSE Error will not prevent the License From being applied To the Host, since it is not the role of the DFM To prevent the user From installing duplicate Licenses. The storage system must be running a minimum ONTAP Version of 6.5.6.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22309</na:Code>
                            <na:Name>EHOSTACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22308</na:Code>
                            <na:Name>EHOSTCOMMUNICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22302</na:Code>
                            <na:Name>EINVALIDLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22285</na:Code>
                            <na:Name>ELICENSEINUSE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostAddLicenseRequest"/>
            <output message="na:HostAddLicenseResponse"/>
        </operation>
        <operation name="HostAddOssv">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add new managed ossv Host To the DataFabric Manager. If there is an ossv agent running on the Host, we add the ossv agent To the database as a snapvault primary and set the OssvId.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22314</na:Code>
                            <na:Name>EHOSTADDDUPPRODID</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22325</na:Code>
                            <na:Name>EHOSTADDMISMATCHPRODID</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22312</na:Code>
                            <na:Name>EHOSTADDNOCONTACT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22322</na:Code>
                            <na:Name>EHOSTADDNOLICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22324</na:Code>
                            <na:Name>EHOSTADDNONODES</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22323</na:Code>
                            <na:Name>EHOSTADDNOTENABLED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22313</na:Code>
                            <na:Name>EHOSTADDNOTRESOLVED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22328</na:Code>
                            <na:Name>EHOSTBADCONFIG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22311</na:Code>
                            <na:Name>EHOSTEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22327</na:Code>
                            <na:Name>EHOSTNDMPACCESSFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22331</na:Code>
                            <na:Name>EHOSTNDMPTABLOOKUPFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22319</na:Code>
                            <na:Name>EHOSTRUNMONFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostAddOssvRequest"/>
            <output message="na:HostAddOssvResponse"/>
        </operation>
        <operation name="HostAgentOssvServiceStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start the OSSV Service on the Host agent using the ossv ZAPI. DFM must have valid credentials for the Host Agent. The Host Agent and OSSV Agent must be installed on the Host. Valid only for Host Agents. DFM will wait up To the time allowed in the Timeout argument To make sure the requested Service state was reached. If the Timeout is exceeded, we return ESERVICESTATEUNKNOWN.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22321</na:Code>
                            <na:Name>EAGENTNOTUPTODATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22309</na:Code>
                            <na:Name>EHOSTACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22328</na:Code>
                            <na:Name>EHOSTBADCONFIG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22308</na:Code>
                            <na:Name>EHOSTCOMMUNICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22320</na:Code>
                            <na:Name>ESERVICESTATEUNKNOWN</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostAgentOssvServiceStartRequest"/>
            <output message="na:HostAgentOssvServiceStartResponse"/>
        </operation>
        <operation name="HostAgentOssvServiceStop">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Stop the OSSV Service on the Host agent using the ossv ZAPI. DFM must have valid credentials for the Host Agent. The Host Agent and OSSV Agent must be installed on the Host. Valid only for Host Agents. DFM will wait up To the time allowed in the Timeout argument To make sure the requested Service state was reached. If the Timeout is exceeded, we return ESERVICESTATEUNKNOWN.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22321</na:Code>
                            <na:Name>EAGENTNOTUPTODATE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22309</na:Code>
                            <na:Name>EHOSTACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22328</na:Code>
                            <na:Name>EHOSTBADCONFIG</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22308</na:Code>
                            <na:Name>EHOSTCOMMUNICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22320</na:Code>
                            <na:Name>ESERVICESTATEUNKNOWN</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostAgentOssvServiceStopRequest"/>
            <output message="na:HostAgentOssvServiceStopResponse"/>
        </operation>
        <operation name="HostCapabilityListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostCapabilityListIterEndRequest"/>
            <output message="na:HostCapabilityListIterEndResponse"/>
        </operation>
        <operation name="HostCapabilityListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To HostCapabilityListIterStart.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostCapabilityListIterNextRequest"/>
            <output message="na:HostCapabilityListIterNextResponse"/>
        </operation>
        <operation name="HostCapabilityListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of allowed Capabilities on Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostCapabilityListIterStartRequest"/>
            <output message="na:HostCapabilityListIterStartResponse"/>
        </operation>
        <operation name="HostCreateNdmpuser">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create an NDMP user on the Host, creating the user account if necessary and storing the host-encrypted Password on dfm. If the user exists already, we generate the encrypted NDMP Password for them on the storage system and store that in the database. If it is a new user on the storage system, we will create a new unencrypted Password for the caller and use that To generate the encrypted NDMP Password which we will then store in the database. If the user is root, we will just use root's unencrypted Password as the NDMP Password since the encryption requirement does not apply To the root user. New non-root users will be added To the "Backup Administrators" Group. Valid only for storage systems.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostCreateNdmpuserRequest"/>
            <output message="na:HostCreateNdmpuserResponse"/>
        </operation>
        <operation name="HostDomainuserAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Adds a domain user on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23323</na:Code>
                            <na:Name>EDOMAINUSERNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23322</na:Code>
                            <na:Name>EDUPLICATEUSERGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23325</na:Code>
                            <na:Name>EINVALIDDOMAINUSERNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostDomainuserAddRequest"/>
            <output message="na:HostDomainuserAddResponse"/>
        </operation>
        <operation name="HostDomainuserListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostDomainuserListIterEndRequest"/>
            <output message="na:HostDomainuserListIterEndResponse"/>
        </operation>
        <operation name="HostDomainuserListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To HostDomainuserListIterStart.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostDomainuserListIterNextRequest"/>
            <output message="na:HostDomainuserListIterNextResponse"/>
        </operation>
        <operation name="HostDomainuserListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of domain users on Host(s). Domain users on Host(s) that matches all filters will be returned. If no input is specified, all the domain users on all monitored storage systems/vFiler units will be returned.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23323</na:Code>
                            <na:Name>EDOMAINUSERNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostDomainuserListIterStartRequest"/>
            <output message="na:HostDomainuserListIterStartResponse"/>
        </operation>
        <operation name="HostDomainuserPush">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23324</na:Code>
                            <na:Name>EDOMAINUSERAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23323</na:Code>
                            <na:Name>EDOMAINUSERNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23332</na:Code>
                            <na:Name>EINCOMPATIBLEUSERGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostDomainuserPushRequest"/>
            <output message="na:HostDomainuserPushResponse"/>
        </operation>
        <operation name="HostDomainuserRemove">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Removes a domain user From a usergroup or usergroups.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23324</na:Code>
                            <na:Name>EDOMAINUSERAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23323</na:Code>
                            <na:Name>EDOMAINUSERNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostDomainuserRemoveRequest"/>
            <output message="na:HostDomainuserRemoveResponse"/>
        </operation>
        <operation name="HostGetDefaults">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The DFM stores a set of global default Values for selected Attributes, which are used on all Hosts. The administrator can override the Values on a per-host basis. This api returns the default Values for some Attributes returned by HostListInfoIterNext. Default Values vary according To the Host Type.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostGetDefaultsRequest"/>
            <output message="na:HostGetDefaultsResponse"/>
        </operation>
        <operation name="HostListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list Hosts.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostListInfoIterEndRequest"/>
            <output message="na:HostListInfoIterEndResponse"/>
        </operation>
        <operation name="HostListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by HostListInfoIterStart.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostListInfoIterNextRequest"/>
            <output message="na:HostListInfoIterNextResponse"/>
        </operation>
        <operation name="HostListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Hosts. The list of Hosts can include: &lt;ul&gt; &lt;li&gt; Storage Systems &lt;li&gt; vFiler units &lt;li&gt; vserver &lt;li&gt; Host Agents &lt;li&gt; OSSV Agents &lt;li&gt; Switches &lt;/ul&gt; Use the filtering criteria in this API To specify the list of Hosts returned by HostListInfoIterNext. If no filtering criteria is specified, all non-deleted Hosts will be returned by HostListInfoIterNext.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostListInfoIterStartRequest"/>
            <output message="na:HostListInfoIterStartResponse"/>
        </operation>
        <operation name="HostModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify Attributes stored in the DFM database of a Host managed by the DFM.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostModifyRequest"/>
            <output message="na:HostModifyResponse"/>
        </operation>
        <operation name="HostModifyAgentCredentials">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change the Password on the Host Agent for the built in Host Agent management user "admin", using the Operating System credentials specified by OsUsername and OsPassword To authenticate the https POST Request. If the Operation succeeds, update the Host Agent Password stored in the DFM database. Valid only for Host Agents.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22309</na:Code>
                            <na:Name>EHOSTACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22308</na:Code>
                            <na:Name>EHOSTCOMMUNICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22310</na:Code>
                            <na:Name>EHOSTREQUESTDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostModifyAgentCredentialsRequest"/>
            <output message="na:HostModifyAgentCredentialsResponse"/>
        </operation>
        <operation name="HostRoleCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a role on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21028</na:Code>
                            <na:Name>EDUPLICATEROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23306</na:Code>
                            <na:Name>EINVALIDCAPABILITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21027</na:Code>
                            <na:Name>EINVALIDROLENAME</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRoleCreateRequest"/>
            <output message="na:HostRoleCreateResponse"/>
        </operation>
        <operation name="HostRoleDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes a role on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23305</na:Code>
                            <na:Name>EROLEAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRoleDeleteRequest"/>
            <output message="na:HostRoleDeleteResponse"/>
        </operation>
        <operation name="HostRoleListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminates a View list iteration and clean up any saved info.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRoleListIterEndRequest"/>
            <output message="na:HostRoleListIterEndResponse"/>
        </operation>
        <operation name="HostRoleListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To HostRoleListIterStart.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRoleListIterNextRequest"/>
            <output message="na:HostRoleListIterNextResponse"/>
        </operation>
        <operation name="HostRoleListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of roles on Host(s). Roles on Host(s) that Match all filters will be returned. If no input is specified, all the roles on all monitored storage systems or vFiler units will be returned.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRoleListIterStartRequest"/>
            <output message="na:HostRoleListIterStartResponse"/>
        </operation>
        <operation name="HostRoleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modifies a role on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23306</na:Code>
                            <na:Name>EINVALIDCAPABILITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23305</na:Code>
                            <na:Name>EROLEAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRoleModifyRequest"/>
            <output message="na:HostRoleModifyResponse"/>
        </operation>
        <operation name="HostRolePush">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23306</na:Code>
                            <na:Name>EINVALIDCAPABILITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23305</na:Code>
                            <na:Name>EROLEAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostRolePushRequest"/>
            <output message="na:HostRolePushResponse"/>
        </operation>
        <operation name="HostSetOption">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change the Option on the storage system specified by HostOptionName To the Value specified by HostOptionValue. If the Operation succeeds the following Options will be stored in the DFM database and will be returned in the specified elements the next time HostListInfoIterNext is called. &lt;table style="border-collapse: collapse;"&gt; &lt;tr style="background-color: #ddd"&gt; &lt;th style="border: solid;"&gt; HostOptionName &lt;/th&gt; &lt;th style="border: solid;"&gt; HostListInfoIterNext element &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; ndmpd.enable &lt;/td&gt; &lt;td style="border: solid;"&gt; IsNdmpEnabled &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; ndmpd.access &lt;/td&gt; &lt;td style="border: solid;"&gt; NdmpAccessSpecifier &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapvault.enable &lt;/td&gt; &lt;td style="border: solid;"&gt; IsSnapvaultEnabled &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapvault.access &lt;/td&gt; &lt;td style="border: solid;"&gt; SnapvaultAccessSpecifier &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapmirror.enable &lt;/td&gt; &lt;td style="border: solid;"&gt; IsSnapmirrorEnabled &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="border: solid;"&gt; snapmirror.access &lt;/td&gt; &lt;td style="border: solid;"&gt; SnapmirrorAccessSpecifier &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; If the Name of the Host Option ends in ".access" and the Value of the Host Option is the empty string, the Value will be changed To "none". See na_options(1) for a list of Option names and Values. See na_protocolaccess(8) for access specifier syntax and usage. Valid only for storage systems.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21001</na:Code>
                            <na:Name>EHOSTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostSetOptionRequest"/>
            <output message="na:HostSetOptionResponse"/>
        </operation>
        <operation name="HostUserAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a local user on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23310</na:Code>
                            <na:Name>EDUPLICATEUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23313</na:Code>
                            <na:Name>EINVALIDPASSWORDAGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23311</na:Code>
                            <na:Name>EINVALIDUSERFULLNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21046</na:Code>
                            <na:Name>EINVALIDUSERNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23312</na:Code>
                            <na:Name>EPASSWORDAGENOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserAddRequest"/>
            <output message="na:HostUserAddResponse"/>
        </operation>
        <operation name="HostUserDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes a local user on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23309</na:Code>
                            <na:Name>EUSERAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserDeleteRequest"/>
            <output message="na:HostUserDeleteResponse"/>
        </operation>
        <operation name="HostUserListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminates a View list iteration and clean up any saved info.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserListIterEndRequest"/>
            <output message="na:HostUserListIterEndResponse"/>
        </operation>
        <operation name="HostUserListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To HostUserListIterStart.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserListIterNextRequest"/>
            <output message="na:HostUserListIterNextResponse"/>
        </operation>
        <operation name="HostUserListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of local users on Host(s). Local users on Host(s) that matches all filters will be returned. If no input is specified, all the local users on all monitored storage systems or vFiler units will be returned.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserListIterStartRequest"/>
            <output message="na:HostUserListIterStartResponse"/>
        </operation>
        <operation name="HostUserModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modifies local user on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23313</na:Code>
                            <na:Name>EINVALIDPASSWORDAGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23311</na:Code>
                            <na:Name>EINVALIDUSERFULLNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23312</na:Code>
                            <na:Name>EPASSWORDAGENOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23309</na:Code>
                            <na:Name>EUSERAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserModifyRequest"/>
            <output message="na:HostUserModifyResponse"/>
        </operation>
        <operation name="HostUserModifyPassword">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modifies Password of a local user on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23309</na:Code>
                            <na:Name>EUSERAMBIGUOUS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserModifyPasswordRequest"/>
            <output message="na:HostUserModifyPasswordResponse"/>
        </operation>
        <operation name="HostUserPush">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23332</na:Code>
                            <na:Name>EINCOMPATIBLEUSERGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23312</na:Code>
                            <na:Name>EPASSWORDAGENOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23309</na:Code>
                            <na:Name>EUSERAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUserPushRequest"/>
            <output message="na:HostUserPushResponse"/>
        </operation>
        <operation name="HostUsergroupCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a usergroup on the Host. This is applicable for Hosts running ONTAP versions 7.0 and above.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23322</na:Code>
                            <na:Name>EDUPLICATEUSERGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23321</na:Code>
                            <na:Name>EINVALIDUSERGROUPNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupCreateRequest"/>
            <output message="na:HostUsergroupCreateResponse"/>
        </operation>
        <operation name="HostUsergroupDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes a usergroup on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23308</na:Code>
                            <na:Name>EUSERGROUPAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupDeleteRequest"/>
            <output message="na:HostUsergroupDeleteResponse"/>
        </operation>
        <operation name="HostUsergroupListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminates a View list iteration and clean up any saved info.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupListIterEndRequest"/>
            <output message="na:HostUsergroupListIterEndResponse"/>
        </operation>
        <operation name="HostUsergroupListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To HostUsergroupListIterStart.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupListIterNextRequest"/>
            <output message="na:HostUsergroupListIterNextResponse"/>
        </operation>
        <operation name="HostUsergroupListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of usergroups on Host(s). Usergroups on Host(s) that Match all filters will be returned. If no input is specified, all the usergroups on all monitored storage systems or vFiler units will be returned.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupListIterStartRequest"/>
            <output message="na:HostUsergroupListIterStartResponse"/>
        </operation>
        <operation name="HostUsergroupModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modifies a usergroup on the Host.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23322</na:Code>
                            <na:Name>EDUPLICATEUSERGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23321</na:Code>
                            <na:Name>EINVALIDUSERGROUPNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23308</na:Code>
                            <na:Name>EUSERGROUPAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupModifyRequest"/>
            <output message="na:HostUsergroupModifyResponse"/>
        </operation>
        <operation name="HostUsergroupPush">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Pushes a usergroup To a Host. This is applicable for Hosts running ONTAP versions 7.0 and above. The Operation succeeds when the Host on which the usergroup is To be pushed contains roles similar To that of the usergroup. Two roles are similar if they have the same Name and same set of Capabilities.</na:Description>
                    <na:Category>Host</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22265</na:Code>
                            <na:Name>EBADHOSTTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13166</na:Code>
                            <na:Name>EHOSTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23304</na:Code>
                            <na:Name>EHOSTOSVERSIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23331</na:Code>
                            <na:Name>EINCOMPATIBLEROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23308</na:Code>
                            <na:Name>EUSERGROUPAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23307</na:Code>
                            <na:Name>EUSERGROUPNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:HostUsergroupPushRequest"/>
            <output message="na:HostUsergroupPushResponse"/>
        </operation>
        <operation name="IfcListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of Interfaces.</na:Description>
                    <na:Category>Ifc</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:IfcListInfoIterEndRequest"/>
            <output message="na:IfcListInfoIterEndResponse"/>
        </operation>
        <operation name="IfcListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next set of Records in the iteration started by call To IfcListInfoIterStart.</na:Description>
                    <na:Category>Ifc</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:IfcListInfoIterNextRequest"/>
            <output message="na:IfcListInfoIterNextResponse"/>
        </operation>
        <operation name="IfcListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start iteration of Interfaces.</na:Description>
                    <na:Category>Ifc</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:IfcListInfoIterStartRequest"/>
            <output message="na:IfcListInfoIterStartResponse"/>
        </operation>
        <operation name="LunListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The LunListInfoIter* set of APIs are used To retrieve the list of Luns. LunListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the LunListInfoIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Lun</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:LunListInfoIterEndRequest"/>
            <output message="na:LunListInfoIterEndResponse"/>
        </operation>
        <operation name="LunListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check LunListInfoIterStart. The LunListInfoIterNext API is used To iterate over the Members of the Luns stored in the temporary store created by the LunListInfoIterStart API.</na:Description>
                    <na:Category>Lun</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:LunListInfoIterNextRequest"/>
            <output message="na:LunListInfoIterNextResponse"/>
        </operation>
        <operation name="LunListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The LunListInfoIter* set of APIs are used To retrieve the list of Luns in DFM. LunListInfoIterStart returns the union of Lun Objects specified, intersected with RbacOperation. It loads the list of Luns into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Luns in the temporary store. If LunListInfoIterStart is invoked twice, then two distinct temporary stores are created.</na:Description>
                    <na:Category>Lun</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:LunListInfoIterStartRequest"/>
            <output message="na:LunListInfoIterStartResponse"/>
        </operation>
        <operation name="MigrateCancel">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Cancel the migration Operation for the specified vFiler Unit or Dataset. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status of the specified vFiler Unit is such that MigrateCancel Operation cannot be initiated. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateCancelRequest"/>
            <output message="na:MigrateCancelResponse"/>
        </operation>
        <operation name="MigrateChangeState">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Change the state of a migration Operation initiated for a vFiler Unit or Dataset. Only the following state changes are allowed through this API: &lt;ul&gt; &lt;li&gt; Change From "migrated" To "not_started": This is used To retain stale storage on the Source hosting storage system and migrating a vFiler Unit again. &lt;li&gt; Change From "migrated_with_errors" To "migrated": This is used To change the state after going through the Errors that occured after cutover and correcting them as necessary. &lt;li&gt; Change From "rolledback_with_errors" To "rolledback": This is used To change the state after going through the Errors that occured after cutover and correcting them as necessary. Error conditions: &lt;UL&gt; EDATABASEERROR - A database Error occurred while processing the Request. EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status change is not allowed. EINVALIDINPUT - Invalid input specified. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateChangeStateRequest"/>
            <output message="na:MigrateChangeStateResponse"/>
        </operation>
        <operation name="MigrateCleanup">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete the stale storage associated with a migration Operation From the Source storage system. This will Destroy all the Volumes of the Source vFiler Unit after successful migration of the vFiler Unit. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status of the specified vFiler Unit is such that MigrateCleanup Operation cannot be initiated. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateCleanupRequest"/>
            <output message="na:MigrateCleanupResponse"/>
        </operation>
        <operation name="MigrateComplete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Complete the migration Operation by doing a cutover From the Source vFiler Unit To destination vFiler Unit. As part of cutover Operation the following will be done: A script if specified, will be run in pre mode. The actual cutover will be carried out so that the Source vFiler Unit is destroyed and data will be served From the destination vFiler Unit. The script if specified, will be run in post mode after successful cutover. For all Volumes of the vFiler Unit, the protection relationships will be migrated To the new destination. All the backup versions will be modified so that they point appropriately To the newly created destination Volumes. The migration Status is changed To 'migrated' after a successful completion of migration. If MigrateComplete fails To cutover To destination storage, then the migration Status is changed To 'migrate-failed'. If the cutover To the destination storage succeeds during completion, but some of the subsequent steps like migrating the protection relationships, or copying the History data fails, then the Status is changed To 'migrated-with-errors'. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the specified vFiler Unit is not in "migrating" Status. &lt;LI&gt;EONLINENOTPOSSIBLE - When online migration cannot be performed, but offline migration is still possible. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23521</na:Code>
                            <na:Name>EONLINENOTPOSSIBLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateCompleteRequest"/>
            <output message="na:MigrateCompleteResponse"/>
        </operation>
        <operation name="MigrateFix">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Fix the migration Status of a Dataset. This API should be called if migration job was aborted abnormally, due To server shutdown or machine reboot etc. It fixes the database entries and migration Status of the Dataset. It can be called only if the last migration job run on the Dataset terminated abnormally. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDINPUT - Invalid input specified. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateFixRequest"/>
            <output message="na:MigrateFixResponse"/>
        </operation>
        <operation name="MigrateRollback">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Rollback the previous migrated vFiler Unit From the destination vFiler Unit To it's original Source vFiler Unit. As part of rollback Operation the following will be done: A script if specified, will be run in pre mode. Rollback will be carried out so that the destination vFiler Unit is destroyed and data will be served From the Source vFiler Unit. The script if specified, will be run in post mode after successful cutover. For all Volumes of the vFiler Unit, the protection relationships will be migrated To the new destination. All the backup versions will be modified so that they point appropriately To the newly created Source Volumes. The migration Status is changed To 'rolled_back' after a successful rollback. If MigrateRollback fails To cutover To Source storage, then the migration Status will be changed To 'migrated'. If the cutover To the Source storage succeeds during rollback, but some of the subsequent steps like migrating the protection relationships, or copying the History data fails, then the Status is changed To 'rolled_back_with_errors'. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EONLINENOTPOSSIBLE - When online migration cannot be performed, but offline migration is still possible. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23521</na:Code>
                            <na:Name>EONLINENOTPOSSIBLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateRollbackRequest"/>
            <output message="na:MigrateRollbackResponse"/>
        </operation>
        <operation name="MigrateStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start the migration Operation for a Dataset or a vFiler Unit. This initiates a baseline transfer for all the Volumes in the Source vFiler Unit and changes the migration Status To 'migrating'. When a Dataset is given as input then the following conditions should hold good: &lt;UL&gt; &lt;LI&gt; A vFiler Unit should be attached To the primary node of the Dataset. &lt;LI&gt; All the Volumes of the vFiler Unit with the exception of the root storage should belong To this Dataset. &lt;LI&gt; For offline migration, the migrating vFiler Unit may contain Qtree as it's root storage. &lt;LI&gt; For online migration, the migrating vFiler Unit should contain a Volume as it's root storage. &lt;/UL&gt; If any of these conditions are not met, then EMIGRATENOTSUPPORTED is returned. If PerformCutover is set To true, then MigrateComplete will be done after MigrateStart. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. If ResourceNameOrId refers To a Resource pool, user should have DFM.ResourcePool.Provision on it. If ResourceNameOrId refers To a storage system, user should have DFM.Resource.Control on it. If ProvisioningPolicyNameOrId is specified, user should have DFM.Policy.Read on it. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit, Dataset, destination storage system or provisioning Policy is not found. &lt;LI&gt;EINVALIDMEMBERTYPE - When the specified Filer is in c-mode. &lt;LI&gt;EINVALIDINPUT - When invalid inputs are provided for IP Address, Netmask. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the specified vFiler Unit is already in "migrating" Status or in a state where migration cannot be started. &lt;LI&gt;EMIGRATENOTSUPPORTED - When the Dataset or Source vFiler Unit cannot be migrated due To various reasons like invalid vFiler Status, ONTAP Version. &lt;LI&gt;EMIGRATEDESTINATIONSELECTIONFAILED - When a suitable storage system is not found as a destination for migration. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22262</na:Code>
                            <na:Name>EINVALIDMEMBERTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23508</na:Code>
                            <na:Name>EMIGRATEDESTINATIONSELECTIONFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23509</na:Code>
                            <na:Name>EMIGRATENOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateStartRequest"/>
            <output message="na:MigrateStartResponse"/>
        </operation>
        <operation name="MigrateUpdate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Update all the SnapMirror relationships of a vFiler Unit for which migration Operation has been initiated. Error conditions: &lt;UL&gt; &lt;LI&gt;EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt;EACCESSDENIED - User does not have required Capabilities To initiate the MigrateStart Operation. If ObjectNameOrId refers To a Dataset, user should have DFM.Dataset.Write on the datset. If ObjectNameOrId refers To a vFiler Unit, user should have DFM.Resource.Control on the Dataset. &lt;LI&gt;EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;LI&gt;EOBJECTNOTFOUND - When the specified vFiler Unit or Dataset is not found. &lt;LI&gt;EINVALIDMIGRATIONSTATUS - When the migration Status of the vFiler Unit is such that MigrateUpdate cannot be called. &lt;/UL&gt;</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23507</na:Code>
                            <na:Name>EINVALIDMIGRATIONSTATUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateUpdateRequest"/>
            <output message="na:MigrateUpdateResponse"/>
        </operation>
        <operation name="MigrateVolume">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Migrate one or more Volumes From one Aggregate To another Aggregate on the same or different storage system. Currently this API works only for secondary Volumes i.e destinations of a Volume SnapMirror or Qtree SnapMirror relationships or if the Volumes are SnapVault secondaries. In addition To the above, the following rules must be satisfied To be able To MigrateStart Volumes using this API :- &lt;UL&gt; &lt;LI&gt; The Volume(s) should not have child clones (FlexClones). &lt;LI&gt; The Volume(s) should not have NFS exports, CIFS shares or contain LUNs mapped To storage clients. &lt;LI&gt; The Volumes(s) should be part of a Dataset (i.e either imported into Datasets, or provisioned by Protection Manager.) so that incoming and outgoing data protection relationships To and From the Volumes are managed by Protection Manager. &lt;UL&gt; If the destination Aggregate is not specified, then the system will automatically select an Aggregate, based on the Type of the Volume, space requirements, provisioning and protection Policy configuration associated with the Dataset.</na:Description>
                    <na:Category>Migrate</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23805</na:Code>
                            <na:Name>EDATASETBUSY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23508</na:Code>
                            <na:Name>EMIGRATEDESTINATIONSELECTIONFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23509</na:Code>
                            <na:Name>EMIGRATENOTSUPPORTED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:MigrateVolumeRequest"/>
            <output message="na:MigrateVolumeResponse"/>
        </operation>
        <operation name="NetifIpInterfaceListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the list of Interfaces on a storage system.</na:Description>
                    <na:Category>Netif</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:NetifIpInterfaceListInfoRequest"/>
            <output message="na:NetifIpInterfaceListInfoResponse"/>
        </operation>
        <operation name="PerfAssocViewListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a View list iteration and clean up any saved info by a previous call To PerfAssocViewListIterStart</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfAssocViewListIterEndRequest"/>
            <output message="na:PerfAssocViewListIterEndResponse"/>
        </operation>
        <operation name="PerfAssocViewListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns Objects From a previous call To PerfAssocViewListIterStart</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfAssocViewListIterNextRequest"/>
            <output message="na:PerfAssocViewListIterNextResponse"/>
        </operation>
        <operation name="PerfAssocViewListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of performance Views.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfAssocViewListIterStartRequest"/>
            <output message="na:PerfAssocViewListIterStartResponse"/>
        </operation>
        <operation name="PerfClientStatsListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends an iteration started by PerfClientStatsListInfoIterStart</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfClientStatsListInfoIterEndRequest"/>
            <output message="na:PerfClientStatsListInfoIterEndResponse"/>
        </operation>
        <operation name="PerfClientStatsListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns the per-client statistics loaded in a previous call To PerfClientStatsListInfoIterStart</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfClientStatsListInfoIterNextRequest"/>
            <output message="na:PerfClientStatsListInfoIterNextResponse"/>
        </operation>
        <operation name="PerfClientStatsListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Iterates over the historical data of stored client statistics for storage systems. If no input filters are specified, all the available collections of statistics will be returned.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfClientStatsListInfoIterStartRequest"/>
            <output message="na:PerfClientStatsListInfoIterStartResponse"/>
        </operation>
        <operation name="PerfClientStatsPurge">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove collected client Stats From the database. If no input is specified, all collections for Hosts on which the user can perform the DFM.Database.Write Operation will be purged.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfClientStatsPurgeRequest"/>
            <output message="na:PerfClientStatsPurgeResponse"/>
        </operation>
        <operation name="PerfCollectClientOperationStatistics">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Collect per-client NFS and CIFS Operation statistics for a storage system. The collection of such statistics will be enabled on all vFiler units on the storage system for a short Period of time, and the collected Values will then be summarized and returned for the storage system as a whole. This ZAPI is synchronous and will not return an Error even if there are Errors collecting per-client statistics From some or all vFiler units on the storage system.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21008</na:Code>
                            <na:Name>EBADCREDENTIALS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCollectClientOperationStatisticsRequest"/>
            <output message="na:PerfCollectClientOperationStatisticsResponse"/>
        </operation>
        <operation name="PerfCopyCounterConfiguration">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Propagates Source Host's current data collection settings To destination Hosts. When counter configuration is copied To destination Hosts, even if it fails for one Host, it proceeds further with the next available Host in the destination list. Privilege required is DFM.Database.Write.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCopyCounterConfigurationRequest"/>
            <output message="na:PerfCopyCounterConfigurationResponse"/>
        </operation>
        <operation name="PerfCounterGroupCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a counter Group. Global DFM.PerfView.Write is required To create historical counter Group. To create a RealTime counter Group Global DFM.PerfView.RealTimeRead is required.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupCreateRequest"/>
            <output message="na:PerfCounterGroupCreateResponse"/>
        </operation>
        <operation name="PerfCounterGroupDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroys a counter Group. Privilege To Destroy a historical counter Group is Global DFM.PerfView.Delete. And To Destroy a RealTime counter Group, Global DFM.PerfView.RealTimeRead is required.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupDestroyRequest"/>
            <output message="na:PerfCounterGroupDestroyResponse"/>
        </operation>
        <operation name="PerfCounterGroupGetData">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve a set of data for a set of data sources From a specific counter Group. The data is extracted for the given time interval bounded by StartTime and EndTime. This API is suitable for extracting the data for a single line in a chart (graph). Privilege required is DFM.Database.Read. For viewing RealTime data Global DFM.PerfView.RealTimeRead is also required.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupGetDataRequest"/>
            <output message="na:PerfCounterGroupGetDataResponse"/>
        </operation>
        <operation name="PerfCounterGroupGetDynamicDataSources">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve a list of top-n data sources for a counter. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22228</na:Code>
                            <na:Name>EGROUPDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupGetDynamicDataSourcesRequest"/>
            <output message="na:PerfCounterGroupGetDynamicDataSourcesResponse"/>
        </operation>
        <operation name="PerfCounterGroupListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve one or more counter Groups. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupListInfoRequest"/>
            <output message="na:PerfCounterGroupListInfoResponse"/>
        </operation>
        <operation name="PerfCounterGroupListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a counter Group list iteration and clean up any saved info. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupListIterEndRequest"/>
            <output message="na:PerfCounterGroupListIterEndResponse"/>
        </operation>
        <operation name="PerfCounterGroupListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To PerfCounterGroupListIterStart. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupListIterNextRequest"/>
            <output message="na:PerfCounterGroupListIterNextResponse"/>
        </operation>
        <operation name="PerfCounterGroupListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of performance counter Group names. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupListIterStartRequest"/>
            <output message="na:PerfCounterGroupListIterStartResponse"/>
        </operation>
        <operation name="PerfCounterGroupModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an existing counter Group. User can modify the sample-interval, SampleBuffer and the counter set of an existing counter Group at the individual Host level. Modifying a counter set of a counter Group means user can selectively enable/disable Counters according To the requirement of collecting data. If a counter is disabled data will not be collected for that counter and this gives the flexibility of controlling load on a storage system. This zapi will only enable the Counters mentioned in the 'DataSources' part of the input parameter 'PerfCounterGroupStart' and rest of the Counters of the counter Group will be automatically disabled. User can also disable all the Counters of a counter Group by setting the flag 'IsDisableAll' in the input parameter 'PerfCounterGroupStart'. Enabling/disabling Counters is not allowed for calculated Stats Counters in default counter Groups. Privilege required is DFM.Database.Write.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupModifyRequest"/>
            <output message="na:PerfCounterGroupModifyResponse"/>
        </operation>
        <operation name="PerfCounterGroupStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start data collection for one counter Group. Privilege required is Global DFM.PerfView.Write for normal Views and Global DFM.PerfView.RealTimeRead for RealTime Views.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupStartRequest"/>
            <output message="na:PerfCounterGroupStartResponse"/>
        </operation>
        <operation name="PerfCounterGroupStop">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Stop data collection for one counter Group. Privilege required is Global DFM.PerfView.Write for normal Views and Global DFM.PerfView.RealTimeRead for RealTime Views.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfCounterGroupStopRequest"/>
            <output message="na:PerfCounterGroupStopResponse"/>
        </operation>
        <operation name="PerfDiagTroubleshoot">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>This API shall troubleshoot the DFM object for performance related issues and provides the recommendations To help resolve them.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfDiagTroubleshootRequest"/>
            <output message="na:PerfDiagTroubleshootResponse"/>
        </operation>
        <operation name="PerfDisableDataCollection">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Disables DFM performance advisor data collection.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfDisableDataCollectionRequest"/>
            <output message="na:PerfDisableDataCollectionResponse"/>
        </operation>
        <operation name="PerfDisableObjectUpdate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Disables any modification To DFM performance advisor Views, counter Groups and object Instances.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfDisableObjectUpdateRequest"/>
            <output message="na:PerfDisableObjectUpdateResponse"/>
        </operation>
        <operation name="PerfEnableDataCollection">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Enables DFM performance advisor data collection.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfEnableDataCollectionRequest"/>
            <output message="na:PerfEnableDataCollectionResponse"/>
        </operation>
        <operation name="PerfEnableObjectUpdate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Enables modifications To DFM performance advisor Views, counter Groups and object Instances.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfEnableObjectUpdateRequest"/>
            <output message="na:PerfEnableObjectUpdateResponse"/>
        </operation>
        <operation name="PerfGetCounterData">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve data for all the related Objects for the given object and the specified performance Counters.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfGetCounterDataRequest"/>
            <output message="na:PerfGetCounterDataResponse"/>
        </operation>
        <operation name="PerfGetCounterDependents">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Find out the Operations Manager Reports, Performance Advisor custom Views, Performance Advisor threshold templates and Performance Advisor Thresholds which depend on the specified performance Counters.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfGetCounterDependentsRequest"/>
            <output message="na:PerfGetCounterDependentsResponse"/>
        </operation>
        <operation name="PerfGetCounterListNotInView">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Given an array of performance Objects and Counters, the API will return a list of all Counters that are not part of any View.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfGetCounterListNotInViewRequest"/>
            <output message="na:PerfGetCounterListNotInViewResponse"/>
        </operation>
        <operation name="PerfGetDefaultView">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Gets the default View for an object.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfGetDefaultViewRequest"/>
            <output message="na:PerfGetDefaultViewResponse"/>
        </operation>
        <operation name="PerfGetServerStatus">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns the Status of DFM Performance Advisor.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfGetServerStatusRequest"/>
            <output message="na:PerfGetServerStatusResponse"/>
        </operation>
        <operation name="PerfObjectCounterListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve information about a performance object's Counters. (No iterator-based equivalent exists for this API because the number of object Counters is fewer than two hundred in number.) Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfObjectCounterListInfoRequest"/>
            <output message="na:PerfObjectCounterListInfoResponse"/>
        </operation>
        <operation name="PerfObjectDependentCounterListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve information about a performance object's dependent Counters. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfObjectDependentCounterListInfoRequest"/>
            <output message="na:PerfObjectDependentCounterListInfoResponse"/>
        </operation>
        <operation name="PerfObjectInstanceListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate an Instance list iteration and clean up any saved info. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfObjectInstanceListIterEndRequest"/>
            <output message="na:PerfObjectInstanceListIterEndResponse"/>
        </operation>
        <operation name="PerfObjectInstanceListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To PerfObjectInstanceListIterStart Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfObjectInstanceListIterNextRequest"/>
            <output message="na:PerfObjectInstanceListIterNextResponse"/>
        </operation>
        <operation name="PerfObjectInstanceListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of performance object Instance names. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfObjectInstanceListIterStartRequest"/>
            <output message="na:PerfObjectInstanceListIterStartResponse"/>
        </operation>
        <operation name="PerfObjectListInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get a list of performance Objects. (No iterator-based equivalent exists for this API because the number of performance Objects is fewer than twenty in number.) Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfObjectListInfoRequest"/>
            <output message="na:PerfObjectListInfoResponse"/>
        </operation>
        <operation name="PerfSetDefaultView">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Sets the default View for an object.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfSetDefaultViewRequest"/>
            <output message="na:PerfSetDefaultViewResponse"/>
        </operation>
        <operation name="PerfStatusGet">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns the DFM performance advisor Status</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfStatusGetRequest"/>
            <output message="na:PerfStatusGetResponse"/>
        </operation>
        <operation name="PerfThresholdCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Sets threshold Values on one or more Objects based on a performance counter. Privilege required is DFM.Database.Write. Threshold will be set only if the User has DFM.Database.Write Permission over the object specified.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23317</na:Code>
                            <na:Name>ETHRESHOLDEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdCreateRequest"/>
            <output message="na:PerfThresholdCreateResponse"/>
        </operation>
        <operation name="PerfThresholdCreate2">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates one threshold composed of one or more Counters, and optionally applies it To an object. The user must have the Capability To perform the DFM.Database.Write Operation on the object on which the threshold is applied.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdCreate2Request"/>
            <output message="na:PerfThresholdCreate2Response"/>
        </operation>
        <operation name="PerfThresholdDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Removes threshold set on a counter. The user must have the Capability To perform the DFM.Database.Delete Operation on the object on which the threshold is directly applied.&lt;P&gt; This ZAPI cannot be used To delete template Thresholds, and PerfThresholdTemplateModify should be used for that purpose.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdDeleteRequest"/>
            <output message="na:PerfThresholdDeleteResponse"/>
        </operation>
        <operation name="PerfThresholdListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a counter-thresholds-list iteration and clean up any saved info. Privilege required is DFM.Database.Read. Only Thresholds on Objects over which the user has DFM.Database.Read permissions will be returned.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdListInfoIterEndRequest"/>
            <output message="na:PerfThresholdListInfoIterEndResponse"/>
        </operation>
        <operation name="PerfThresholdListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdListInfoIter* list of APIs are used To retrieve the list of all Counters on which Thresholds have been set. It loads the list of Counters on which Thresholds have been set into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the threshold related Counters in the temporary store. Privilege required is DFM.Database.Read. Only Thresholds on Objects over which the user has DFM.Database.Read permissions will be returned.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdListInfoIterNextRequest"/>
            <output message="na:PerfThresholdListInfoIterNextResponse"/>
        </operation>
        <operation name="PerfThresholdListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdListInfoIter* list of APIs are used To retrieve the list of all Counters on which Thresholds have been set. It loads the list of Counters on which Thresholds have been set into a temporary store. The API returns a Tag that identifies a temporary store so that subsequent APIs can be used To iterate over the threshold related Counters in the temporary store. Privilege required is DFM.Database.Read. Only Thresholds on Objects over which the User has DFM.Database.Read permissions will be returned.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdListInfoIterStartRequest"/>
            <output message="na:PerfThresholdListInfoIterStartResponse"/>
        </operation>
        <operation name="PerfThresholdListInfo2IterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a perf-thresholds-list-info2 iteration and clean up any saved info.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdListInfo2IterEndRequest"/>
            <output message="na:PerfThresholdListInfo2IterEndResponse"/>
        </operation>
        <operation name="PerfThresholdListInfo2IterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdListInfo2Iter* list of APIs are used To retrieve the list of all Objects on which Thresholds have been set.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdListInfo2IterNextRequest"/>
            <output message="na:PerfThresholdListInfo2IterNextResponse"/>
        </operation>
        <operation name="PerfThresholdListInfo2IterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdListInfo2Iter* list of APIs are used To retrieve the list of Objects on which Thresholds have been set. It loads the list of Thresholds into a temporary store. The API returns a Tag that identifies the temporary store so that subsequent APIs can be used To iterate over the Thresholds in it. The user must have the Capability To perform the DFM.Database.Read Operation on the object on which the threshold is applied, and only Thresholds which are applied on such Objects will be returned.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdListInfo2IterStartRequest"/>
            <output message="na:PerfThresholdListInfo2IterStartResponse"/>
        </operation>
        <operation name="PerfThresholdModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Allows modification of threshold Value and threshold interval that have been set before. Privilege required is DFM.Database.Write.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdModifyRequest"/>
            <output message="na:PerfThresholdModifyResponse"/>
        </operation>
        <operation name="PerfThresholdModify2">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an existing threshold. This ZAPI should be used only for changing the parameters of a threshold, not for changing the Objects it is not applied on. The ObjectsInfo structure is ignored in this ZAPI. This ZAPI cannot be used To modify template Thresholds, and PerfThresholdTemplateModify should be used for that purpose. The user must have the Capability To perform the DFM.Database.Write Operation on the object on which the threshold is applied.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdModify2Request"/>
            <output message="na:PerfThresholdModify2Response"/>
        </operation>
        <operation name="PerfThresholdTemplateAttachObjects">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Attach one or more Objects To a performance template. Either all input Objects get attached or none of them get attached. The specified Objects will get associated To the applicable Thresholds in the template. Objects cannot be attached if the template has no Thresholds. Objects already attached To the template are left unchanged. The user must have the Capability To perform the DFM.Database.Write Operation on the object To which the template is To be attached.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateAttachObjectsRequest"/>
            <output message="na:PerfThresholdTemplateAttachObjectsResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a template for perf Thresholds.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23417</na:Code>
                            <na:Name>EPERFTEMPLATEEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateCreateRequest"/>
            <output message="na:PerfThresholdTemplateCreateResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes a template.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateDeleteRequest"/>
            <output message="na:PerfThresholdTemplateDeleteResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateDetachObjects">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Detaches one or more Objects From a performance template. Either all or none of the input Objects get detached. The user must have the Capability To perform the DFM.Database.Write Operation on the object which is To be detached From the template.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateDetachObjectsRequest"/>
            <output message="na:PerfThresholdTemplateDetachObjectsResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a perf-threshold-template-list iteration and clean up any saved information.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateListInfoIterEndRequest"/>
            <output message="na:PerfThresholdTemplateListInfoIterEndResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdTemplateListInfoIter* list of APIs are used To retrieve the list of all Objects on which Thresholds have been set.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateListInfoIterNextRequest"/>
            <output message="na:PerfThresholdTemplateListInfoIterNextResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdTemplateListInfoIter* list of APIs are used To retrieve the list of all threshold templates that have been created. It loads the templates into a temporary store. The API returns a Tag that identifies a temporary store so that subsequent APIs can be used To iterate over the threshold related Counters in the temporary store.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateListInfoIterStartRequest"/>
            <output message="na:PerfThresholdTemplateListInfoIterStartResponse"/>
        </operation>
        <operation name="PerfThresholdTemplateModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The PerfThresholdTemplateModify zapi is used To modify an existing threshold template. It can be used To add, remove or modify Thresholds in the template or modify Attributes of the template</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfThresholdTemplateModifyRequest"/>
            <output message="na:PerfThresholdTemplateModifyResponse"/>
        </operation>
        <operation name="PerfViewAssociatedObjectsList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List all the Objects associated with the View.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewAssociatedObjectsListRequest"/>
            <output message="na:PerfViewAssociatedObjectsListResponse"/>
        </operation>
        <operation name="PerfViewCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a performance View. A performance View consists of one or more Charts, but each View refers To only a single counter Group. Global DFM.PerfView.Write RBAC Capability is required To create normal Views while Global DFM.PerfView.RealTimeRead is required To create RealTime View.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23314</na:Code>
                            <na:Name>EPERFUPDATEDISABLED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewCreateRequest"/>
            <output message="na:PerfViewCreateResponse"/>
        </operation>
        <operation name="PerfViewDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a performance View. Global DFM.PerfView.Delete is required for destroying normal Views while Global DFM.PerfView.RealTimeRead is required for destroying RealTime Views.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewDestroyRequest"/>
            <output message="na:PerfViewDestroyResponse"/>
        </operation>
        <operation name="PerfViewGetData">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve data for a single DataSource From a specific performance View. The data is extracted for the given time interval bounded by StartTime and EndTime.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewGetDataRequest"/>
            <output message="na:PerfViewGetDataResponse"/>
        </operation>
        <operation name="PerfViewListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a View list iteration and clean up any saved info. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewListIterEndRequest"/>
            <output message="na:PerfViewListIterEndResponse"/>
        </operation>
        <operation name="PerfViewListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve items From a previous call To PerfViewListIterStart Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewListIterNextRequest"/>
            <output message="na:PerfViewListIterNextResponse"/>
        </operation>
        <operation name="PerfViewListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of performance Views. Privilege required is read.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewListIterStartRequest"/>
            <output message="na:PerfViewListIterStartResponse"/>
        </operation>
        <operation name="PerfViewModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an existing performance View. Global DFM.PerfView.Write RBAC Capability is required To modify performance Views.</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13003</na:Code>
                            <na:Name>EAPIPRIVILEDGE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewModifyRequest"/>
            <output message="na:PerfViewModifyResponse"/>
        </operation>
        <operation name="PerfViewObjectAssociationAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Associates an object with a View</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewObjectAssociationAddRequest"/>
            <output message="na:PerfViewObjectAssociationAddResponse"/>
        </operation>
        <operation name="PerfViewObjectAssociationDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Removes the association of an object with a View</na:Description>
                    <na:Category>Perf</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:PerfViewObjectAssociationDeleteRequest"/>
            <output message="na:PerfViewObjectAssociationDeleteResponse"/>
        </operation>
        <operation name="ProvisioningPolicyCopy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new provisioning Policy by making a copy of an existing Policy. The new Policy created using this ZAPI has the same set of Properties as the existing Policy. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the existing Policy From the database, or create a new Policy, or both. &lt;LI&gt; EOBJECTNOTFOUND - No existing Policy was found that has the given Name or ID. &lt;LI&gt; EOBJECTAMBIGUOUS - Multiple Objects with the given Name present in database. &lt;LI&gt; EPOLICYEXISTS - A Policy with the given ProvisioningPolicyName already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EINVALIDINPUTERROR - Invalid input was provided. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22261</na:Code>
                            <na:Name>EPOLICYEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyCopyRequest"/>
            <output message="na:ProvisioningPolicyCopyResponse"/>
        </operation>
        <operation name="ProvisioningPolicyCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>This ZAPI creates a new provisioning Policy. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To create policies. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EINVALIDINPUTERROR - Invalid input was provided. &lt;LI&gt; EPOLICYEXISTS - A provisioning Policy with given Name already exists. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22261</na:Code>
                            <na:Name>EPOLICYEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyCreateRequest"/>
            <output message="na:ProvisioningPolicyCreateResponse"/>
        </operation>
        <operation name="ProvisioningPolicyDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a provisioning Policy. This removes it From the database. &lt;P&gt; If the Policy has been applied To any Dataset nodes, then the Destroy Operation fails; it must first be disassociated From all the Dataset nodes To which it has been associated and then destroyed. Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have DFM.Policy.Delete on the Policy being destroyed. &lt;LI&gt; EOBJECTNOTFOUND - The specified provisioning Policy does not exist in the database. &lt;LI&gt; EPROVPOLICYINUSE - The Policy is assigned To one or more Datasets. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EOBJECTAMBIGUOUS - Multiple Objects with the given Name present in database. &lt;LI&gt; EEDITSESSIONINPROGRESS - The provisioning Policy being destroyed locked in an edit session. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22243</na:Code>
                            <na:Name>EEDITSESSIONINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyDestroyRequest"/>
            <output message="na:ProvisioningPolicyDestroyResponse"/>
        </operation>
        <operation name="ProvisioningPolicyEditBegin">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create an edit session and obtain an edit lock on a provisioning Policy To begin modifying the Policy. &lt;P&gt; An edit lock must be obtained before invoking ProvisioningPolicyModify. &lt;P&gt; Use ProvisioningPolicyEditCommit To end the edit session and commit the changes To the database. &lt;P&gt; Use ProvisioningPolicyEditRollback To end the edit session and discard any changes made To the Policy. &lt;P&gt; 24 hours after an edit session on a Policy begins, any subsequent call To ProvisioningPolicyEditBegin for that same Policy automatically rolls back the existing edit session and begins a new edit session, just as if the call had used the Force Option. If there is no such call, the existing edit session simply continues and retains the edit lock. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITINPROGRESS - Another edit session already has an edit lock on the specified provisioning Policy. &lt;LI&gt; EOBJECTNOTFOUND - No provisioning Policy was found that has the given Name or ID. &lt;LI&gt; EACCESSDENIED - User does not have DFM.Policy.Write Privilege on the Policy. modify the provisioning Policy. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22221</na:Code>
                            <na:Name>EEDITINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyEditBeginRequest"/>
            <output message="na:ProvisioningPolicyEditBeginResponse"/>
        </operation>
        <operation name="ProvisioningPolicyEditCommit">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Commit changes made To a provisioning Policy during an edit session into the database.&lt;P&gt; If all the changes To the Policy are performed successfully, the entire edit is committed and the edit lock on the Policy is released.&lt;P&gt; If any of the changes To the Policy are not performed successfully, then the edit is rolled back (none of the changes are committed) and the edit lock on the Policy is released.&lt;P&gt; Use the DryRun Option To test the commit. Using this Option, the changes To the Policy are not committed To the database. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have DFM.Policy.Write on the Policy. &lt;LI&gt; EPOLICYEXISTS - The Policy's Name is being changed, and a Policy with the new Name already exists. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22261</na:Code>
                            <na:Name>EPOLICYEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyEditCommitRequest"/>
            <output message="na:ProvisioningPolicyEditCommitResponse"/>
        </operation>
        <operation name="ProvisioningPolicyEditRollback">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Roll back changes made To a provisioning Policy. The edit lock on the Policy will be released after the rollback. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyEditRollbackRequest"/>
            <output message="na:ProvisioningPolicyEditRollbackResponse"/>
        </operation>
        <operation name="ProvisioningPolicyListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a list iteration that had been started by a call To ProvisioningPolicyListIterStart. This informs the server that it may now release any resources associated with the temporary store for the list iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyListIterEndRequest"/>
            <output message="na:ProvisioningPolicyListIterEndResponse"/>
        </operation>
        <operation name="ProvisioningPolicyListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve the next series of policies that are present in a list iteration created by a call To ProvisioningPolicyListIterStart. The server maintains an internal cursor pointing To the last record returned. Subsequent calls To ProvisioningPolicyListIterNext return the next Maximum Records after the cursor, or all the remaining Records, whichever is fewer. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EINVALIDTAG - The specified Tag does not exist. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyListIterNextRequest"/>
            <output message="na:ProvisioningPolicyListIterNextResponse"/>
        </operation>
        <operation name="ProvisioningPolicyListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Begin a list iteration over all content in all provisioning policies in the system. Optionally, you may iterate over the content of just a single Policy. &lt;p&gt; After calling ProvisioningPolicyListIterStart, you continue the iteration by calling ProvisioningPolicyListIterNext zero or more times, followed by a call To ProvisioningPolicyListIterEnd To terminate the iteration. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EACCESSDENIED - User does not have privileges To read the specified Policy. &lt;LI&gt; EOBJECTNOTFOUND - No Policy was found that has the given Name or ID. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyListIterStartRequest"/>
            <output message="na:ProvisioningPolicyListIterStartResponse"/>
        </operation>
        <operation name="ProvisioningPolicyModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>This ZAPI modifies the provisioning Policy settings of an existing Policy in the database with the new Values specified in the input. Note: Type of provisioning Policy cannot be modified after creation. Before modifying the Policy, an edit lock has To be obtained on the Policy object. &lt;HR&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EEDITSESSIONNOTFOUND - No edit lock was found that has the given ID. &lt;LI&gt; EEDITSESSIONCONFLICTINGOP - current modification made conflicts with previous change in the edit session. &lt;LI&gt; EACCESSDENIED - User does not have privileges To modify the Policy. &lt;LI&gt; EOBJECTNOTFOUND - The Policy was already destroyed during this edit session. &lt;LI&gt; EOBJECTAMBIGUOUS - Multiple Objects with the given Name present in database. &lt;LI&gt; EINVALIDINPUT - The requested modification is not applicable To the Policy being modified. &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EDSCONFLICTDEDUPLICATION - Deduplication schedule cannot be set in the Policy if it is attached To a SnapVault destination node. Valid only for secondary provisioning Policy. &lt;/UL&gt;</na:Description>
                    <na:Category>ProvisioningPolicy</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22264</na:Code>
                            <na:Name>EEDITSESSIONCONFLICTINGOP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22243</na:Code>
                            <na:Name>EEDITSESSIONINPROGRESS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22240</na:Code>
                            <na:Name>EEDITSESSIONNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ProvisioningPolicyModifyRequest"/>
            <output message="na:ProvisioningPolicyModifyResponse"/>
        </operation>
        <operation name="QtreeListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The QtreeListInfoIter* set of APIs are used To retrieve the list of Qtrees. QtreeListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the QtreeListInfoIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeListInfoIterEndRequest"/>
            <output message="na:QtreeListInfoIterEndResponse"/>
        </operation>
        <operation name="QtreeListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check QtreeListInfoIterStart. The QtreeListInfoIterNext API is used To iterate over the Members of the Qtrees stored in the temporary store created by the QtreeListInfoIterStart API.</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeListInfoIterNextRequest"/>
            <output message="na:QtreeListInfoIterNextResponse"/>
        </operation>
        <operation name="QtreeListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The QtreeListInfoIter* set of APIs are used To retrieve the list of Qtrees in DFM. QtreeListInfoIterStart returns the union of Qtree Objects specified, intersected with IsSnapvaultSecondaryQtrees, IsInDataset and RbacOperation. It loads the list of Qtrees into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the Qtrees in the temporary store. If QtreeListInfoIterStart is invoked twice, then two distinct temporary stores are created.</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeListInfoIterStartRequest"/>
            <output message="na:QtreeListInfoIterStartResponse"/>
        </operation>
        <operation name="QtreeModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a Qtree's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Qtree. &lt;li&gt; EINVALIDINPUT - When invalid input specified. &lt;li&gt; EOBJECTNOTFOUND - When the QtreeNameOrId does not correspond To a Qtree. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeModifyRequest"/>
            <output message="na:QtreeModifyResponse"/>
        </operation>
        <operation name="QtreeRename">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Rename a Qtree on a storage system and in the DataFabric Manager database. The new Qtree will still be in the same Volume as the original Qtree. The first step renames the given Qtree on the storage system. If that fails, then processing stops and the API emits an EINTERNALERROR To the caller along with the appropriate Error message. The second step renames the given Qtree on the DFM database. If that fails, then processing stops and the same EINTERNALERROR is emitted back To the caller along with an appropriate Error message. There is no retrying or undoing of any of the steps should they fail. The API relies on the DFM monitor To undo the rename automatically. However, the undoing does not happen right away because it depends on the DFM monitor regular update schedule. The DFM monitor periodically ensures that storage system resources are matched in its database -- it updates the database To be consistent with the storage system. Prior To invoking this API, the storage system's login credentials where the Qtree resides must be specified in DFM's database using normal DFM procedure.</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22225</na:Code>
                            <na:Name>EINVALIDQTREENAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22226</na:Code>
                            <na:Name>EQTREEALREADYEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22224</na:Code>
                            <na:Name>EQTREEDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeRenameRequest"/>
            <output message="na:QtreeRenameResponse"/>
        </operation>
        <operation name="QtreeStartMonitoring">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Start monitoring a previously un-monitored primary Qtree From the DataFabric Manager. Error EQTREEMONITORONFAIL means that an attempt To start monitoring the specified Qtree failed.</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22226</na:Code>
                            <na:Name>EQTREEALREADYEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22236</na:Code>
                            <na:Name>EQTREEDELETEDPARENT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22224</na:Code>
                            <na:Name>EQTREEDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22237</na:Code>
                            <na:Name>EQTREEMONITORONFAIL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22235</na:Code>
                            <na:Name>EQTREEUNDELETEFAIL</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeStartMonitoringRequest"/>
            <output message="na:QtreeStartMonitoringResponse"/>
        </operation>
        <operation name="QtreeStopMonitoring">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Stop monitoring a primary Qtree From the DataFabric Manager. A Qtree that is being managed by an application cannot be stopped being monitored (Errno returned will be EQTREEMANAGEDBYAPP)</na:Description>
                    <na:Category>Qtree</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22224</na:Code>
                            <na:Name>EQTREEDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22234</na:Code>
                            <na:Name>EQTREEMANAGEDBYAPP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22238</na:Code>
                            <na:Name>EQTREEMONITOROFFFAIL</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:QtreeStopMonitoringRequest"/>
            <output message="na:QtreeStopMonitoringResponse"/>
        </operation>
        <operation name="RbacAccessCheck">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Checks whether the given admin or usergroup has access To the specified Resource. For example, RbacAccessCheck will return "allow" or "deny" on the following Query: Is admin joe allowed To configure storage system, host1.abc.xyz.com, From DFM? One could pass the following as input To answer this question: admin=joe operation=DFM.Event.Read resource=host1.abc.xyz.com In order To prevent an admin From querying everyone's privileges on the system, the system will only allow Admins To check their own access by cross-referencing with however they authenticated To the API server. If the admin has Full Control, or has the Privilege To Query other admin's access, then they will be allowed To make the Query. Per software security best practice, this API limits Error reporting when access is denied on a particular Resource.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAccessCheckRequest"/>
            <output message="na:RbacAccessCheckResponse"/>
        </operation>
        <operation name="RbacAdminListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends listing of Admins.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAdminListInfoIterEndRequest"/>
            <output message="na:RbacAdminListInfoIterEndResponse"/>
        </operation>
        <operation name="RbacAdminListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From list generated by RbacAdminListInfoIterStart.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAdminListInfoIterNextRequest"/>
            <output message="na:RbacAdminListInfoIterNextResponse"/>
        </operation>
        <operation name="RbacAdminListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Lists all the administrators and their Attributes.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAdminListInfoIterStartRequest"/>
            <output message="na:RbacAdminListInfoIterStartResponse"/>
        </operation>
        <operation name="RbacAdminRoleAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Assign an existing role To an existing administrator or usergroup. The administrator effectively gains the Capabilities From the role and its inherited roles. As for a usergroup, all Members of the usergroup will gain the Capabilities assigned To that role and its inherited roles.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21031</na:Code>
                            <na:Name>EROLEASSIGNED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAdminRoleAddRequest"/>
            <output message="na:RbacAdminRoleAddResponse"/>
        </operation>
        <operation name="RbacAdminRoleInfoList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List the administrators or usergroups assigned To an existing role directly or indirectly. In essence, this API lists the Admins or usergroups that have the Capabilities of the given role. This API drills into all the possible ways that an admin or usergroup can effectively have the given role. Admins or usergroups are assigned roles indirectly via role inheritance or usergroup assignment (note: a usergroup can be a member of another usergroup). So an admin or usergroup will be listed if any of the following conditions apply: 1. Given role is directly assigned To the admin or usergroup 2. Admin or usergroup has a role directly assigned that inherits given role. 3. Admin or usergroup gains the given role via usergroup membership</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21042</na:Code>
                            <na:Name>ENOTASSIGNEDROLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAdminRoleInfoListRequest"/>
            <output message="na:RbacAdminRoleInfoListResponse"/>
        </operation>
        <operation name="RbacAdminRoleRemove">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove one or more roles From an administrator or usergroup. The admin will no longer have the Capabilities gained From the role(s) and its inherited roles. As for a usergroup, the Members of the usergroup will no longer have the Capabilities gained From the role(s) and its inherited roles. If DeleteAll is not specified or is FALSE, then RoleNameOrId must be specified. If DeleteAll is TRUE, then all roles assigned To admin will be removed.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacAdminRoleRemoveRequest"/>
            <output message="na:RbacAdminRoleRemoveResponse"/>
        </operation>
        <operation name="RbacOperationAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a new Operation To the RBAC system. An Operation is an ability To perform an Action on a particular Resource Type. An Operation is tied To a specific application so that different applications are able To manage access control that are specific To them.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21039</na:Code>
                            <na:Name>EDUPOPERATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21033</na:Code>
                            <na:Name>EINVALIDAPPLICATIONNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21036</na:Code>
                            <na:Name>EINVALIDLONGDESC</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21032</na:Code>
                            <na:Name>EINVALIDOPERATIONNAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21038</na:Code>
                            <na:Name>EINVALIDRESOURCETYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21037</na:Code>
                            <na:Name>EINVALIDSHORTDESC</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacOperationAddRequest"/>
            <output message="na:RbacOperationAddResponse"/>
        </operation>
        <operation name="RbacOperationDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete an existing Operation</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21040</na:Code>
                            <na:Name>ENOTFOUNDOPERATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22289</na:Code>
                            <na:Name>EOPERATIONISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacOperationDeleteRequest"/>
            <output message="na:RbacOperationDeleteResponse"/>
        </operation>
        <operation name="RbacOperationInfoList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get information about an existing Operation or all operations in the system.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21040</na:Code>
                            <na:Name>ENOTFOUNDOPERATION</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacOperationInfoListRequest"/>
            <output message="na:RbacOperationInfoListResponse"/>
        </operation>
        <operation name="RbacRoleAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a new role To the RBAC system</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21028</na:Code>
                            <na:Name>EDUPLICATEROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21027</na:Code>
                            <na:Name>EINVALIDROLENAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleAddRequest"/>
            <output message="na:RbacRoleAddResponse"/>
        </operation>
        <operation name="RbacRoleAdminInfoList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>List the roles assigned To an existing administratror or usergroup. A role is considered assigned To the administrator if that role is gained directly or indirectly via role inheritance or usergroup membership.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21047</na:Code>
                            <na:Name>ENOTFOUNDUSER</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleAdminInfoListRequest"/>
            <output message="na:RbacRoleAdminInfoListResponse"/>
        </operation>
        <operation name="RbacRoleCapabilityAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add an existing resource/operation pair To a role. In essence, this adds a Capability To a role.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21044</na:Code>
                            <na:Name>EDUPCAPABILITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21041</na:Code>
                            <na:Name>EINVALIDRESOURCE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21040</na:Code>
                            <na:Name>ENOTFOUNDOPERATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21048</na:Code>
                            <na:Name>EROLEISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleCapabilityAddRequest"/>
            <output message="na:RbacRoleCapabilityAddResponse"/>
        </operation>
        <operation name="RbacRoleCapabilityRemove">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove one or more Capabilities (resource/operation pair) From an existing role. If DeleteAll is TRUE, it removes all Capabilities From given role. Otherwise, it removes only the given Capability (resource/operation pair). If DeleteAll is not specified or is FALSE, then Operation and Resource must be specified.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21043</na:Code>
                            <na:Name>ENOTASSIGNEDCAPABILITY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21040</na:Code>
                            <na:Name>ENOTFOUNDOPERATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21048</na:Code>
                            <na:Name>EROLEISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleCapabilityRemoveRequest"/>
            <output message="na:RbacRoleCapabilityRemoveResponse"/>
        </operation>
        <operation name="RbacRoleDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Delete an existing role From the RBAC system</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21048</na:Code>
                            <na:Name>EROLEISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleDeleteRequest"/>
            <output message="na:RbacRoleDeleteResponse"/>
        </operation>
        <operation name="RbacRoleDisinherit">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Disinherit one or more roles. The Effect is that the affected role will no longer have the Capabilities gained From the disinherited role(s). If DisinheritAll is not specified or is FALSE, then DisinheritedRoleNameOrId must be specified.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21045</na:Code>
                            <na:Name>ENOTINHERITEDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21048</na:Code>
                            <na:Name>EROLEISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleDisinheritRequest"/>
            <output message="na:RbacRoleDisinheritResponse"/>
        </operation>
        <operation name="RbacRoleInfoList">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the operations, Capabilities and inherited roles that one or more roles have.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleInfoListRequest"/>
            <output message="na:RbacRoleInfoListResponse"/>
        </operation>
        <operation name="RbacRoleInherit">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Inherit From a role. The Effect is that the affected role will gain the Capabilities From the inherited role.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22292</na:Code>
                            <na:Name>EDUPLICATEROLEREF</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21048</na:Code>
                            <na:Name>EROLEISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleInheritRequest"/>
            <output message="na:RbacRoleInheritResponse"/>
        </operation>
        <operation name="RbacRoleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify an existing role Name and/or its Description.</na:Description>
                    <na:Category>Rbac</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21029</na:Code>
                            <na:Name>EINVALIDDESCRIPTION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13115</na:Code>
                            <na:Name>EINVALIDINPUTERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21027</na:Code>
                            <na:Name>EINVALIDROLENAME</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21030</na:Code>
                            <na:Name>ENOTFOUNDROLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21048</na:Code>
                            <na:Name>EROLEISPERMANENT</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:RbacRoleModifyRequest"/>
            <output message="na:RbacRoleModifyResponse"/>
        </operation>
        <operation name="ReportGraphListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a View list iteration and clean up any saved info.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportGraphListInfoIterEndRequest"/>
            <output message="na:ReportGraphListInfoIterEndResponse"/>
        </operation>
        <operation name="ReportGraphListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To ReportGraphListInfoIterStart</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportGraphListInfoIterNextRequest"/>
            <output message="na:ReportGraphListInfoIterNextResponse"/>
        </operation>
        <operation name="ReportGraphListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of Graphs for a particular report.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23318</na:Code>
                            <na:Name>EREPORTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23326</na:Code>
                            <na:Name>EREPORTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportGraphListInfoIterStartRequest"/>
            <output message="na:ReportGraphListInfoIterStartResponse"/>
        </operation>
        <operation name="ReportListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Terminate a View list iteration and clean up any saved info.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportListInfoIterEndRequest"/>
            <output message="na:ReportListInfoIterEndResponse"/>
        </operation>
        <operation name="ReportListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns items From a previous call To ReportListInfoIterStart</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportListInfoIterNextRequest"/>
            <output message="na:ReportListInfoIterNextResponse"/>
        </operation>
        <operation name="ReportListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Initiates a Query for a list of Reports that can be scheduled.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23318</na:Code>
                            <na:Name>EREPORTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23326</na:Code>
                            <na:Name>EREPORTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportListInfoIterStartRequest"/>
            <output message="na:ReportListInfoIterStartResponse"/>
        </operation>
        <operation name="ReportOutputDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes a report output.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23334</na:Code>
                            <na:Name>EREPORTNOTLICENSED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23327</na:Code>
                            <na:Name>EREPORTOUTPUTDELETEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23320</na:Code>
                            <na:Name>EREPORTOUTPUTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportOutputDeleteRequest"/>
            <output message="na:ReportOutputDeleteResponse"/>
        </operation>
        <operation name="ReportOutputListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportOutputListInfoIterEndRequest"/>
            <output message="na:ReportOutputListInfoIterEndResponse"/>
        </operation>
        <operation name="ReportOutputListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportOutputListInfoIterNextRequest"/>
            <output message="na:ReportOutputListInfoIterNextResponse"/>
        </operation>
        <operation name="ReportOutputListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23318</na:Code>
                            <na:Name>EREPORTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23320</na:Code>
                            <na:Name>EREPORTOUTPUTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportOutputListInfoIterStartRequest"/>
            <output message="na:ReportOutputListInfoIterStartResponse"/>
        </operation>
        <operation name="ReportOutputRead">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Reads report output data From a file. API will fail if Length exceeds 1 MB.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23333</na:Code>
                            <na:Name>EREPORTOUTPUTFILENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23328</na:Code>
                            <na:Name>EREPORTOUTPUTFILEREADERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23320</na:Code>
                            <na:Name>EREPORTOUTPUTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportOutputReadRequest"/>
            <output message="na:ReportOutputReadResponse"/>
        </operation>
        <operation name="ReportScheduleAdd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add a new report schedule.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23318</na:Code>
                            <na:Name>EREPORTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23334</na:Code>
                            <na:Name>EREPORTNOTLICENSED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23319</na:Code>
                            <na:Name>EREPORTSCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleAddRequest"/>
            <output message="na:ReportScheduleAddResponse"/>
        </operation>
        <operation name="ReportScheduleDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes a report schedule.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23329</na:Code>
                            <na:Name>EREPORTSCHEDULEDELETEERROR</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleDeleteRequest"/>
            <output message="na:ReportScheduleDeleteResponse"/>
        </operation>
        <operation name="ReportScheduleDisable">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Disable a report schedule.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleDisableRequest"/>
            <output message="na:ReportScheduleDisableResponse"/>
        </operation>
        <operation name="ReportScheduleEnable">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Enable a report schedule.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23334</na:Code>
                            <na:Name>EREPORTNOTLICENSED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleEnableRequest"/>
            <output message="na:ReportScheduleEnableResponse"/>
        </operation>
        <operation name="ReportScheduleListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleListInfoIterEndRequest"/>
            <output message="na:ReportScheduleListInfoIterEndResponse"/>
        </operation>
        <operation name="ReportScheduleListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleListInfoIterNextRequest"/>
            <output message="na:ReportScheduleListInfoIterNextResponse"/>
        </operation>
        <operation name="ReportScheduleListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23318</na:Code>
                            <na:Name>EREPORTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleListInfoIterStartRequest"/>
            <output message="na:ReportScheduleListInfoIterStartResponse"/>
        </operation>
        <operation name="ReportScheduleModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a report schedule.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23318</na:Code>
                            <na:Name>EREPORTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23334</na:Code>
                            <na:Name>EREPORTNOTLICENSED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23319</na:Code>
                            <na:Name>EREPORTSCHEDULEDUPLICATE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleModifyRequest"/>
            <output message="na:ReportScheduleModifyResponse"/>
        </operation>
        <operation name="ReportScheduleRun">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Runs a report schedule at that instant of time.</na:Description>
                    <na:Category>Report</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23334</na:Code>
                            <na:Name>EREPORTNOTLICENSED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23335</na:Code>
                            <na:Name>EREPORTNOTSCHEDULABLE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ReportScheduleRunRequest"/>
            <output message="na:ReportScheduleRunResponse"/>
        </operation>
        <operation name="ResourcepoolAddMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Add member -- storage system or Aggregate -- To an existing Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Resource pool or DFM.Database.Read Privilege on the object being added. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EOBJECTNOTFOUND - When the specified object of valid Type To add is not found or object does not exist at all. &lt;li&gt; EINVALIDMEMBERTYPE - When an Aggregate To add contains traditional Volume or it is Aggregate Snapshot. &lt;li&gt; EOBJECTINANOTHERDYNAMICREFERENCE - When the specified object or its relative Members, are already in another Resource pool/storage set. Try again with move flag To move resources across Resource pools. When used by storage set, you need To manually remove Resource From storage set and add it To Resource pool. &lt;li&gt; EOBJECTINDIRECTMEMOFANOTHERDYNAMICREF - Object being added To Resource pool is in another Resource pool and it's a indirect member of the Resource pool. &lt;li&gt; EOBJECTEXISTSINRESOURCEPOOL - When the specified object already exists in the Resource pool. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous To denote whether its storage system or Aggregate. Try again with fully qualified Name or object Id. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22262</na:Code>
                            <na:Name>EINVALIDMEMBERTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22208</na:Code>
                            <na:Name>EOBJECTEXISTSINRESOURCEPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22206</na:Code>
                            <na:Name>EOBJECTINANOTHERDYNAMICREFERENCE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23419</na:Code>
                            <na:Name>EOBJECTINDIRECTMEMOFANOTHERDYNAMICREF</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolAddMemberRequest"/>
            <output message="na:ResourcepoolAddMemberResponse"/>
        </operation>
        <operation name="ResourcepoolCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new, empty Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EINVALIDINPUT - When invalid Name specified. A valid Name is non empty and constitutes at least one non-numeric character. &lt;li&gt; ERESOURCEPOOLEXISTS - When the specified Resource pool already exists. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22205</na:Code>
                            <na:Name>ERESOURCEPOOLEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolCreateRequest"/>
            <output message="na:ResourcepoolCreateResponse"/>
        </operation>
        <operation name="ResourcepoolDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a Resource pool. If the Resource pool is in use by a storage set or Resource pool is not empty, the Resource pool may only be destroyed by specifying the Force flag. If the Resource pool is in use by the storage Service, the Resource pool can be destroyed only after removing it From the storage Service. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Delete Capability on the specified Resource pool. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; ERESOURCEPOOLNOTEMPTY - When the specified Resource pool is not empty. Try again with Force flag. &lt;li&gt; ERESOURCEPOOLINUSE - When the specified Resource pool is in use by a storage set. Try again with Force flag. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22210</na:Code>
                            <na:Name>ERESOURCEPOOLINUSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22209</na:Code>
                            <na:Name>ERESOURCEPOOLNOTEMPTY</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolDestroyRequest"/>
            <output message="na:ResourcepoolDestroyResponse"/>
        </operation>
        <operation name="ResourcepoolGetDefaults">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the default Values of Attributes defined by this ZAPI set.</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolGetDefaultsRequest"/>
            <output message="na:ResourcepoolGetDefaultsResponse"/>
        </operation>
        <operation name="ResourcepoolListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of Resource pools.</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolListInfoIterEndRequest"/>
            <output message="na:ResourcepoolListInfoIterEndResponse"/>
        </operation>
        <operation name="ResourcepoolListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next Records in the iteration started by ResourcepoolListInfoIterStart.</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolListInfoIterNextRequest"/>
            <output message="na:ResourcepoolListInfoIterNextResponse"/>
        </operation>
        <operation name="ResourcepoolListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Resource pools. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Read Capability on the specified Resource pools. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool is not found in the database. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolListInfoIterStartRequest"/>
            <output message="na:ResourcepoolListInfoIterStartResponse"/>
        </operation>
        <operation name="ResourcepoolMemberListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of Resource pools.</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolMemberListInfoIterEndRequest"/>
            <output message="na:ResourcepoolMemberListInfoIterEndResponse"/>
        </operation>
        <operation name="ResourcepoolMemberListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next Records in the iteration started by ResourcepoolMemberListInfoIterStart.</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolMemberListInfoIterNextRequest"/>
            <output message="na:ResourcepoolMemberListInfoIterNextResponse"/>
        </operation>
        <operation name="ResourcepoolMemberListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Members of specified Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Read Capability on the specified Resource pools. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolMemberListInfoIterStartRequest"/>
            <output message="na:ResourcepoolMemberListInfoIterStartResponse"/>
        </operation>
        <operation name="ResourcepoolModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a Resource pool's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Resource pool. &lt;li&gt; EINVALIDINPUT - When invalid input specified. A ResourcepoolName should be non empty and constitutes at least one non-numeric character. &lt;br&gt; The ResourcepoolContact Value should be email Address which does not have any white space. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; ERESOURCEPOOLEXISTS - Already a Resource pool exists with the new Name. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>14517</na:Code>
                            <na:Name>EINVALIDTIMEZONE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22205</na:Code>
                            <na:Name>ERESOURCEPOOLEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolModifyRequest"/>
            <output message="na:ResourcepoolModifyResponse"/>
        </operation>
        <operation name="ResourcepoolModifyMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify the Properties of Members of Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Resource pool or DFM.Database.Write Privilege on the object being modified. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EOBJECTNOTFOUND - When the specified object of valid Type To add is not found or object does not exist at all. &lt;li&gt; EINVALIDMEMBERTYPE - When an object is not a mamber of Resourcepool. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous To denote whether its Filer or Aggregate. Try again with fully qualified Name or object Id. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22207</na:Code>
                            <na:Name>EOBJECTNOTINRESOURCEPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolModifyMemberRequest"/>
            <output message="na:ResourcepoolModifyMemberResponse"/>
        </operation>
        <operation name="ResourcepoolRemoveMember">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Remove member -- storage system or Aggregate -- From a Resource pool. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Delete Capability on the specified Resource pool or DFM.Database.Read Privilege on the object being removed. &lt;li&gt; ERESOURCEPOOLDOESNOTEXIST - When the specified Resource pool does not exist. &lt;li&gt; EOBJECTNOTFOUND - When the specified object To remove not found. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous To denote whether its storage system or Aggregate. Try again with fully qualified Name or object Id. &lt;li&gt; EOBJECTNOTINRESOURCEPOOL - When the specified object does not exist in the Resource pool. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22207</na:Code>
                            <na:Name>EOBJECTNOTINRESOURCEPOOL</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolRemoveMemberRequest"/>
            <output message="na:ResourcepoolRemoveMemberResponse"/>
        </operation>
        <operation name="ResourcepoolUpdateFreeSpaceStatus">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Check the free space in the Resource pool against the nearly-full and full Thresholds and generate appropriate Events for the Resource pool.</na:Description>
                    <na:Category>Resourcepool</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22204</na:Code>
                            <na:Name>ERESOURCEPOOLDOESNOTEXIST</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:ResourcepoolUpdateFreeSpaceStatusRequest"/>
            <output message="na:ResourcepoolUpdateFreeSpaceStatusResponse"/>
        </operation>
        <operation name="SnapshotGetReclaimableInfo">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns the amount of space that would be freed when a set of Snapshot copies are deleted From a specified Volume. This API gets information dynamically From the Filer and is a blocking call.</na:Description>
                    <na:Category>Snapshot</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13021</na:Code>
                            <na:Name>ESNAPSHOTDOESNOTEXIST</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13022</na:Code>
                            <na:Name>ESNAPSHOTTOOMANY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13158</na:Code>
                            <na:Name>EVOLUMEBUSY</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13041</na:Code>
                            <na:Name>EVOLUMEMOUNTING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13042</na:Code>
                            <na:Name>EVOLUMEOFFLINE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:SnapshotGetReclaimableInfoRequest"/>
            <output message="na:SnapshotGetReclaimableInfoResponse"/>
        </operation>
        <operation name="SnapshotListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of Snapshot copies.</na:Description>
                    <na:Category>Snapshot</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:SnapshotListInfoIterEndRequest"/>
            <output message="na:SnapshotListInfoIterEndResponse"/>
        </operation>
        <operation name="SnapshotListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieve the next Records in the iteration started by SnapshotListInfoIterStart.</na:Description>
                    <na:Category>Snapshot</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:SnapshotListInfoIterNextRequest"/>
            <output message="na:SnapshotListInfoIterNextResponse"/>
        </operation>
        <operation name="SnapshotListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Returns information on a list of Snapshot copies.</na:Description>
                    <na:Category>Snapshot</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:SnapshotListInfoIterStartRequest"/>
            <output message="na:SnapshotListInfoIterStartResponse"/>
        </operation>
        <operation name="StorageServiceCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new storage Service.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23515</na:Code>
                            <na:Name>ESERVICEEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceCreateRequest"/>
            <output message="na:StorageServiceCreateResponse"/>
        </operation>
        <operation name="StorageServiceDatasetListIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list of Datasets associated with a storage Service.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceDatasetListIterEndRequest"/>
            <output message="na:StorageServiceDatasetListIterEndResponse"/>
        </operation>
        <operation name="StorageServiceDatasetListIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by storage-service-dataset-list-info-iter-start.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceDatasetListIterNextRequest"/>
            <output message="na:StorageServiceDatasetListIterNextResponse"/>
        </operation>
        <operation name="StorageServiceDatasetListIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Lists the association of Datasets with storage services. If no service/dataset Name or Id is provided then all Datasets with no storage Service are listed.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13002</na:Code>
                            <na:Name>EAPIAUTHENTICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceDatasetListIterStartRequest"/>
            <output message="na:StorageServiceDatasetListIterStartResponse"/>
        </operation>
        <operation name="StorageServiceDatasetModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Attach or detach a storage Service To a Dataset.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22222</na:Code>
                            <na:Name>EDPPOLICYNODENOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23513</na:Code>
                            <na:Name>EOPERATIONNOTSUPPORTED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceDatasetModifyRequest"/>
            <output message="na:StorageServiceDatasetModifyResponse"/>
        </operation>
        <operation name="StorageServiceDatasetProvision">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a Dataset with the specified storage Service</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13008</na:Code>
                            <na:Name>EAPILICENSE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22212</na:Code>
                            <na:Name>EDATASETEXISTS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22270</na:Code>
                            <na:Name>EINVALIDMEMBER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>14517</na:Code>
                            <na:Name>EINVALIDTIMEZONE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22269</na:Code>
                            <na:Name>EMEMBERALREADYINGROUP</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23518</na:Code>
                            <na:Name>EPROVISIONFAILED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23520</na:Code>
                            <na:Name>EVFILERINTERFACENOTSET</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceDatasetProvisionRequest"/>
            <output message="na:StorageServiceDatasetProvisionResponse"/>
        </operation>
        <operation name="StorageServiceDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a storage Service. In order To Destroy storage Service containing Datasets, Force Option must be supplied.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13002</na:Code>
                            <na:Name>EAPIAUTHENTICATION</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23516</na:Code>
                            <na:Name>ESTORAGESERVICEINUSE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceDestroyRequest"/>
            <output message="na:StorageServiceDestroyResponse"/>
        </operation>
        <operation name="StorageServiceListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list storage services.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceListInfoIterEndRequest"/>
            <output message="na:StorageServiceListInfoIterEndResponse"/>
        </operation>
        <operation name="StorageServiceListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by StorageServiceListInfoIterStart.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceListInfoIterNextRequest"/>
            <output message="na:StorageServiceListInfoIterNextResponse"/>
        </operation>
        <operation name="StorageServiceListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list storage services.</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceListInfoIterStartRequest"/>
            <output message="na:StorageServiceListInfoIterStartResponse"/>
        </operation>
        <operation name="StorageServiceModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify Attributes for a storage Service</na:Description>
                    <na:Category>StorageService</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23416</na:Code>
                            <na:Name>EDATASETFAILINGOVER</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23510</na:Code>
                            <na:Name>EDATASETMIGRATING</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13114</na:Code>
                            <na:Name>EINTERNALERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23515</na:Code>
                            <na:Name>ESERVICEEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:StorageServiceModifyRequest"/>
            <output message="na:StorageServiceModifyResponse"/>
        </operation>
        <operation name="TimezoneGetDefaults">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Retrieves the default time zone settings, including the time zone in which the server runs and the time zone To use for Objects that don't specify their own time zone.</na:Description>
                    <na:Category>Timezone</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:TimezoneGetDefaultsRequest"/>
            <output message="na:TimezoneGetDefaultsResponse"/>
        </operation>
        <operation name="TimezoneListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list time zones.</na:Description>
                    <na:Category>Timezone</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:TimezoneListInfoIterEndRequest"/>
            <output message="na:TimezoneListInfoIterEndResponse"/>
        </operation>
        <operation name="TimezoneListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get the next few Records in the iteration started by TimezoneListInfoIterStart.</na:Description>
                    <na:Category>Timezone</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:TimezoneListInfoIterNextRequest"/>
            <output message="na:TimezoneListInfoIterNextResponse"/>
        </operation>
        <operation name="TimezoneListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list time zones From the internal database of time zone information.</na:Description>
                    <na:Category>Timezone</na:Category>
                    <na:Status>supported</na:Status>
                </OperationDocumentation>
            </documentation>
            <input message="na:TimezoneListInfoIterStartRequest"/>
            <output message="na:TimezoneListInfoIterStartResponse"/>
        </operation>
        <operation name="TimezoneValidate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Determines if a time zone specification is valid. The specification may be the Name of Timezone returned From TimezoneListInfoIterNext(), or can be a POSIX-style time zone specification.</na:Description>
                    <na:Category>Timezone</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>14517</na:Code>
                            <na:Name>EINVALIDTIMEZONE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:TimezoneValidateRequest"/>
            <output message="na:TimezoneValidateResponse"/>
        </operation>
        <operation name="UserFavoriteReportDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes favorite Reports of a user or all users.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23315</na:Code>
                            <na:Name>ENOFAVORITES</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserFavoriteReportDeleteRequest"/>
            <output message="na:UserFavoriteReportDeleteResponse"/>
        </operation>
        <operation name="UserFavoriteReportListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The UserFavoriteReportListInfoIter* set of APIs are used To retrieve the list of user favorite counts. UserFavoriteReportListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the UserFavoriteReportListInfoIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserFavoriteReportListInfoIterEndRequest"/>
            <output message="na:UserFavoriteReportListInfoIterEndResponse"/>
        </operation>
        <operation name="UserFavoriteReportListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check UserFavoriteReportListInfoIterStart. The UserFavoriteReportListInfoIterNext API is used To iterate over the Members of user favorite report counts stored in the temporary store created by the UserFavoriteReportListInfoIterStart API.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserFavoriteReportListInfoIterNextRequest"/>
            <output message="na:UserFavoriteReportListInfoIterNextResponse"/>
        </operation>
        <operation name="UserFavoriteReportListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The UserFavoriteReportListInfoIter* set of APIs are used To retrieve the number of favorite Reports of specified user or all users. It loads the list of user favorite report counts into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. If UserFavoriteReportListInfoIterStart is invoked twice, then two distinct temporary stores are created.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23315</na:Code>
                            <na:Name>ENOFAVORITES</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserFavoriteReportListInfoIterStartRequest"/>
            <output message="na:UserFavoriteReportListInfoIterStartResponse"/>
        </operation>
        <operation name="UserRecentReportDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes recently viewed Reports of a user or all users.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23316</na:Code>
                            <na:Name>ENORECENTVIEWED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserRecentReportDeleteRequest"/>
            <output message="na:UserRecentReportDeleteResponse"/>
        </operation>
        <operation name="UserRecentReportListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The UserRecentReportListInfoIter* set of APIs are used To retrieve the list of user's recently viewed report counts. UserRecentReportListInfoIterEnd is used To tell the DFM station that the temporary store used by DFM To support the UserRecentReportListInfoIterNext API for the particular Tag is no longer necessary.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserRecentReportListInfoIterEndRequest"/>
            <output message="na:UserRecentReportListInfoIterEndResponse"/>
        </operation>
        <operation name="UserRecentReportListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>For more documentation please check UserRecentReportListInfoIterStart. The UserRecentReportListInfoIterNext API is used To iterate over the Members of user's recently viewed report counts stored in the temporary store created by the UserRecentReportListInfoIterStart API.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserRecentReportListInfoIterNextRequest"/>
            <output message="na:UserRecentReportListInfoIterNextResponse"/>
        </operation>
        <operation name="UserRecentReportListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>The UserRecentReportListInfoIter* set of APIs are used To retrieve the number of recently viewed report Count of specified user or all users. It loads the list of user's recently viewed report counts into a temporary store. The API returns a Tag that identifies that temporary store so that subsequent APIs can be used To iterate over the list in the temporary store. If UserRecentReportListInfoIterStart is invoked twice, then two distinct temporary stores are created.</na:Description>
                    <na:Category>UserReportProfile</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23316</na:Code>
                            <na:Name>ENORECENTVIEWED</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:UserRecentReportListInfoIterStartRequest"/>
            <output message="na:UserRecentReportListInfoIterStartResponse"/>
        </operation>
        <operation name="VfilerCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Create a new vFiler on a storage system. A vFiler can be created by either: &lt;UL&gt; &lt;LI&gt; Specifying the Filer on which To create it. &lt;LI&gt; Speciying a Resource pool. In this case, a Filer is selected From the Resource pool based on required Licenses and in-built Resource selection algorithm To evenly balance space and load in the Resource pool and a vFiler will be created on the selected Filer. &lt;/UL&gt; Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To create a vFiler. &lt;li&gt; EOBJECTNOTFOUND - When the specified ResourceNameOrId Id not found. &lt;li&gt; EFILERNOTFOUND - No storage system could be found on which a vFiler could be created. &lt;li&gt; EINVALIDINPUT - Invalid input provided for certain fields. &lt;li&gt; EINVALIDMEMBERTYPE - when the Filer is in c-mode. &lt;li&gt; EMULTISTORENOTLICENSED - When ResourceNameOrId corresponds To a Filer that does not have multistore licensed. &lt;/ul&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23343</na:Code>
                            <na:Name>EFILERNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22262</na:Code>
                            <na:Name>EINVALIDMEMBERTYPE</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23344</na:Code>
                            <na:Name>EMULTISTORENOTLICENSED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerCreateRequest"/>
            <output message="na:VfilerCreateResponse"/>
        </operation>
        <operation name="VfilerDestroy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Destroy a Vfiler. This API stops and then destroys the vFiler on the hosting Filer and marks the vFiler as deleted in DFM. Storage resources owned by the vFiler are not destroyed. They will be owned by the hosting Filer after the vFiler is destroyed. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To Destroy the vFiler. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler is not found. &lt;/UL&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerDestroyRequest"/>
            <output message="na:VfilerDestroyResponse"/>
        </operation>
        <operation name="VfilerSetup">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Configure and setup a vFiler based on a specified vFiler template. Depending on the input a CIFS setup will also be done on the vFiler. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To setup the vFiler. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler is not found. &lt;li&gt; EINVALIDINPUT - Invalid input provided. &lt;/ul&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerSetupRequest"/>
            <output message="na:VfilerSetupResponse"/>
        </operation>
        <operation name="VfilerTemplateCopy">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a new vFiler template by copying all settings From an existing vFiler template. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have privileges To create the Vfiler template. &lt;LI&gt; EVFILERTEMPLATEEXISTS - A vFiler template already exists with this Name. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler template does not exist. &lt;/UL&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23341</na:Code>
                            <na:Name>EVFILERTEMPLATEEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateCopyRequest"/>
            <output message="na:VfilerTemplateCopyResponse"/>
        </operation>
        <operation name="VfilerTemplateCreate">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Creates a vFiler template. A vFiler template contains configuration information that is used during vFiler setup. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have privileges To create the vFiler template. &lt;LI&gt; EVFILERTEMPLATEEXISTS - A vFiler template already exists with this Name. &lt;LI&gt; EINVALIDINPUT - Input validation failed. &lt;/UL&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23341</na:Code>
                            <na:Name>EVFILERTEMPLATEEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateCreateRequest"/>
            <output message="na:VfilerTemplateCreateResponse"/>
        </operation>
        <operation name="VfilerTemplateDelete">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Deletes the vFiler template. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have Capabilities To delete the vFiler template. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler template does not exist. &lt;/UL&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23519</na:Code>
                            <na:Name>EVFILERTEMPLATEINUSE</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateDeleteRequest"/>
            <output message="na:VfilerTemplateDeleteResponse"/>
        </operation>
        <operation name="VfilerTemplateListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration of vFiler templates.</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateListInfoIterEndRequest"/>
            <output message="na:VfilerTemplateListInfoIterEndResponse"/>
        </operation>
        <operation name="VfilerTemplateListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next Records in the iteration started by VfilerTemplateListInfoIterStart.</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateListInfoIterNextRequest"/>
            <output message="na:VfilerTemplateListInfoIterNextResponse"/>
        </operation>
        <operation name="VfilerTemplateListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Lists vFiler templates. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have required Capabilities To list vFiler templates. &lt;li&gt; EOBJECTAMBIGUOUS - When the specified object Name is ambiguous. &lt;li&gt; EOBJECTNOTFOUND - When the specified vFiler template does not exist. &lt;/UL&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateListInfoIterStartRequest"/>
            <output message="na:VfilerTemplateListInfoIterStartResponse"/>
        </operation>
        <operation name="VfilerTemplateModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modifies the settings in a vFiler template. Error conditions: &lt;UL&gt; &lt;LI&gt; EDATABASEERROR - A database Error occurred while processing the Request. &lt;LI&gt; EACCESSDENIED - User does not have capabilties To create the vFiler template. &lt;LI&gt; EVFILERTEMPLATEEXISTS - A vFiler template already exists with this Name. &lt;LI&gt; EINVALIDINPUT - Input validation failed. &lt;/UL&gt;</na:Description>
                    <na:Category>Vfiler</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>23341</na:Code>
                            <na:Name>EVFILERTEMPLATEEXISTS</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VfilerTemplateModifyRequest"/>
            <output message="na:VfilerTemplateModifyResponse"/>
        </operation>
        <operation name="VolumeListInfoIterEnd">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Ends iteration To list Volumes.</na:Description>
                    <na:Category>Volume</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VolumeListInfoIterEndRequest"/>
            <output message="na:VolumeListInfoIterEndResponse"/>
        </operation>
        <operation name="VolumeListInfoIterNext">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Get next few Records in the iteration started by VolumeListInfoIterStart.</na:Description>
                    <na:Category>Volume</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>21002</na:Code>
                            <na:Name>EINVALIDTAG</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VolumeListInfoIterNextRequest"/>
            <output message="na:VolumeListInfoIterNextResponse"/>
        </operation>
        <operation name="VolumeListInfoIterStart">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Starts iteration To list Volumes.</na:Description>
                    <na:Category>Volume</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>13001</na:Code>
                            <na:Name>EAPIERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22211</na:Code>
                            <na:Name>EOBJECTAMBIGUOUS</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VolumeListInfoIterStartRequest"/>
            <output message="na:VolumeListInfoIterStartResponse"/>
        </operation>
        <operation name="VolumeModify">
            <documentation>
                <OperationDocumentation xsi:type="na:OperationDocumentation">
                    <na:Description>Modify a Volume's information. If modifying of one property fails, nothing will be changed. &lt;br&gt; Error Conditions: &lt;ul&gt; &lt;li&gt; EACCESSDENIED - When the user does not have DFM.Database.Write Capability on the specified Volume. &lt;li&gt; EINVALIDINPUT - When invalid input specified. &lt;li&gt; EOBJECTNOTFOUND - When the VolumeNameOrId does not correspond To a Volume. &lt;li&gt; EDATABASEERROR - On database Error. &lt;/ul&gt;</na:Description>
                    <na:Category>Volume</na:Category>
                    <na:Status>supported</na:Status>
                    <na:OperationErrors>
                        <na:OperationError>
                            <na:Code>22256</na:Code>
                            <na:Name>EACCESSDENIED</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22259</na:Code>
                            <na:Name>EDATABASEERROR</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>21012</na:Code>
                            <na:Name>EINVALIDINPUT</na:Name>
                        </na:OperationError>
                        <na:OperationError>
                            <na:Code>22255</na:Code>
                            <na:Name>EOBJECTNOTFOUND</na:Name>
                        </na:OperationError>
                    </na:OperationErrors>
                </OperationDocumentation>
            </documentation>
            <input message="na:VolumeModifyRequest"/>
            <output message="na:VolumeModifyResponse"/>
        </operation>
    </portType>
    <binding name="DfmBinding" type="na:DfmInterface">
        <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
        <operation name="AggregateListInfoIterEnd">
            <soap:operation soapAction="urn:AggregateListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateListInfoIterNext">
            <soap:operation soapAction="urn:AggregateListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateListInfoIterStart">
            <soap:operation soapAction="urn:AggregateListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateModify">
            <soap:operation soapAction="urn:AggregateModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateSpaceManagementAddOperation">
            <soap:operation soapAction="urn:AggregateSpaceManagementAddOperation"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateSpaceManagementBegin">
            <soap:operation soapAction="urn:AggregateSpaceManagementBegin"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateSpaceManagementCommit">
            <soap:operation soapAction="urn:AggregateSpaceManagementCommit"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateSpaceManagementRemoveOperation">
            <soap:operation soapAction="urn:AggregateSpaceManagementRemoveOperation"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AggregateSpaceManagementRollback">
            <soap:operation soapAction="urn:AggregateSpaceManagementRollback"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmCreate">
            <soap:operation soapAction="urn:AlarmCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmDestroy">
            <soap:operation soapAction="urn:AlarmDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmGetDefaults">
            <soap:operation soapAction="urn:AlarmGetDefaults"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmListInfoIterEnd">
            <soap:operation soapAction="urn:AlarmListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmListInfoIterNext">
            <soap:operation soapAction="urn:AlarmListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmListInfoIterStart">
            <soap:operation soapAction="urn:AlarmListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmModify">
            <soap:operation soapAction="urn:AlarmModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AlarmTest">
            <soap:operation soapAction="urn:AlarmTest"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ApiProxy">
            <soap:operation soapAction="urn:ApiProxy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="AuditLogAddEntry">
            <soap:operation soapAction="urn:AuditLogAddEntry"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CifsDomainListInfoIterEnd">
            <soap:operation soapAction="urn:CifsDomainListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CifsDomainListInfoIterNext">
            <soap:operation soapAction="urn:CifsDomainListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CifsDomainListInfoIterStart">
            <soap:operation soapAction="urn:CifsDomainListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ClientRegistryDestroy">
            <soap:operation soapAction="urn:ClientRegistryDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ClientRegistryGet">
            <soap:operation soapAction="urn:ClientRegistryGet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ClientRegistrySet">
            <soap:operation soapAction="urn:ClientRegistrySet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldCreate">
            <soap:operation soapAction="urn:CommentFieldCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldDestroy">
            <soap:operation soapAction="urn:CommentFieldDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldListInfoIterEnd">
            <soap:operation soapAction="urn:CommentFieldListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldListInfoIterNext">
            <soap:operation soapAction="urn:CommentFieldListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldListInfoIterStart">
            <soap:operation soapAction="urn:CommentFieldListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldModify">
            <soap:operation soapAction="urn:CommentFieldModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldValuesListInfoIterEnd">
            <soap:operation soapAction="urn:CommentFieldValuesListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldValuesListInfoIterNext">
            <soap:operation soapAction="urn:CommentFieldValuesListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentFieldValuesListInfoIterStart">
            <soap:operation soapAction="urn:CommentFieldValuesListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="CommentSetObjectValue">
            <soap:operation soapAction="urn:CommentSetObjectValue"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetAddMember">
            <soap:operation soapAction="urn:DatasetAddMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetAddMemberByDynamicReference">
            <soap:operation soapAction="urn:DatasetAddMemberByDynamicReference"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetAddResourcepool">
            <soap:operation soapAction="urn:DatasetAddResourcepool"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetBeginFailover">
            <soap:operation soapAction="urn:DatasetBeginFailover"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetBeginFailoverScriptTest">
            <soap:operation soapAction="urn:DatasetBeginFailoverScriptTest"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetChangeDrState">
            <soap:operation soapAction="urn:DatasetChangeDrState"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetConformBegin">
            <soap:operation soapAction="urn:DatasetConformBegin"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetCreate">
            <soap:operation soapAction="urn:DatasetCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetDestroy">
            <soap:operation soapAction="urn:DatasetDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetDynamicReferenceListInfoIterEnd">
            <soap:operation soapAction="urn:DatasetDynamicReferenceListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetDynamicReferenceListInfoIterNext">
            <soap:operation soapAction="urn:DatasetDynamicReferenceListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetDynamicReferenceListInfoIterStart">
            <soap:operation soapAction="urn:DatasetDynamicReferenceListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetEditBegin">
            <soap:operation soapAction="urn:DatasetEditBegin"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetEditCommit">
            <soap:operation soapAction="urn:DatasetEditCommit"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetEditRollback">
            <soap:operation soapAction="urn:DatasetEditRollback"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetListInfoIterEnd">
            <soap:operation soapAction="urn:DatasetListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetListInfoIterNext">
            <soap:operation soapAction="urn:DatasetListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetListInfoIterStart">
            <soap:operation soapAction="urn:DatasetListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberDedupeAbort">
            <soap:operation soapAction="urn:DatasetMemberDedupeAbort"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberDedupeStart">
            <soap:operation soapAction="urn:DatasetMemberDedupeStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberDeleteSnapshots">
            <soap:operation soapAction="urn:DatasetMemberDeleteSnapshots"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberListInfoIterEnd">
            <soap:operation soapAction="urn:DatasetMemberListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberListInfoIterNext">
            <soap:operation soapAction="urn:DatasetMemberListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberListInfoIterStart">
            <soap:operation soapAction="urn:DatasetMemberListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMemberUndedupeStart">
            <soap:operation soapAction="urn:DatasetMemberUndedupeStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMissingMemberListInfoIterEnd">
            <soap:operation soapAction="urn:DatasetMissingMemberListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMissingMemberListInfoIterNext">
            <soap:operation soapAction="urn:DatasetMissingMemberListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetMissingMemberListInfoIterStart">
            <soap:operation soapAction="urn:DatasetMissingMemberListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetModify">
            <soap:operation soapAction="urn:DatasetModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetModifyNode">
            <soap:operation soapAction="urn:DatasetModifyNode"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetProvisionMember">
            <soap:operation soapAction="urn:DatasetProvisionMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetRemoveMember">
            <soap:operation soapAction="urn:DatasetRemoveMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetRemoveMemberByDynamicReference">
            <soap:operation soapAction="urn:DatasetRemoveMemberByDynamicReference"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetRemoveResourcepool">
            <soap:operation soapAction="urn:DatasetRemoveResourcepool"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetReplacePrimaryMembers">
            <soap:operation soapAction="urn:DatasetReplacePrimaryMembers"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetResizeMember">
            <soap:operation soapAction="urn:DatasetResizeMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetSet">
            <soap:operation soapAction="urn:DatasetSet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetSetStorageset">
            <soap:operation soapAction="urn:DatasetSetStorageset"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetUpdateDrStatus">
            <soap:operation soapAction="urn:DatasetUpdateDrStatus"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DatasetUpdateProtectionStatus">
            <soap:operation soapAction="urn:DatasetUpdateProtectionStatus"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmAbout">
            <soap:operation soapAction="urn:DfmAbout"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmGetApiStatistics">
            <soap:operation soapAction="urn:DfmGetApiStatistics"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmGetResourcePropertyValues">
            <soap:operation soapAction="urn:DfmGetResourcePropertyValues"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmObjectRefresh">
            <soap:operation soapAction="urn:DfmObjectRefresh"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmObjectsGetStatus">
            <soap:operation soapAction="urn:DfmObjectsGetStatus"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmRelatedObjectsListInfo">
            <soap:operation soapAction="urn:DfmRelatedObjectsListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleContentGet">
            <soap:operation soapAction="urn:DfmScheduleContentGet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleCreate">
            <soap:operation soapAction="urn:DfmScheduleCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleDailyAdd">
            <soap:operation soapAction="urn:DfmScheduleDailyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleDailyDelete">
            <soap:operation soapAction="urn:DfmScheduleDailyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleDailyModify">
            <soap:operation soapAction="urn:DfmScheduleDailyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleDependency">
            <soap:operation soapAction="urn:DfmScheduleDependency"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleDestroy">
            <soap:operation soapAction="urn:DfmScheduleDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleHourlyAdd">
            <soap:operation soapAction="urn:DfmScheduleHourlyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleHourlyDelete">
            <soap:operation soapAction="urn:DfmScheduleHourlyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleHourlyModify">
            <soap:operation soapAction="urn:DfmScheduleHourlyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleList">
            <soap:operation soapAction="urn:DfmScheduleList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleListInfoIterEnd">
            <soap:operation soapAction="urn:DfmScheduleListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleListInfoIterNext">
            <soap:operation soapAction="urn:DfmScheduleListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleListInfoIterStart">
            <soap:operation soapAction="urn:DfmScheduleListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleModify">
            <soap:operation soapAction="urn:DfmScheduleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleMonthlyAdd">
            <soap:operation soapAction="urn:DfmScheduleMonthlyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleMonthlyDelete">
            <soap:operation soapAction="urn:DfmScheduleMonthlyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleMonthlyModify">
            <soap:operation soapAction="urn:DfmScheduleMonthlyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleMonthlySubscheduleSet">
            <soap:operation soapAction="urn:DfmScheduleMonthlySubscheduleSet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleMonthlySubscheduleUnset">
            <soap:operation soapAction="urn:DfmScheduleMonthlySubscheduleUnset"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleRename">
            <soap:operation soapAction="urn:DfmScheduleRename"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleWeeklyAdd">
            <soap:operation soapAction="urn:DfmScheduleWeeklyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleWeeklyDelete">
            <soap:operation soapAction="urn:DfmScheduleWeeklyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleWeeklyModify">
            <soap:operation soapAction="urn:DfmScheduleWeeklyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleWeeklySubscheduleAdd">
            <soap:operation soapAction="urn:DfmScheduleWeeklySubscheduleAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleWeeklySubscheduleDelete">
            <soap:operation soapAction="urn:DfmScheduleWeeklySubscheduleDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmScheduleWeeklySubscheduleModify">
            <soap:operation soapAction="urn:DfmScheduleWeeklySubscheduleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmServerListDiagnosticInfo">
            <soap:operation soapAction="urn:DfmServerListDiagnosticInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DfmUserPrivGet">
            <soap:operation soapAction="urn:DfmUserPrivGet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DiskListInfoIterEnd">
            <soap:operation soapAction="urn:DiskListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DiskListInfoIterNext">
            <soap:operation soapAction="urn:DiskListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DiskListInfoIterStart">
            <soap:operation soapAction="urn:DiskListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupContentListIterEnd">
            <soap:operation soapAction="urn:DpBackupContentListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupContentListIterNext">
            <soap:operation soapAction="urn:DpBackupContentListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupContentListIterStart">
            <soap:operation soapAction="urn:DpBackupContentListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupGetLocation">
            <soap:operation soapAction="urn:DpBackupGetLocation"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupListIterEnd">
            <soap:operation soapAction="urn:DpBackupListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupListIterNext">
            <soap:operation soapAction="urn:DpBackupListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupListIterStart">
            <soap:operation soapAction="urn:DpBackupListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupStart">
            <soap:operation soapAction="urn:DpBackupStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupVersionCreate">
            <soap:operation soapAction="urn:DpBackupVersionCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupVersionDelete">
            <soap:operation soapAction="urn:DpBackupVersionDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupVersionListIterEnd">
            <soap:operation soapAction="urn:DpBackupVersionListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupVersionListIterNext">
            <soap:operation soapAction="urn:DpBackupVersionListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupVersionListIterStart">
            <soap:operation soapAction="urn:DpBackupVersionListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpBackupVersionModify">
            <soap:operation soapAction="urn:DpBackupVersionModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpDashboardGetDrDatasetCounts">
            <soap:operation soapAction="urn:DpDashboardGetDrDatasetCounts"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpDashboardGetLaggedDatasets">
            <soap:operation soapAction="urn:DpDashboardGetLaggedDatasets"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpDashboardGetLaggedRelationships">
            <soap:operation soapAction="urn:DpDashboardGetLaggedRelationships"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpDashboardGetProtectedDataCounts">
            <soap:operation soapAction="urn:DpDashboardGetProtectedDataCounts"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpDashboardGetProtectedDataCounts2">
            <soap:operation soapAction="urn:DpDashboardGetProtectedDataCounts2"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpGetDatasetBackupJobsData">
            <soap:operation soapAction="urn:DpGetDatasetBackupJobsData"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobAbort">
            <soap:operation soapAction="urn:DpJobAbort"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobListIterEnd">
            <soap:operation soapAction="urn:DpJobListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobListIterNext">
            <soap:operation soapAction="urn:DpJobListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobListIterStart">
            <soap:operation soapAction="urn:DpJobListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobProgressEventListIterEnd">
            <soap:operation soapAction="urn:DpJobProgressEventListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobProgressEventListIterNext">
            <soap:operation soapAction="urn:DpJobProgressEventListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobProgressEventListIterStart">
            <soap:operation soapAction="urn:DpJobProgressEventListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobPurge">
            <soap:operation soapAction="urn:DpJobPurge"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobScheduleGetLastChanged">
            <soap:operation soapAction="urn:DpJobScheduleGetLastChanged"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobScheduleListIterEnd">
            <soap:operation soapAction="urn:DpJobScheduleListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobScheduleListIterNext">
            <soap:operation soapAction="urn:DpJobScheduleListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpJobScheduleListIterStart">
            <soap:operation soapAction="urn:DpJobScheduleListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvApplicationListInfoIterEnd">
            <soap:operation soapAction="urn:DpOssvApplicationListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvApplicationListInfoIterNext">
            <soap:operation soapAction="urn:DpOssvApplicationListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvApplicationListInfoIterStart">
            <soap:operation soapAction="urn:DpOssvApplicationListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvApplicationRestoreDestinationListInfoIterEnd">
            <soap:operation soapAction="urn:DpOssvApplicationRestoreDestinationListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvApplicationRestoreDestinationListInfoIterNext">
            <soap:operation soapAction="urn:DpOssvApplicationRestoreDestinationListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvApplicationRestoreDestinationListInfoIterStart">
            <soap:operation soapAction="urn:DpOssvApplicationRestoreDestinationListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryAdd">
            <soap:operation soapAction="urn:DpOssvDirectoryAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryBrowseIterEnd">
            <soap:operation soapAction="urn:DpOssvDirectoryBrowseIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryBrowseIterNext">
            <soap:operation soapAction="urn:DpOssvDirectoryBrowseIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryBrowseIterStart">
            <soap:operation soapAction="urn:DpOssvDirectoryBrowseIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryDiscoveredIterEnd">
            <soap:operation soapAction="urn:DpOssvDirectoryDiscoveredIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryDiscoveredIterNext">
            <soap:operation soapAction="urn:DpOssvDirectoryDiscoveredIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryDiscoveredIterStart">
            <soap:operation soapAction="urn:DpOssvDirectoryDiscoveredIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryModify">
            <soap:operation soapAction="urn:DpOssvDirectoryModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryRootsIterEnd">
            <soap:operation soapAction="urn:DpOssvDirectoryRootsIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryRootsIterNext">
            <soap:operation soapAction="urn:DpOssvDirectoryRootsIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpOssvDirectoryRootsIterStart">
            <soap:operation soapAction="urn:DpOssvDirectoryRootsIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyCopy">
            <soap:operation soapAction="urn:DpPolicyCopy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyDestroy">
            <soap:operation soapAction="urn:DpPolicyDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyEditBegin">
            <soap:operation soapAction="urn:DpPolicyEditBegin"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyEditCommit">
            <soap:operation soapAction="urn:DpPolicyEditCommit"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyEditRollback">
            <soap:operation soapAction="urn:DpPolicyEditRollback"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyGetDefaultPropertyValues">
            <soap:operation soapAction="urn:DpPolicyGetDefaultPropertyValues"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyListIterEnd">
            <soap:operation soapAction="urn:DpPolicyListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyListIterNext">
            <soap:operation soapAction="urn:DpPolicyListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyListIterStart">
            <soap:operation soapAction="urn:DpPolicyListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpPolicyModify">
            <soap:operation soapAction="urn:DpPolicyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpRelationshipListInfoIterEnd">
            <soap:operation soapAction="urn:DpRelationshipListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpRelationshipListInfoIterNext">
            <soap:operation soapAction="urn:DpRelationshipListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpRelationshipListInfoIterStart">
            <soap:operation soapAction="urn:DpRelationshipListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpRelationshipModify">
            <soap:operation soapAction="urn:DpRelationshipModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpRestoreToNewPath">
            <soap:operation soapAction="urn:DpRestoreToNewPath"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpRestoreToPrimary">
            <soap:operation soapAction="urn:DpRestoreToPrimary"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleContentGet">
            <soap:operation soapAction="urn:DpScheduleContentGet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleCreate">
            <soap:operation soapAction="urn:DpScheduleCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleDailyAdd">
            <soap:operation soapAction="urn:DpScheduleDailyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleDailyDelete">
            <soap:operation soapAction="urn:DpScheduleDailyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleDailyModify">
            <soap:operation soapAction="urn:DpScheduleDailyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleDependency">
            <soap:operation soapAction="urn:DpScheduleDependency"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleDestroy">
            <soap:operation soapAction="urn:DpScheduleDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleHourlyAdd">
            <soap:operation soapAction="urn:DpScheduleHourlyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleHourlyDelete">
            <soap:operation soapAction="urn:DpScheduleHourlyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleHourlyModify">
            <soap:operation soapAction="urn:DpScheduleHourlyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleList">
            <soap:operation soapAction="urn:DpScheduleList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleListInfoIterEnd">
            <soap:operation soapAction="urn:DpScheduleListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleListInfoIterNext">
            <soap:operation soapAction="urn:DpScheduleListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleListInfoIterStart">
            <soap:operation soapAction="urn:DpScheduleListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleModify">
            <soap:operation soapAction="urn:DpScheduleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleMonthlyAdd">
            <soap:operation soapAction="urn:DpScheduleMonthlyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleMonthlyDelete">
            <soap:operation soapAction="urn:DpScheduleMonthlyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleMonthlyModify">
            <soap:operation soapAction="urn:DpScheduleMonthlyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleMonthlySubscheduleSet">
            <soap:operation soapAction="urn:DpScheduleMonthlySubscheduleSet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleMonthlySubscheduleUnset">
            <soap:operation soapAction="urn:DpScheduleMonthlySubscheduleUnset"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleRename">
            <soap:operation soapAction="urn:DpScheduleRename"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleWeeklyAdd">
            <soap:operation soapAction="urn:DpScheduleWeeklyAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleWeeklyDelete">
            <soap:operation soapAction="urn:DpScheduleWeeklyDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleWeeklyModify">
            <soap:operation soapAction="urn:DpScheduleWeeklyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleWeeklySubscheduleAdd">
            <soap:operation soapAction="urn:DpScheduleWeeklySubscheduleAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleWeeklySubscheduleDelete">
            <soap:operation soapAction="urn:DpScheduleWeeklySubscheduleDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpScheduleWeeklySubscheduleModify">
            <soap:operation soapAction="urn:DpScheduleWeeklySubscheduleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleCreate">
            <soap:operation soapAction="urn:DpThrottleCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleDependency">
            <soap:operation soapAction="urn:DpThrottleDependency"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleDestroy">
            <soap:operation soapAction="urn:DpThrottleDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleItemAdd">
            <soap:operation soapAction="urn:DpThrottleItemAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleItemDelete">
            <soap:operation soapAction="urn:DpThrottleItemDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleListInfoIterEnd">
            <soap:operation soapAction="urn:DpThrottleListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleListInfoIterNext">
            <soap:operation soapAction="urn:DpThrottleListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleListInfoIterStart">
            <soap:operation soapAction="urn:DpThrottleListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleModify">
            <soap:operation soapAction="urn:DpThrottleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="DpThrottleRename">
            <soap:operation soapAction="urn:DpThrottleRename"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventAcknowledge">
            <soap:operation soapAction="urn:EventAcknowledge"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventDelete">
            <soap:operation soapAction="urn:EventDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventGenerate">
            <soap:operation soapAction="urn:EventGenerate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventListIterEnd">
            <soap:operation soapAction="urn:EventListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventListIterNext">
            <soap:operation soapAction="urn:EventListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventListIterStart">
            <soap:operation soapAction="urn:EventListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventStatusChangeListIterEnd">
            <soap:operation soapAction="urn:EventStatusChangeListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventStatusChangeListIterNext">
            <soap:operation soapAction="urn:EventStatusChangeListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventStatusChangeListIterStart">
            <soap:operation soapAction="urn:EventStatusChangeListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventclassAddCustom">
            <soap:operation soapAction="urn:EventclassAddCustom"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventclassDeleteCustom">
            <soap:operation soapAction="urn:EventclassDeleteCustom"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventclassList">
            <soap:operation soapAction="urn:EventclassList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventclassListIterEnd">
            <soap:operation soapAction="urn:EventclassListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventclassListIterNext">
            <soap:operation soapAction="urn:EventclassListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="EventclassListIterStart">
            <soap:operation soapAction="urn:EventclassListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="FcpTargetListInfoIterEnd">
            <soap:operation soapAction="urn:FcpTargetListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="FcpTargetListInfoIterNext">
            <soap:operation soapAction="urn:FcpTargetListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="FcpTargetListInfoIterStart">
            <soap:operation soapAction="urn:FcpTargetListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GraphDataListInfo">
            <soap:operation soapAction="urn:GraphDataListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GraphListInfoIterEnd">
            <soap:operation soapAction="urn:GraphListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GraphListInfoIterNext">
            <soap:operation soapAction="urn:GraphListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GraphListInfoIterStart">
            <soap:operation soapAction="urn:GraphListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupAddMember">
            <soap:operation soapAction="urn:GroupAddMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupCopy">
            <soap:operation soapAction="urn:GroupCopy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupCreate">
            <soap:operation soapAction="urn:GroupCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupDeleteMember">
            <soap:operation soapAction="urn:GroupDeleteMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupDestroy">
            <soap:operation soapAction="urn:GroupDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupGetOptions">
            <soap:operation soapAction="urn:GroupGetOptions"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupGetStatus">
            <soap:operation soapAction="urn:GroupGetStatus"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupIsMemberOf">
            <soap:operation soapAction="urn:GroupIsMemberOf"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupListIterEnd">
            <soap:operation soapAction="urn:GroupListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupListIterNext">
            <soap:operation soapAction="urn:GroupListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupListIterStart">
            <soap:operation soapAction="urn:GroupListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupMemberListIterEnd">
            <soap:operation soapAction="urn:GroupMemberListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupMemberListIterNext">
            <soap:operation soapAction="urn:GroupMemberListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupMemberListIterStart">
            <soap:operation soapAction="urn:GroupMemberListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupMove">
            <soap:operation soapAction="urn:GroupMove"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupRename">
            <soap:operation soapAction="urn:GroupRename"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="GroupSetOptions">
            <soap:operation soapAction="urn:GroupSetOptions"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostAdd">
            <soap:operation soapAction="urn:HostAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostAddLicense">
            <soap:operation soapAction="urn:HostAddLicense"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostAddOssv">
            <soap:operation soapAction="urn:HostAddOssv"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostAgentOssvServiceStart">
            <soap:operation soapAction="urn:HostAgentOssvServiceStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostAgentOssvServiceStop">
            <soap:operation soapAction="urn:HostAgentOssvServiceStop"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostCapabilityListIterEnd">
            <soap:operation soapAction="urn:HostCapabilityListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostCapabilityListIterNext">
            <soap:operation soapAction="urn:HostCapabilityListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostCapabilityListIterStart">
            <soap:operation soapAction="urn:HostCapabilityListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostCreateNdmpuser">
            <soap:operation soapAction="urn:HostCreateNdmpuser"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostDomainuserAdd">
            <soap:operation soapAction="urn:HostDomainuserAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostDomainuserListIterEnd">
            <soap:operation soapAction="urn:HostDomainuserListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostDomainuserListIterNext">
            <soap:operation soapAction="urn:HostDomainuserListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostDomainuserListIterStart">
            <soap:operation soapAction="urn:HostDomainuserListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostDomainuserPush">
            <soap:operation soapAction="urn:HostDomainuserPush"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostDomainuserRemove">
            <soap:operation soapAction="urn:HostDomainuserRemove"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostGetDefaults">
            <soap:operation soapAction="urn:HostGetDefaults"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostListInfoIterEnd">
            <soap:operation soapAction="urn:HostListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostListInfoIterNext">
            <soap:operation soapAction="urn:HostListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostListInfoIterStart">
            <soap:operation soapAction="urn:HostListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostModify">
            <soap:operation soapAction="urn:HostModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostModifyAgentCredentials">
            <soap:operation soapAction="urn:HostModifyAgentCredentials"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRoleCreate">
            <soap:operation soapAction="urn:HostRoleCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRoleDelete">
            <soap:operation soapAction="urn:HostRoleDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRoleListIterEnd">
            <soap:operation soapAction="urn:HostRoleListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRoleListIterNext">
            <soap:operation soapAction="urn:HostRoleListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRoleListIterStart">
            <soap:operation soapAction="urn:HostRoleListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRoleModify">
            <soap:operation soapAction="urn:HostRoleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostRolePush">
            <soap:operation soapAction="urn:HostRolePush"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostSetOption">
            <soap:operation soapAction="urn:HostSetOption"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserAdd">
            <soap:operation soapAction="urn:HostUserAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserDelete">
            <soap:operation soapAction="urn:HostUserDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserListIterEnd">
            <soap:operation soapAction="urn:HostUserListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserListIterNext">
            <soap:operation soapAction="urn:HostUserListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserListIterStart">
            <soap:operation soapAction="urn:HostUserListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserModify">
            <soap:operation soapAction="urn:HostUserModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserModifyPassword">
            <soap:operation soapAction="urn:HostUserModifyPassword"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUserPush">
            <soap:operation soapAction="urn:HostUserPush"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupCreate">
            <soap:operation soapAction="urn:HostUsergroupCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupDelete">
            <soap:operation soapAction="urn:HostUsergroupDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupListIterEnd">
            <soap:operation soapAction="urn:HostUsergroupListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupListIterNext">
            <soap:operation soapAction="urn:HostUsergroupListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupListIterStart">
            <soap:operation soapAction="urn:HostUsergroupListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupModify">
            <soap:operation soapAction="urn:HostUsergroupModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="HostUsergroupPush">
            <soap:operation soapAction="urn:HostUsergroupPush"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="IfcListInfoIterEnd">
            <soap:operation soapAction="urn:IfcListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="IfcListInfoIterNext">
            <soap:operation soapAction="urn:IfcListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="IfcListInfoIterStart">
            <soap:operation soapAction="urn:IfcListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="LunListInfoIterEnd">
            <soap:operation soapAction="urn:LunListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="LunListInfoIterNext">
            <soap:operation soapAction="urn:LunListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="LunListInfoIterStart">
            <soap:operation soapAction="urn:LunListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateCancel">
            <soap:operation soapAction="urn:MigrateCancel"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateChangeState">
            <soap:operation soapAction="urn:MigrateChangeState"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateCleanup">
            <soap:operation soapAction="urn:MigrateCleanup"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateComplete">
            <soap:operation soapAction="urn:MigrateComplete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateFix">
            <soap:operation soapAction="urn:MigrateFix"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateRollback">
            <soap:operation soapAction="urn:MigrateRollback"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateStart">
            <soap:operation soapAction="urn:MigrateStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateUpdate">
            <soap:operation soapAction="urn:MigrateUpdate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="MigrateVolume">
            <soap:operation soapAction="urn:MigrateVolume"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="NetifIpInterfaceListInfo">
            <soap:operation soapAction="urn:NetifIpInterfaceListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfAssocViewListIterEnd">
            <soap:operation soapAction="urn:PerfAssocViewListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfAssocViewListIterNext">
            <soap:operation soapAction="urn:PerfAssocViewListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfAssocViewListIterStart">
            <soap:operation soapAction="urn:PerfAssocViewListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfClientStatsListInfoIterEnd">
            <soap:operation soapAction="urn:PerfClientStatsListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfClientStatsListInfoIterNext">
            <soap:operation soapAction="urn:PerfClientStatsListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfClientStatsListInfoIterStart">
            <soap:operation soapAction="urn:PerfClientStatsListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfClientStatsPurge">
            <soap:operation soapAction="urn:PerfClientStatsPurge"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCollectClientOperationStatistics">
            <soap:operation soapAction="urn:PerfCollectClientOperationStatistics"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCopyCounterConfiguration">
            <soap:operation soapAction="urn:PerfCopyCounterConfiguration"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupCreate">
            <soap:operation soapAction="urn:PerfCounterGroupCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupDestroy">
            <soap:operation soapAction="urn:PerfCounterGroupDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupGetData">
            <soap:operation soapAction="urn:PerfCounterGroupGetData"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupGetDynamicDataSources">
            <soap:operation soapAction="urn:PerfCounterGroupGetDynamicDataSources"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupListInfo">
            <soap:operation soapAction="urn:PerfCounterGroupListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupListIterEnd">
            <soap:operation soapAction="urn:PerfCounterGroupListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupListIterNext">
            <soap:operation soapAction="urn:PerfCounterGroupListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupListIterStart">
            <soap:operation soapAction="urn:PerfCounterGroupListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupModify">
            <soap:operation soapAction="urn:PerfCounterGroupModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupStart">
            <soap:operation soapAction="urn:PerfCounterGroupStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfCounterGroupStop">
            <soap:operation soapAction="urn:PerfCounterGroupStop"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfDiagTroubleshoot">
            <soap:operation soapAction="urn:PerfDiagTroubleshoot"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfDisableDataCollection">
            <soap:operation soapAction="urn:PerfDisableDataCollection"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfDisableObjectUpdate">
            <soap:operation soapAction="urn:PerfDisableObjectUpdate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfEnableDataCollection">
            <soap:operation soapAction="urn:PerfEnableDataCollection"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfEnableObjectUpdate">
            <soap:operation soapAction="urn:PerfEnableObjectUpdate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfGetCounterData">
            <soap:operation soapAction="urn:PerfGetCounterData"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfGetCounterDependents">
            <soap:operation soapAction="urn:PerfGetCounterDependents"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfGetCounterListNotInView">
            <soap:operation soapAction="urn:PerfGetCounterListNotInView"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfGetDefaultView">
            <soap:operation soapAction="urn:PerfGetDefaultView"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfGetServerStatus">
            <soap:operation soapAction="urn:PerfGetServerStatus"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfObjectCounterListInfo">
            <soap:operation soapAction="urn:PerfObjectCounterListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfObjectDependentCounterListInfo">
            <soap:operation soapAction="urn:PerfObjectDependentCounterListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfObjectInstanceListIterEnd">
            <soap:operation soapAction="urn:PerfObjectInstanceListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfObjectInstanceListIterNext">
            <soap:operation soapAction="urn:PerfObjectInstanceListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfObjectInstanceListIterStart">
            <soap:operation soapAction="urn:PerfObjectInstanceListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfObjectListInfo">
            <soap:operation soapAction="urn:PerfObjectListInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfSetDefaultView">
            <soap:operation soapAction="urn:PerfSetDefaultView"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfStatusGet">
            <soap:operation soapAction="urn:PerfStatusGet"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdCreate">
            <soap:operation soapAction="urn:PerfThresholdCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdCreate2">
            <soap:operation soapAction="urn:PerfThresholdCreate2"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdDelete">
            <soap:operation soapAction="urn:PerfThresholdDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdListInfoIterEnd">
            <soap:operation soapAction="urn:PerfThresholdListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdListInfoIterNext">
            <soap:operation soapAction="urn:PerfThresholdListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdListInfoIterStart">
            <soap:operation soapAction="urn:PerfThresholdListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdListInfo2IterEnd">
            <soap:operation soapAction="urn:PerfThresholdListInfo2IterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdListInfo2IterNext">
            <soap:operation soapAction="urn:PerfThresholdListInfo2IterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdListInfo2IterStart">
            <soap:operation soapAction="urn:PerfThresholdListInfo2IterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdModify">
            <soap:operation soapAction="urn:PerfThresholdModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdModify2">
            <soap:operation soapAction="urn:PerfThresholdModify2"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateAttachObjects">
            <soap:operation soapAction="urn:PerfThresholdTemplateAttachObjects"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateCreate">
            <soap:operation soapAction="urn:PerfThresholdTemplateCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateDelete">
            <soap:operation soapAction="urn:PerfThresholdTemplateDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateDetachObjects">
            <soap:operation soapAction="urn:PerfThresholdTemplateDetachObjects"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateListInfoIterEnd">
            <soap:operation soapAction="urn:PerfThresholdTemplateListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateListInfoIterNext">
            <soap:operation soapAction="urn:PerfThresholdTemplateListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateListInfoIterStart">
            <soap:operation soapAction="urn:PerfThresholdTemplateListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfThresholdTemplateModify">
            <soap:operation soapAction="urn:PerfThresholdTemplateModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewAssociatedObjectsList">
            <soap:operation soapAction="urn:PerfViewAssociatedObjectsList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewCreate">
            <soap:operation soapAction="urn:PerfViewCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewDestroy">
            <soap:operation soapAction="urn:PerfViewDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewGetData">
            <soap:operation soapAction="urn:PerfViewGetData"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewListIterEnd">
            <soap:operation soapAction="urn:PerfViewListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewListIterNext">
            <soap:operation soapAction="urn:PerfViewListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewListIterStart">
            <soap:operation soapAction="urn:PerfViewListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewModify">
            <soap:operation soapAction="urn:PerfViewModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewObjectAssociationAdd">
            <soap:operation soapAction="urn:PerfViewObjectAssociationAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="PerfViewObjectAssociationDelete">
            <soap:operation soapAction="urn:PerfViewObjectAssociationDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyCopy">
            <soap:operation soapAction="urn:ProvisioningPolicyCopy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyCreate">
            <soap:operation soapAction="urn:ProvisioningPolicyCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyDestroy">
            <soap:operation soapAction="urn:ProvisioningPolicyDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyEditBegin">
            <soap:operation soapAction="urn:ProvisioningPolicyEditBegin"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyEditCommit">
            <soap:operation soapAction="urn:ProvisioningPolicyEditCommit"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyEditRollback">
            <soap:operation soapAction="urn:ProvisioningPolicyEditRollback"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyListIterEnd">
            <soap:operation soapAction="urn:ProvisioningPolicyListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyListIterNext">
            <soap:operation soapAction="urn:ProvisioningPolicyListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyListIterStart">
            <soap:operation soapAction="urn:ProvisioningPolicyListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ProvisioningPolicyModify">
            <soap:operation soapAction="urn:ProvisioningPolicyModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeListInfoIterEnd">
            <soap:operation soapAction="urn:QtreeListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeListInfoIterNext">
            <soap:operation soapAction="urn:QtreeListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeListInfoIterStart">
            <soap:operation soapAction="urn:QtreeListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeModify">
            <soap:operation soapAction="urn:QtreeModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeRename">
            <soap:operation soapAction="urn:QtreeRename"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeStartMonitoring">
            <soap:operation soapAction="urn:QtreeStartMonitoring"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="QtreeStopMonitoring">
            <soap:operation soapAction="urn:QtreeStopMonitoring"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAccessCheck">
            <soap:operation soapAction="urn:RbacAccessCheck"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAdminListInfoIterEnd">
            <soap:operation soapAction="urn:RbacAdminListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAdminListInfoIterNext">
            <soap:operation soapAction="urn:RbacAdminListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAdminListInfoIterStart">
            <soap:operation soapAction="urn:RbacAdminListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAdminRoleAdd">
            <soap:operation soapAction="urn:RbacAdminRoleAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAdminRoleInfoList">
            <soap:operation soapAction="urn:RbacAdminRoleInfoList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacAdminRoleRemove">
            <soap:operation soapAction="urn:RbacAdminRoleRemove"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacOperationAdd">
            <soap:operation soapAction="urn:RbacOperationAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacOperationDelete">
            <soap:operation soapAction="urn:RbacOperationDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacOperationInfoList">
            <soap:operation soapAction="urn:RbacOperationInfoList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleAdd">
            <soap:operation soapAction="urn:RbacRoleAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleAdminInfoList">
            <soap:operation soapAction="urn:RbacRoleAdminInfoList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleCapabilityAdd">
            <soap:operation soapAction="urn:RbacRoleCapabilityAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleCapabilityRemove">
            <soap:operation soapAction="urn:RbacRoleCapabilityRemove"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleDelete">
            <soap:operation soapAction="urn:RbacRoleDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleDisinherit">
            <soap:operation soapAction="urn:RbacRoleDisinherit"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleInfoList">
            <soap:operation soapAction="urn:RbacRoleInfoList"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleInherit">
            <soap:operation soapAction="urn:RbacRoleInherit"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="RbacRoleModify">
            <soap:operation soapAction="urn:RbacRoleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportGraphListInfoIterEnd">
            <soap:operation soapAction="urn:ReportGraphListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportGraphListInfoIterNext">
            <soap:operation soapAction="urn:ReportGraphListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportGraphListInfoIterStart">
            <soap:operation soapAction="urn:ReportGraphListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportListInfoIterEnd">
            <soap:operation soapAction="urn:ReportListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportListInfoIterNext">
            <soap:operation soapAction="urn:ReportListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportListInfoIterStart">
            <soap:operation soapAction="urn:ReportListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportOutputDelete">
            <soap:operation soapAction="urn:ReportOutputDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportOutputListInfoIterEnd">
            <soap:operation soapAction="urn:ReportOutputListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportOutputListInfoIterNext">
            <soap:operation soapAction="urn:ReportOutputListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportOutputListInfoIterStart">
            <soap:operation soapAction="urn:ReportOutputListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportOutputRead">
            <soap:operation soapAction="urn:ReportOutputRead"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleAdd">
            <soap:operation soapAction="urn:ReportScheduleAdd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleDelete">
            <soap:operation soapAction="urn:ReportScheduleDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleDisable">
            <soap:operation soapAction="urn:ReportScheduleDisable"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleEnable">
            <soap:operation soapAction="urn:ReportScheduleEnable"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleListInfoIterEnd">
            <soap:operation soapAction="urn:ReportScheduleListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleListInfoIterNext">
            <soap:operation soapAction="urn:ReportScheduleListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleListInfoIterStart">
            <soap:operation soapAction="urn:ReportScheduleListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleModify">
            <soap:operation soapAction="urn:ReportScheduleModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ReportScheduleRun">
            <soap:operation soapAction="urn:ReportScheduleRun"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolAddMember">
            <soap:operation soapAction="urn:ResourcepoolAddMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolCreate">
            <soap:operation soapAction="urn:ResourcepoolCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolDestroy">
            <soap:operation soapAction="urn:ResourcepoolDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolGetDefaults">
            <soap:operation soapAction="urn:ResourcepoolGetDefaults"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolListInfoIterEnd">
            <soap:operation soapAction="urn:ResourcepoolListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolListInfoIterNext">
            <soap:operation soapAction="urn:ResourcepoolListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolListInfoIterStart">
            <soap:operation soapAction="urn:ResourcepoolListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolMemberListInfoIterEnd">
            <soap:operation soapAction="urn:ResourcepoolMemberListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolMemberListInfoIterNext">
            <soap:operation soapAction="urn:ResourcepoolMemberListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolMemberListInfoIterStart">
            <soap:operation soapAction="urn:ResourcepoolMemberListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolModify">
            <soap:operation soapAction="urn:ResourcepoolModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolModifyMember">
            <soap:operation soapAction="urn:ResourcepoolModifyMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolRemoveMember">
            <soap:operation soapAction="urn:ResourcepoolRemoveMember"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="ResourcepoolUpdateFreeSpaceStatus">
            <soap:operation soapAction="urn:ResourcepoolUpdateFreeSpaceStatus"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="SnapshotGetReclaimableInfo">
            <soap:operation soapAction="urn:SnapshotGetReclaimableInfo"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="SnapshotListInfoIterEnd">
            <soap:operation soapAction="urn:SnapshotListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="SnapshotListInfoIterNext">
            <soap:operation soapAction="urn:SnapshotListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="SnapshotListInfoIterStart">
            <soap:operation soapAction="urn:SnapshotListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceCreate">
            <soap:operation soapAction="urn:StorageServiceCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceDatasetListIterEnd">
            <soap:operation soapAction="urn:StorageServiceDatasetListIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceDatasetListIterNext">
            <soap:operation soapAction="urn:StorageServiceDatasetListIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceDatasetListIterStart">
            <soap:operation soapAction="urn:StorageServiceDatasetListIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceDatasetModify">
            <soap:operation soapAction="urn:StorageServiceDatasetModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceDatasetProvision">
            <soap:operation soapAction="urn:StorageServiceDatasetProvision"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceDestroy">
            <soap:operation soapAction="urn:StorageServiceDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceListInfoIterEnd">
            <soap:operation soapAction="urn:StorageServiceListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceListInfoIterNext">
            <soap:operation soapAction="urn:StorageServiceListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceListInfoIterStart">
            <soap:operation soapAction="urn:StorageServiceListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="StorageServiceModify">
            <soap:operation soapAction="urn:StorageServiceModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="TimezoneGetDefaults">
            <soap:operation soapAction="urn:TimezoneGetDefaults"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="TimezoneListInfoIterEnd">
            <soap:operation soapAction="urn:TimezoneListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="TimezoneListInfoIterNext">
            <soap:operation soapAction="urn:TimezoneListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="TimezoneListInfoIterStart">
            <soap:operation soapAction="urn:TimezoneListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="TimezoneValidate">
            <soap:operation soapAction="urn:TimezoneValidate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserFavoriteReportDelete">
            <soap:operation soapAction="urn:UserFavoriteReportDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserFavoriteReportListInfoIterEnd">
            <soap:operation soapAction="urn:UserFavoriteReportListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserFavoriteReportListInfoIterNext">
            <soap:operation soapAction="urn:UserFavoriteReportListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserFavoriteReportListInfoIterStart">
            <soap:operation soapAction="urn:UserFavoriteReportListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserRecentReportDelete">
            <soap:operation soapAction="urn:UserRecentReportDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserRecentReportListInfoIterEnd">
            <soap:operation soapAction="urn:UserRecentReportListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserRecentReportListInfoIterNext">
            <soap:operation soapAction="urn:UserRecentReportListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="UserRecentReportListInfoIterStart">
            <soap:operation soapAction="urn:UserRecentReportListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerCreate">
            <soap:operation soapAction="urn:VfilerCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerDestroy">
            <soap:operation soapAction="urn:VfilerDestroy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerSetup">
            <soap:operation soapAction="urn:VfilerSetup"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateCopy">
            <soap:operation soapAction="urn:VfilerTemplateCopy"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateCreate">
            <soap:operation soapAction="urn:VfilerTemplateCreate"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateDelete">
            <soap:operation soapAction="urn:VfilerTemplateDelete"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateListInfoIterEnd">
            <soap:operation soapAction="urn:VfilerTemplateListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateListInfoIterNext">
            <soap:operation soapAction="urn:VfilerTemplateListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateListInfoIterStart">
            <soap:operation soapAction="urn:VfilerTemplateListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VfilerTemplateModify">
            <soap:operation soapAction="urn:VfilerTemplateModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VolumeListInfoIterEnd">
            <soap:operation soapAction="urn:VolumeListInfoIterEnd"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VolumeListInfoIterNext">
            <soap:operation soapAction="urn:VolumeListInfoIterNext"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VolumeListInfoIterStart">
            <soap:operation soapAction="urn:VolumeListInfoIterStart"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
        <operation name="VolumeModify">
            <soap:operation soapAction="urn:VolumeModify"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
    </binding>
    <service name="DfmService">
        <port binding="na:DfmBinding" name="DfmPort">
            <soap:address location="https://HOST_NAME:8488/apis/soap/v1"/>
        </port>
    </service>
</definitions>
